This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
ADMIN_BRANDING_SETUP.md
AGENTS.md
App.tsx
BRANDING_SETUP.sql
check-db.js
CLAUDE.md
CLINICAL_DATA_MIGRATION.sql
components/BottomNav.tsx
components/PrescriptionComponent.tsx
components/PrescriptionPrinter.tsx
components/RefreshButton.tsx
components/Sidebar.tsx
components/SyncStatus.tsx
components/ui/SearchableSelect.tsx
constants.ts
context/BrandingContext.tsx
data/egyptian_drugs.ts
data/medical_terms.ts
DATABASE_MIGRATION.md
debug-sync.js
DEPLOYMENT_QUICK_START.md
electron/main.js
electron/preload.js
ENV_SETUP.md
index.html
index.tsx
INFERTILITY_WORKUPS_SETUP.sql
IVF_CYCLES_SETUP.sql
IVF_MIGRATION_GUIDE.md
metadata.json
MIGRATION_ADD_RX_NOTES.sql
OBSTETRICS_IMPLEMENTATION.md
OBSTETRICS_SETUP_V2.sql
OBSTETRICS_SETUP.sql
package.json
pages/AdminDashboard.tsx
pages/ClinicalStation.tsx
pages/components/InfertilityWizard.tsx
pages/components/obstetrics/ANCFlowSheet.tsx
pages/components/obstetrics/FetalGrowthChart.tsx
pages/components/obstetrics/PregnancyHeader.tsx
pages/components/obstetrics/RiskAssessment.tsx
pages/Dashboard.tsx
pages/Gynecology.tsx
pages/IvfJourney.tsx
pages/Login.tsx
pages/ObstetricsDashboard.tsx
pages/PatientMasterRecord.tsx
pages/Reception.tsx
pages/Settings.tsx
postcss.config.js
POWERSYNC_PUBLICATION_SETUP.sql
POWERSYNC_SCHEMA_SETUP.sql
POWERSYNC_SETUP_GUIDE.md
POWERSYNC_SYNC_RULES.yaml
public/apple-touch-icon.png
public/favicon-96x96.png
public/manifest.json
public/powersync.worker.js
public/pwa-192x192.png
public/pwa-512x512.png
public/sw.js
public/wa-sqlite-async.wasm
PWA_SETUP.md
QUICK_FIX.sql
README.md
SEED_DATA.sql
services/authService.ts
services/dbService.ts
services/ivfService.ts
services/obstetricsService.ts
services/supabaseClient.ts
services/visitsService.ts
services/workupService.ts
src/components/HistorySidebar.tsx
src/components/SyncStatus.tsx
src/context/PowerSyncContext.tsx
src/hooks/usePatients.ts
src/hooks/usePowerSync.ts
src/hooks/useSyncStatus.ts
src/lib/networkStatus.ts
src/lib/powerSyncHelpers.ts
src/lib/pwa.ts
src/lib/supabase.ts
src/powersync/AppSchema.ts
src/powersync/client.ts
src/powersync/connector.ts
src/powersync/schema.ts
src/powersync/SupabaseConnector.ts
src/powersync/SyncRules.ts
src/powersync/worker.ts
src/services/syncService.ts
src/utils/connectionDiagnostics.ts
styles.css
SUPABASE_SETUP.sql
tailwind.config.js
tsconfig.json
types.ts
vercel.json
vite.config.ts
write_file.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="ADMIN_BRANDING_SETUP.md">
# Admin Dashboard & Dynamic Branding - Setup Guide

## ğŸ“‹ Overview

The admin dashboard enables real-time customization of:
- **Clinic name & contact info** (address, phone)
- **Clinic logo** (upload & display)
- **Brand colors** (primary, secondary, accent)
- **Prescription settings** (default templates)
- **Record management** (view & delete clinical records)

Changes are instantly reflected across the entire application (Sidebar, Dashboard, Prescriptions).

---

## ğŸ”§ Setup Steps

### Step 1: Create Database Table

Execute this SQL in your **Supabase SQL Editor**:

```sql
CREATE TABLE IF NOT EXISTS app_settings (
  id INTEGER PRIMARY KEY DEFAULT 1,
  clinic_name TEXT NOT NULL DEFAULT 'Ù†Ø¸Ø§Ù… Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±',
  logo_url TEXT,
  clinic_address TEXT,
  clinic_phone TEXT,
  primary_color TEXT DEFAULT '#2d5a6b',
  secondary_color TEXT DEFAULT '#00838f',
  accent_color TEXT DEFAULT '#00bcd4',
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_by UUID,
  CONSTRAINT single_row CHECK (id = 1),
  FOREIGN KEY (updated_by) REFERENCES auth.users(id)
);

ALTER TABLE app_settings ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can read app_settings" ON app_settings;
CREATE POLICY "Users can read app_settings"
  ON app_settings FOR SELECT
  TO authenticated
  USING (true);

DROP POLICY IF EXISTS "Authenticated users can update app_settings" ON app_settings;
CREATE POLICY "Authenticated users can update app_settings"
  ON app_settings FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

INSERT INTO app_settings (id, clinic_name, logo_url)
VALUES (1, 'Ù†Ø¸Ø§Ù… Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±', NULL)
ON CONFLICT (id) DO NOTHING;
```

âœ… **Verify**: Go to Supabase â†’ SQL Editor â†’ Run the query above

---

### Step 2: Create Storage Bucket for Logo Upload

1. **Go to Supabase Dashboard** â†’ **Storage** tab
2. Click **"Create a new bucket"**
3. **Bucket name**: `branding` (exactly as shown)
4. **Privacy**: Select **"Public bucket"**
5. Click **"Create bucket"**

---

### Step 3: Set Storage Policies

Execute this SQL in **Supabase SQL Editor**:

```sql
-- Allow authenticated users to upload files
DROP POLICY IF EXISTS "Allow authenticated users to upload branding" ON storage.objects;
CREATE POLICY "Allow authenticated users to upload branding"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (bucket_id = 'branding');

-- Allow authenticated users to delete their files
DROP POLICY IF EXISTS "Allow authenticated users to delete branding" ON storage.objects;
CREATE POLICY "Allow authenticated users to delete branding"
  ON storage.objects FOR DELETE
  TO authenticated
  USING (bucket_id = 'branding');

-- Allow public read access (so logos display)
DROP POLICY IF EXISTS "Allow public read access to branding" ON storage.objects;
CREATE POLICY "Allow public read access to branding"
  ON storage.objects FOR SELECT
  TO public
  USING (bucket_id = 'branding');
```

âœ… **Verify**: In Storage tab, you should see "branding" bucket with policies set

---

## ğŸš€ Using the Admin Dashboard

### Access Admin Panel

1. Login to the application
2. **Desktop**: Click **"Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…"** (Admin) in the Sidebar
3. **Mobile**: Scroll bottom navigation â†’ tap **"Admin"** button

### Customize Branding

**Tab 1: ØªØ®ØµÙŠØµ Ø§Ù„ØªØµÙ…ÙŠÙ… (Design Customization)**

- **Ø§Ø³Ù… Ø§Ù„Ù…Ø±ÙƒØ²**: Update clinic name (appears in Sidebar & Dashboard)
- **Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ**: Clinic phone number
- **Ø§Ù„Ø¹Ù†ÙˆØ§Ù†**: Clinic address
- **Ø´Ø¹Ø§Ø± Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©**: Upload clinic logo
  - Drag & drop or click to select image
  - Supported formats: PNG, JPG, GIF
  - Max size: 5 MB
- **Colors**: Adjust primary, secondary, accent colors using color picker
- Click **"Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª"** to save

---

### Configure Prescriptions

**Tab 2: Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±ÙˆØ´ØªØ© (Prescription Settings)**

- **Default drug category**: Select which category appears first
- **Default instructions**: Add standard prescription notes
- Available drugs database shown with categories

---

### Manage Records

**Tab 3: Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø³Ø¬Ù„Ø§Øª (Records Management)**

- View last 50 clinical visits
- **Delete**: Remove records from system
- **Refresh**: Click â† to reload latest records

---

## âœ¨ Features Enabled After Setup

### 1. **Dynamic Sidebar**
- Clinic logo displays in Sidebar header (if uploaded)
- Clinic name from settings (instead of hardcoded "Nile IVF Center")

### 2. **Dynamic Dashboard**
- Header shows clinic name from settings

### 3. **Dynamic Prescriptions**
- Prescription print headers use:
  - Clinic name from settings
  - Clinic address & phone from settings
  - Clinic logo (if uploaded) or default symbol

### 4. **Real-time Updates**
- All changes apply immediately without app restart
- Changes persist to Supabase database

---

## ğŸ› Troubleshooting

### Error: "ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„Ø´Ø¹Ø§Ø±" (Logo upload failed)

**Solution**: 
- Make sure "branding" bucket exists in Supabase Storage
- Verify it's set as "Public bucket"
- Run storage policies from Step 3 above

### Error: "ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª" (Settings save failed)

**Check**:
1. Is `app_settings` table created? (Run SQL from Step 1)
2. Are RLS policies enabled?
3. Is the table queryable? (`SELECT * FROM app_settings` should return 1 row)

### Clinic name not updating in Sidebar

**Solution**:
- Hard refresh browser: **Ctrl+Shift+R** (Windows) or **Cmd+Shift+R** (Mac)
- Close & reopen the app

---

## ğŸ“ Database Schema Reference

```typescript
app_settings {
  id: 1 (fixed, single row)
  clinic_name: string          // "Ù†Ø¸Ø§Ù… Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±"
  logo_url: string | null       // URL from branding bucket
  clinic_address: string | null
  clinic_phone: string | null
  primary_color: string         // "#2d5a6b"
  secondary_color: string       // "#00838f"
  accent_color: string          // "#00bcd4"
  updated_at: timestamp
  updated_by: uuid (user id)
}
```

---

## ğŸ” Security

- âœ… RLS policies restrict access to authenticated users
- âœ… Settings table has single-row constraint (immutable singleton)
- âœ… Storage bucket marked as public (for logo display)
- âœ… Upload policies verify user authentication

---

## ğŸ“¦ Files Modified

- `context/BrandingContext.tsx` - Global branding state & API
- `pages/AdminDashboard.tsx` - Admin control panel UI
- `components/Sidebar.tsx` - Dynamic branding display
- `pages/Dashboard.tsx` - Dynamic clinic name
- `components/PrescriptionPrinter.tsx` - Dynamic prescription headers
- `types.ts` - Added ADMIN page enum
- `App.tsx` - BrandingProvider wrapper
- `BRANDING_SETUP.sql` - Database setup script

---

## âœ… Verification Checklist

- [ ] Executed SQL from Step 1 (app_settings table)
- [ ] Created "branding" storage bucket (Step 2)
- [ ] Executed SQL from Step 3 (storage policies)
- [ ] Can access Admin Dashboard from app
- [ ] Can update clinic name without logo (settings save)
- [ ] Can upload logo successfully
- [ ] Changes appear in Sidebar, Dashboard, Prescriptions
- [ ] Hardcoded text replaced with dynamic values

---

## ğŸ¯ Next Steps

1. Test all admin features
2. Verify changes persist after browser refresh
3. Test prescription printing with new branding
4. (Optional) Customize color scheme to match your clinic identity
</file>

<file path="BRANDING_SETUP.sql">
-- ============================================================================
-- Nile IVF Center - Dynamic Branding Setup
-- ============================================================================
-- This script creates the app_settings table and enables dynamic branding
-- for clinic name, logo, and color customization.
-- ============================================================================

-- 1. Create app_settings table for dynamic branding
CREATE TABLE IF NOT EXISTS app_settings (
  id INTEGER PRIMARY KEY DEFAULT 1,
  clinic_name TEXT NOT NULL DEFAULT 'Ù†Ø¸Ø§Ù… Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±',
  logo_url TEXT,
  clinic_address TEXT,
  clinic_phone TEXT,
  primary_color TEXT DEFAULT '#2d5a6b',
  secondary_color TEXT DEFAULT '#00838f',
  accent_color TEXT DEFAULT '#00bcd4',
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_by UUID,
  CONSTRAINT single_row CHECK (id = 1),
  FOREIGN KEY (updated_by) REFERENCES auth.users(id)
);

-- 2. Enable RLS on app_settings
ALTER TABLE app_settings ENABLE ROW LEVEL SECURITY;

-- 3. RLS Policies for app_settings table
-- Policy: Authenticated users can read app_settings
DROP POLICY IF EXISTS "Users can read app_settings" ON app_settings;
CREATE POLICY "Users can read app_settings"
  ON app_settings FOR SELECT
  TO authenticated
  USING (true);

-- Policy: Authenticated users can update app_settings
DROP POLICY IF EXISTS "Authenticated users can update app_settings" ON app_settings;
CREATE POLICY "Authenticated users can update app_settings"
  ON app_settings FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

-- 4. Insert default settings row
INSERT INTO app_settings (id, clinic_name, logo_url)
VALUES (1, 'Ù†Ø¸Ø§Ù… Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±', NULL)
ON CONFLICT (id) DO NOTHING;

-- ============================================================================
-- NOTE: For Storage Bucket Creation, use Supabase Dashboard:
-- ============================================================================
-- 1. Go to Supabase Dashboard â†’ Storage
-- 2. Click "Create new bucket"
-- 3. Enter name: "branding"
-- 4. Choose "Public bucket"
-- 5. Click "Create bucket"
-- 
-- Then run the storage policies below in SQL Editor:
-- ============================================================================

-- 5. Storage Policies (Run these AFTER creating "branding" bucket)
DROP POLICY IF EXISTS "Allow authenticated users to upload branding" ON storage.objects;
CREATE POLICY "Allow authenticated users to upload branding"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (bucket_id = 'branding');

DROP POLICY IF EXISTS "Allow authenticated users to delete branding" ON storage.objects;
CREATE POLICY "Allow authenticated users to delete branding"
  ON storage.objects FOR DELETE
  TO authenticated
  USING (bucket_id = 'branding');

DROP POLICY IF EXISTS "Allow public read access to branding" ON storage.objects;
CREATE POLICY "Allow public read access to branding"
  ON storage.objects FOR SELECT
  TO public
  USING (bucket_id = 'branding');

-- ============================================================================
-- Verification Queries
-- ============================================================================
-- Verify table was created:
-- SELECT * FROM app_settings;
--
-- Verify bucket exists (use Supabase Dashboard Storage tab):
-- Should see "branding" bucket listed
</file>

<file path="CLAUDE.md">
# Development Commands & Notes

## Build & Type Checking
```bash
npm run build        # Builds the project (runs tsc then vite build)
npx tsc --noEmit    # Type check only without building
```

## Running the Application
```bash
npm run dev          # Start development server
npm run preview      # Preview production build
```

## Database Migrations
When new database tables are needed, create SQL files in the project root:
- `IVF_CYCLES_SETUP.sql` - IVF cycle management tables
- `OBSTETRICS_SETUP_V2.sql` - Obstetrics module
- `CLINICAL_DATA_MIGRATION.sql` - Visits and clinical data
- `BRANDING_SETUP.sql` - App settings and branding

To apply migrations:
1. Go to Supabase Dashboard â†’ SQL Editor
2. Create new query
3. Copy-paste the entire SQL file content
4. Click Run

## Project Structure
```
â”œâ”€â”€ pages/               # React page components
â”œâ”€â”€ components/          # Reusable React components
â”œâ”€â”€ services/            # API and Supabase service layer
â”‚   â”œâ”€â”€ ivfService.ts       # IVF cycle database operations
â”‚   â”œâ”€â”€ visitsService.ts    # Patient visits
â”‚   â”œâ”€â”€ supabaseClient.ts   # Supabase initialization
â”‚   â””â”€â”€ authService.ts      # Authentication
â”œâ”€â”€ types.ts             # TypeScript interfaces
â”œâ”€â”€ constants.ts         # Protocols, drugs, UI constants
â””â”€â”€ [SQL files]          # Database migrations
```

## Recent Changes (IVF Assessment Fix)

### Issue: "Failed to save assessment" error
**Root Cause:** Missing `ivf_cycles` table with JSONB columns in Supabase

### Solution Applied:
1. **Created `IVF_CYCLES_SETUP.sql`**
   - Defines `ivf_cycles` table with assessment_data, lab_data, transfer_data, outcome_data (JSONB)
   - Defines `stimulation_logs` table for daily tracking
   - Sets up RLS policies for data isolation
   - Creates performance indexes

2. **Enhanced Error Handling in `ivfService.ts`**
   - Added try-catch blocks to all update functions
   - Added detailed console error logging
   - Changed error messages from generic to specific

3. **Improved Error Display in `IvfJourney.tsx`**
   - All save functions now display detailed error messages
   - Added console logging for debugging
   - Toast messages include actual error details

### How to Fix:
1. Run the `IVF_CYCLES_SETUP.sql` migration in Supabase SQL Editor
2. Refresh the browser
3. Try saving assessment again - error message will show what's wrong

## Key Services

### ivfService.ts Functions
- `calculateBMI()` - BMI calculation with alert flag
- `calculateTMSC()` - Total Motile Sperm Count (triggers ICSI at <5M)
- `classifyOvarianReserve()` - Poor/Normal/High responder classification
- `calculateMaturationRate()` - Oocyte maturation percentage
- `calculateFertilizationRate()` - 2PN fertilization percentage
- `db.getCycles()` - Fetch all cycles with stimulation logs
- `db.saveCycle()` - Create new IVF cycle
- `db.updateCycleAssessment()` - Save couple/male/female factor assessments
- `db.updateCycleLabData()` - Save OPU and embryo data
- `db.updateCycleTransfer()` - Save transfer details
- `db.updateCycleOutcome()` - Save beta-HCG and pregnancy outcomes

## IVF Journey Component
The `/ivf-journey` page has 4 tabs:

1. **Assessment Tab**
   - Couple profile (infertility duration/type, BMI)
   - Male factor with WHO 2021 parameters and TMSC calculation
   - Female factor with ovarian reserve classification
   - Tubal-uterine findings (HSG, hysteroscopy)
   - Protocol selection with "Generate Prescription" button

2. **Stimulation Tab**
   - Hormone trends chart (E2, LH, follicle progression)
   - Daily stimulation log table with FSH/HMG/E2/LH/follicles/endometrium

3. **OPU & Embryology Tab**
   - OPU day data (total oocytes, MII, MI, GV, atretic)
   - Auto-calculated maturation rate
   - Fertilization data (2PN count)
   - Auto-calculated fertilization rate
   - Embryo grading (Day 3: A/B/C, Day 5: expanded/hatching)

4. **Transfer & Outcome Tab**
   - Transfer details (date, number, embryo quality, catheter difficulty)
   - Luteal support multi-select (6 options)
   - Cycle outcome (Beta-HCG, clinical pregnancy markers)

## Debugging Tips

### "Failed to save assessment" troubleshooting:
1. Open browser console (F12)
2. Look for detailed error in red text
3. Check Supabase connection in `services/supabaseClient.ts`
4. Verify RLS policies are enabled
5. Verify doctor record exists in database

### Database Issues:
```sql
-- Check if tables exist
SELECT * FROM information_schema.tables WHERE table_schema = 'public';

-- Check RLS is enabled
SELECT tablename, rowsecurity FROM pg_tables 
WHERE schemaname = 'public' AND tablename IN ('ivf_cycles', 'stimulation_logs');

-- Check doctor relationship
SELECT id, user_id FROM doctors WHERE user_id = '[current_user_id]';
```

## Performance Notes
- Current build size: ~993KB (gzip: 261KB)
- Consider code-splitting for large components if exceeds 500KB
- All database queries use indexes for optimal performance

## RLS Policy Structure
```
auth.users â†’ doctors (via user_id)
           â†’ patients (via doctor_id) 
           â†’ ivf_cycles (via doctor_id)
           â†’ stimulation_logs (via cycle_id)
```

Each doctor can only see their own data through RLS policies.
</file>

<file path="CLINICAL_DATA_MIGRATION.sql">
-- ============================================================================
-- VISITS TABLE MIGRATION - Create visits table and add clinical columns
-- ============================================================================

-- Create visits table if it doesn't exist
CREATE TABLE IF NOT EXISTS visits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  department TEXT DEFAULT NULL,
  diagnosis TEXT DEFAULT '',
  prescription JSONB DEFAULT '[]',
  notes TEXT DEFAULT '',
  clinical_data JSONB DEFAULT NULL,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- Add department column to visits table (if table already exists)
ALTER TABLE visits ADD COLUMN IF NOT EXISTS department TEXT DEFAULT NULL;

-- Add clinical_data column to visits table (if table already exists)
ALTER TABLE visits ADD COLUMN IF NOT EXISTS clinical_data JSONB DEFAULT NULL;

-- Create index for better query performance on clinical_data
CREATE INDEX IF NOT EXISTS idx_visits_clinical_data ON visits USING GIN (clinical_data);

-- Create index for department queries
CREATE INDEX IF NOT EXISTS idx_visits_department ON visits (department);

-- Create index for patient visits with clinical data
CREATE INDEX IF NOT EXISTS idx_visits_patient_clinical ON visits (patient_id, date DESC) WHERE clinical_data IS NOT NULL;

-- Enable RLS on visits table
ALTER TABLE visits ENABLE ROW LEVEL SECURITY;

-- RLS Policies for visits table
DROP POLICY IF EXISTS "Doctors can read visits" ON visits;
DROP POLICY IF EXISTS "Doctors can insert visits" ON visits;
DROP POLICY IF EXISTS "Doctors can update visits" ON visits;

CREATE POLICY "Doctors can read visits" ON visits
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients WHERE doctor_id = auth.uid()
    )
  );

CREATE POLICY "Doctors can insert visits" ON visits
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients WHERE doctor_id = auth.uid()
    )
  );

CREATE POLICY "Doctors can update visits" ON visits
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients WHERE doctor_id = auth.uid()
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients WHERE doctor_id = auth.uid()
    )
  );

-- Add comments for documentation
COMMENT ON COLUMN visits.department IS 'Department identifier (GYNA, OBS, IVF_STIM, IVF_LAB)';
COMMENT ON COLUMN visits.clinical_data IS 'Structured clinical data stored as JSONB for different departments (gynecology, obstetrics, ivf)';
COMMENT ON INDEX idx_visits_clinical_data IS 'GIN index for efficient JSONB queries on clinical_data';
COMMENT ON INDEX idx_visits_department IS 'Index for filtering visits by department';
COMMENT ON INDEX idx_visits_patient_clinical IS 'Index for patient clinical visits ordered by date';
</file>

<file path="components/BottomNav.tsx">
import React from 'react';
import { LayoutDashboard, Users, Baby, Heart, Settings, Activity, FileText, LogOut } from 'lucide-react';
import { Page } from '../types';

interface Props {
  activePage: Page;
  setPage: (p: Page) => void;
  onLogout: () => void;
}

const BottomNav: React.FC<Props> = ({ activePage, setPage, onLogout }) => {
  // Consolidated navigation items in logical order
  const navItems = [
    { id: Page.HOME, label: 'Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©', icon: LayoutDashboard, action: null },
    { id: Page.RECEPTION, label: 'Ø§Ù„Ù…Ø±Ø¶Ù‰', icon: Users, action: null },
    { id: Page.GYNECOLOGY, label: 'Ø§Ù„Ù†Ø³Ø§Ø¡', icon: Activity, action: null },
    { id: Page.OBSTETRICS, label: 'Ø§Ù„Ø­Ù…Ù„', icon: Heart, action: null },
    { id: Page.IVF, label: 'Ø§Ù„Ø®ØµÙˆØ¨Ø©', icon: Baby, action: null },
    { id: Page.PATIENT_RECORD, label: 'Ø§Ù„Ø³Ø¬Ù„Ø§Øª', icon: FileText, action: null },
    { id: Page.SETTINGS, label: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª', icon: Settings, action: null },
    { id: 'logout', label: 'Ø®Ø±ÙˆØ¬', icon: LogOut, action: onLogout },
  ];

  const NavButton: React.FC<{ item: any, isActive: boolean }> = ({ item, isActive }) => {
    const Icon = typeof item.icon === 'string' ? null : item.icon;
    return (
      <button
        onClick={() => {
          if (item.action) {
            item.action();
          } else {
            setPage(item.id);
          }
        }}
        className={`flex-none flex flex-col items-center justify-center min-w-[4.5rem] py-2 pb-safe transition-colors duration-200 ${
          isActive
            ? 'text-teal-600 bg-teal-50 border-t-4 border-teal-600'
            : item.id === 'logout'
            ? 'text-red-600 hover:bg-red-50'
            : 'text-gray-600 hover:bg-gray-50'
        }`}
        aria-label={item.label}
        aria-current={isActive ? 'page' : undefined}
      >
        {Icon && <Icon className="w-5 h-5 mb-1" />}
        <span className="text-xs font-medium text-center leading-tight">{item.label}</span>
      </button>
    );
  };

  return (
    <>
      {/* Mobile Bottom Navigation - Horizontally Scrollable */}
      <nav className="fixed bottom-0 left-0 right-0 md:hidden bg-white border-t border-gray-200 shadow-xl z-50">
        <div className="flex overflow-x-auto w-full bg-white border-t border-gray-200 no-scrollbar">
          {navItems.map((item) => (
            <NavButton
              key={item.id}
              item={item}
              isActive={activePage === item.id}
            />
          ))}
        </div>
      </nav>
    </>
  );
};

export default BottomNav;
</file>

<file path="constants.ts">
// Egyptian IVF Medications Database
export const EGYPTIAN_DRUGS = {
  "Induction (Stimulation)": {
    "Clomid 50mg": { active: "Clomiphene Citrate", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 2 Ù„Ù€ 6 Ù„Ù„Ø¯ÙˆØ±Ø©" },
    "Clostilbegyt 50mg": { active: "Clomiphene Citrate", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 2 Ù„Ù€ 6 Ù„Ù„Ø¯ÙˆØ±Ø©" },
    "Technovula 50mg": { active: "Clomiphene Citrate", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 2 Ù„Ù€ 6 Ù„Ù„Ø¯ÙˆØ±Ø©" },
    "Femara 2.5mg": { active: "Letrozole", dose: "Ù‚Ø±ØµÙŠÙ† Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 3 Ù„Ù€ 7 Ù„Ù„Ø¯ÙˆØ±Ø©" },
    "Letrozole 2.5mg": { active: "Letrozole", dose: "Ù‚Ø±ØµÙŠÙ† Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 3 Ù„Ù€ 7 Ù„Ù„Ø¯ÙˆØ±Ø©" },
    "Nolvadex 10mg": { active: "Tamoxifen", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 2 Ù„Ù€ 6 Ù„Ù„Ø¯ÙˆØ±Ø©" },
    "Gonal-F 75 IU": { active: "Follitropin Alpha", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¬Ø¯ÙˆÙ„" },
    "Gonal-F 300/450/900 Pen": { active: "Follitropin Alpha", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹ (Ø­Ø¯Ø¯ Ø§Ù„Ø¬Ø±Ø¹Ø©)" },
    "Fostimon 75 IU": { active: "Urofollitropin (FSH)", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„/ØªØ­Øª Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Fostimon 150 IU": { active: "Urofollitropin (FSH)", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„/ØªØ­Øª Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Merional 75 IU": { active: "HMG (FSH+LH)", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„/ØªØ­Øª Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Merional 150 IU": { active: "HMG (FSH+LH)", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„/ØªØ­Øª Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Menogon 75 IU": { active: "HMG", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Menopur 75 IU": { active: "HP-HMG", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„/ØªØ­Øª Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Pergoveris Pen": { active: "FSH + LH", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Epigonal 75 IU": { active: "HMG", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„ ÙŠÙˆÙ…ÙŠØ§Ù‹" }
  },
  "Trigger Shots": {
    "Choriomon 5000 IU": { active: "HCG", dose: "Ø­Ù‚Ù†ØªÙŠÙ† Ø¹Ø¶Ù„ ÙÙŠ ØªÙˆÙ‚ÙŠØª Ù…Ø­Ø¯Ø¯ (36 Ø³Ø§Ø¹Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø³Ø­Ø¨)" },
    "Epifasi 5000 IU": { active: "HCG", dose: "Ø­Ù‚Ù†ØªÙŠÙ† Ø¹Ø¶Ù„ ÙÙŠ ØªÙˆÙ‚ÙŠØª Ù…Ø­Ø¯Ø¯" },
    "Pregnyl 5000 IU": { active: "HCG", dose: "Ø­Ù‚Ù†ØªÙŠÙ† Ø¹Ø¶Ù„ ÙÙŠ ØªÙˆÙ‚ÙŠØª Ù…Ø­Ø¯Ø¯" },
    "Ovitrelle 250mcg": { active: "Choriogonadotropin Alfa", dose: "Ø­Ù‚Ù†Ø© ÙƒØ§Ù…Ù„Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙÙŠ Ø§Ù„Ù…ÙŠØ¹Ø§Ø¯ Ø§Ù„Ù…Ø­Ø¯Ø¯" },
    "Decapeptyl 0.1mg (Trigger)": { active: "Triptorelin", dose: "Ø­Ù‚Ù†ØªÙŠÙ† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ (Ù„Ù„Ø­Ù…Ø§ÙŠØ© Ù…Ù† OHSS)" }
  },
  "Down-Regulation (Antagonists/Agonists)": {
    "Cetrotide 0.25mg": { active: "Cetrorelix", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…ÙŠØ¹Ø§Ø¯" },
    "Orgalutran 0.25mg": { active: "Ganirelix", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…ÙŠØ¹Ø§Ø¯" },
    "Decapeptyl 0.1mg Daily": { active: "Triptorelin", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Decapeptyl 3.75mg Depot": { active: "Triptorelin", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© (ØªØ­Ø¶ÙŠØ±)" },
    "Zoladex 3.6mg": { active: "Goserelin", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙÙŠ Ø¬Ø¯Ø§Ø± Ø§Ù„Ø¨Ø·Ù†" },
    "Lupron Depot": { active: "Leuprolide", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©" }
  },
  "Luteal Support (Progesterone)": {
    "Cyclogest 400mg": { active: "Progesterone", dose: "Ù„Ø¨ÙˆØ³Ø© Ù…Ù‡Ø¨Ù„ÙŠØ©/Ø´Ø±Ø¬ÙŠØ© ØµØ¨Ø§Ø­Ø§Ù‹ ÙˆÙ…Ø³Ø§Ø¡Ù‹" },
    "Cyclogest 200mg": { active: "Progesterone", dose: "Ù„Ø¨ÙˆØ³Ø© Ù…Ù‡Ø¨Ù„ÙŠØ© Ù…Ø³Ø§Ø¡Ù‹" },
    "Prontogest 100mg": { active: "Progesterone", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„ Ø¹Ù…ÙŠÙ‚ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Prontogest 200mg": { active: "Progesterone", dose: "Ù„Ø¨ÙˆØ³Ø© Ù…Ù‡Ø¨Ù„ÙŠØ© Ù…Ø³Ø§Ø¡Ù‹" },
    "Duphaston 10mg": { active: "Dydrogesterone", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Utrogestan 200mg": { active: "Micronized Progesterone", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ù‡Ø¨Ù„ÙŠØ© ØµØ¨Ø§Ø­Ø§Ù‹ ÙˆÙ…Ø³Ø§Ø¡Ù‹" },
    "Crinone 8% Gel": { active: "Progesterone Gel", dose: "Ø£Ù†Ø¨ÙˆØ¨Ø© Ù…Ù‡Ø¨Ù„ÙŠØ© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ØµØ¨Ø§Ø­Ø§Ù‹" },
    "Endometrin 100mg": { active: "Progesterone", dose: "Ù‚Ø±Øµ Ù…Ù‡Ø¨Ù„ÙŠ 3 Ù…Ø±Ø§Øª ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Progynova 2mg": { active: "Estradiol Valerate", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ (Ù„Ø¯Ø¹Ù… Ø§Ù„Ø¨Ø·Ø§Ù†Ø©)" },
    "Estrimax 2mg": { active: "Estradiol", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹" }
  },
  "Vitamins & Supplements": {
    "Folic Acid 5mg": { active: "Folic Acid", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Folicap 0.5mg": { active: "Folic Acid", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Methylfolate 400mcg": { active: "Active Folic Acid", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Ferrotron": { active: "Iron + Multivitamins", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡" },
    "Haemoton": { active: "Iron + Folic", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡" },
    "Feroglobin": { active: "Iron + B12", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡" },
    "Osteocare": { active: "Calcium + Mg + Vit D", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ Ø¨Ø¹Ø¯ Ø§Ù„Ø¥ÙØ·Ø§Ø±" },
    "Calcid 500mg": { active: "Calcium Carbonate", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ Ø¨Ø¹Ø¯ Ø§Ù„Ø¥ÙØ·Ø§Ø±" },
    "Calcimate": { active: "Calcium", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Omega 3 Plus": { active: "Fish Oil", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Carnivita Forte": { active: "L-Carnitine + Zinc", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "L-Carnitine 350mg": { active: "Levocarnitine", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "DHEA 25mg": { active: "Dehydroepiandrosterone", dose: "Ù‚Ø±Øµ 3 Ù…Ø±Ø§Øª ÙŠÙˆÙ…ÙŠØ§Ù‹ (Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø®Ø²ÙˆÙ†)" },
    "Total Fertility": { active: "Multivitamin", dose: "ÙƒÙŠØ³ Ø¹Ù„Ù‰ Ù†ØµÙ ÙƒÙˆØ¨ Ù…Ø§Ø¡ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Pregnacare": { active: "Multivitamin", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" }
  },
  "Anticoagulants (Blood Thinners)": {
    "Clexane 40mg": { active: "Enoxaparin", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Clexane 20mg": { active: "Enoxaparin", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Clexane 60mg": { active: "Enoxaparin", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Enoxa 4000": { active: "Enoxaparin", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Innohep 3500": { active: "Tinzaparin", dose: "Ø­Ù‚Ù†Ø© ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Juvespr 81mg": { active: "Aspirin", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡" },
    "Aspocid 75mg": { active: "Aspirin", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡ (Ø£Ø·ÙØ§Ù„)" },
    "Ezacard 75mg": { active: "Aspirin", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡" }
  },
  "Antibiotics": {
    "Augmentin 1g": { active: "Amoxicillin/Clav", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ù„Ù…Ø¯Ø© Ø£Ø³Ø¨ÙˆØ¹" },
    "Augmentin 625mg": { active: "Amoxicillin/Clav", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©" },
    "Hibiotic 1g": { active: "Amoxicillin/Clav", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©" },
    "Vibramycin 100mg": { active: "Doxycycline", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„ (Ù„Ù„Ø²ÙˆØ¬ ÙˆØ§Ù„Ø²ÙˆØ¬Ø©)" },
    "Doxycast 100mg": { active: "Doxycycline", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©" },
    "Zithromax 500mg": { active: "Azithromycin", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 3 Ø£ÙŠØ§Ù…" },
    "Dalacin C 300mg": { active: "Clindamycin", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª" },
    "Flagyl 500mg": { active: "Metronidazole", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ù„Ù…Ø¯Ø© 7 Ø£ÙŠØ§Ù…" },
    "Amrizole 500mg": { active: "Metronidazole", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©" },
    "Diflucan 150mg": { active: "Fluconazole", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© (Ù„Ù„ÙØ·Ø±ÙŠØ§Øª)" },
    "Flucoral 150mg": { active: "Fluconazole", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© Ø£Ø³Ø¨ÙˆØ¹ÙŠØ§Ù‹" }
  },
  "Misc & Hormonal Adjuncts": {
    "Cidophage 500mg": { active: "Metformin", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„" },
    "Cidophage 850mg": { active: "Metformin", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„" },
    "Cidophage 1000mg Retard": { active: "Metformin", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ Ø¨Ø¹Ø¯ Ø§Ù„Ø¹Ø´Ø§Ø¡" },
    "Glucophage XR 1000mg": { active: "Metformin", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ Ù…Ø³Ø§Ø¡Ù‹" },
    "Dostinex 0.5mg": { active: "Cabergoline", dose: "Ù†ØµÙ Ù‚Ø±Øµ ÙƒÙ„ 3 Ø£ÙŠØ§Ù… (Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¨Ø±ÙˆÙ„Ø§ÙƒØªÙŠÙ†/OHSS)" },
    "Caberglob 0.5mg": { active: "Cabergoline", dose: "Ù†ØµÙ Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† Ø£Ø³Ø¨ÙˆØ¹ÙŠØ§Ù‹" },
    "Eltroxin 50mcg": { active: "Levothyroxine", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø±ÙŠÙ‚" },
    "Euthyrox 50mcg": { active: "Levothyroxine", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø±ÙŠÙ‚" },
    "Kapron 500mg": { active: "Tranexamic Acid", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª (Ø¹Ù†Ø¯ Ø§Ù„Ù†Ø²ÙŠÙ)" },
    "Dicynone 500mg": { active: "Etamsylate", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª" },
    "Daflon 500mg": { active: "Diosmin", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Primolut Nor 10mg": { active: "Norethisterone", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ (Ù„ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ø¯ÙˆØ±Ø©)" },
    "Steronate 5mg": { active: "Norethisterone", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹" },
    "Cyclo-Progynova": { active: "Estradiol/Norgestrel", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ (Ø§Ù„Ø£Ø¨ÙŠØ¶ Ø«Ù… Ø§Ù„Ø¨Ù†ÙŠ)" }
  },
  "Pain Killers & Spasmolytics": {
    "Panadol Extra": { active: "Paracetamol", dose: "Ù‚Ø±ØµÙŠÙ† Ø¹Ù†Ø¯ Ø§Ù„Ù„Ø²ÙˆÙ…" },
    "Cataflam 50mg": { active: "Diclofenac Potassium", dose: "Ù‚Ø±Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„ Ø¹Ù†Ø¯ Ø§Ù„Ù„Ø²ÙˆÙ…" },
    "Ketolac": { active: "Ketorolac", dose: "Ø­Ù‚Ù†Ø© Ø¹Ø¶Ù„ Ø¹Ù†Ø¯ Ø§Ù„Ù„Ø²ÙˆÙ… (Ø£Ù„Ù… Ø´Ø¯ÙŠØ¯)" },
    "Visceralgine": { active: "Tiemonium", dose: "Ù‚Ø±Øµ 3 Ù…Ø±Ø§Øª ÙŠÙˆÙ…ÙŠØ§Ù‹ (Ù„Ù„Ù…ØºØµ)" },
    "Spasmo-digestin": { active: "Digestive/Spasmolytic", dose: "Ù‚Ø±Øµ ÙˆØ³Ø· Ø§Ù„Ø£ÙƒÙ„" },
    "Buscopan": { active: "Hyoscine", dose: "Ù‚Ø±Øµ Ø¹Ù†Ø¯ Ø§Ù„Ù„Ø²ÙˆÙ… Ù„Ù„Ù…ØºØµ" }
  }
};

export const PROTOCOLS = ['Long', 'Antagonist', 'Flare-up', 'Mini-IVF'];

export const PROTOCOL_INFO = {
  'Long': {
    name: 'Long Agonist Protocol',
    arabicName: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ù†Ø§Ù‡Ø¶Ø§Øª Ø§Ù„Ø·ÙˆÙŠÙ„Ø©',
    description: 'Most commonly used protocol. Down-regulation starts in luteal phase of previous cycle.',
    arabicDescription: 'Ø§Ù„Ø£ÙƒØ«Ø± Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Ù‹. Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù‡Ø±Ù…ÙˆÙ†Ø§Øª ÙŠØ¨Ø¯Ø£ Ù…Ù† Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù„ÙˆØªÙŠØ§Ù„ÙŠØ© Ù„Ù„Ø¯ÙˆØ±Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©.',
    bestFor: ['Normal responders', 'Regular cycles', 'PCO patients'],
    arabicBestFor: ['Ø§Ù„Ù…Ø³ØªØ¬ÙŠØ¨ÙˆÙ† Ø§Ù„Ø¹Ø§Ø¯ÙŠÙˆÙ†', 'Ø§Ù„Ø¯ÙˆØ±Ø§Øª Ø§Ù„Ù…Ù†ØªØ¸Ù…Ø©', 'Ù…ØªÙ„Ø§Ø²Ù…Ø© ØªÙƒÙŠØ³ Ø§Ù„Ù…Ø¨Ø§ÙŠØ¶'],
    duration: '35-42 days total',
    stimDays: '10-12 days',
    downRegDrugs: ['Decapeptyl 0.1mg Daily', 'Zoladex 3.6mg'],
    stimDrugs: ['Gonal-F 75 IU', 'Merional 75 IU', 'Fostimon 75 IU'],
    trigger: ['Ovitrelle 250mcg', 'Choriomon 5000 IU'],
    luteal: ['Cyclogest 400mg', 'Utrogestan 200mg', 'Crinone 8% Gel']
  },
  'Antagonist': {
    name: 'Antagonist Protocol',
    arabicName: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ù…Ø¶Ø§Ø¯Ø§Øª',
    description: 'Shorter protocol. GnRH antagonists used to prevent premature LH surge. Good for poor responders.',
    arabicDescription: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø£Ù‚ØµØ±. Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¶Ø§Ø¯Ø§Øª Ù„Ù…Ù†Ø¹ Ø§Ø±ØªÙØ§Ø¹ LH Ø§Ù„Ù…Ø¨ÙƒØ±. Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ù…Ø³ØªØ¬ÙŠØ¨ÙŠÙ† Ø§Ù„Ø¶Ø¹ÙØ§Ø¡.',
    bestFor: ['Poor responders', 'Previous low response', 'PCOS with high response risk'],
    arabicBestFor: ['Ø§Ù„Ù…Ø³ØªØ¬ÙŠØ¨ÙˆÙ† Ø§Ù„Ø¶Ø¹ÙØ§Ø¡', 'Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù…Ù†Ø®ÙØ¶Ø© Ø³Ø§Ø¨Ù‚Ø©', 'ØªÙƒÙŠØ³ Ù…Ø¨Ø§ÙŠØ¶ Ù…Ø¹ Ø®Ø·Ø± Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø¹Ø§Ù„ÙŠØ©'],
    duration: '14-16 days',
    stimDays: '8-10 days',
    downRegDrugs: [],
    stimDrugs: ['Gonal-F 75-150 IU', 'Merional 75 IU', 'Menopur 75 IU'],
    antagonist: ['Cetrotide 0.25mg', 'Orgalutran 0.25mg'],
    trigger: ['Ovitrelle 250mcg', 'Decapeptyl 0.1mg (Trigger)'],
    luteal: ['Cyclogest 400mg', 'Progynova 2mg']
  },
  'Flare-up': {
    name: 'Flare-up Protocol',
    arabicName: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„ØªÙ†Ø´ÙŠØ· Ø§Ù„Ø­Ø§Ø¯',
    description: 'Short protocol. Initial FSH surge from GnRH agonist boosts recruitment. Faster but needs monitoring.',
    arabicDescription: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ù‚ØµÙŠØ±. Ø§Ø±ØªÙØ§Ø¹ FSH Ø§Ù„Ø£ÙˆÙ„ÙŠ ÙŠØ¹Ø²Ø² ØªØ¬Ù†ÙŠØ¯ Ø§Ù„Ø¨ÙˆÙŠØ¶Ø§Øª. Ø£Ø³Ø±Ø¹ Ù„ÙƒÙ† ÙŠØ­ØªØ§Ø¬ Ù…Ø±Ø§Ù‚Ø¨Ø©.',
    bestFor: ['Poor responders', 'Diminished ovarian reserve', 'Older patients'],
    arabicBestFor: ['Ø§Ù„Ù…Ø³ØªØ¬ÙŠØ¨ÙˆÙ† Ø§Ù„Ø¶Ø¹ÙØ§Ø¡', 'Ù‚ØµÙˆØ± Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¶', 'Ø§Ù„Ù…Ø±ÙŠØ¶Ø§Øª Ø§Ù„Ø£ÙƒØ¨Ø± Ø³Ù†Ø§Ù‹'],
    duration: '10-12 days',
    stimDays: '8-9 days',
    downRegDrugs: ['Decapeptyl 3.75mg Depot'],
    stimDrugs: ['Gonal-F 150-300 IU', 'Merional 150 IU'],
    trigger: ['Ovitrelle 250mcg', 'Choriomon 5000 IU'],
    luteal: ['Cyclogest 400mg', 'Duphaston 10mg']
  },
  'Mini-IVF': {
    name: 'Mini-IVF Protocol',
    arabicName: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø­Ù‚Ù† Ø§Ù„Ù…Ø¬Ù‡Ø±ÙŠ Ø§Ù„Ø®ÙÙŠÙ',
    description: 'Minimal stimulation. Lower hormone doses, suitable for poor responders and medical contraindications.',
    arabicDescription: 'ØªÙ†Ø´ÙŠØ· Ø¨Ø³ÙŠØ· Ø¬Ø¯Ø§Ù‹. Ø¬Ø±Ø¹Ø§Øª Ù‡Ø±Ù…ÙˆÙ†ÙŠØ© Ù…Ù†Ø®ÙØ¶Ø©ØŒ Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ù…Ø³ØªØ¬ÙŠØ¨ÙŠÙ† Ø§Ù„Ø¶Ø¹ÙØ§Ø¡ ÙˆØ§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø©.',
    bestFor: ['Poor responders', 'Previous OHSS', 'Medical contraindications'],
    arabicBestFor: ['Ø§Ù„Ù…Ø³ØªØ¬ÙŠØ¨ÙˆÙ† Ø§Ù„Ø¶Ø¹ÙØ§Ø¡', 'ÙØ±Ø· ØªÙ†Ø¨ÙŠÙ‡ Ø³Ø§Ø¨Ù‚', 'Ù…ÙˆØ§Ù†Ø¹ Ø·Ø¨ÙŠØ©'],
    duration: '10-14 days',
    stimDays: '7-8 days',
    downRegDrugs: [],
    stimDrugs: ['Clomid 50mg', 'Femara 2.5mg', 'Gonal-F 75 IU'],
    trigger: ['Ovitrelle 250mcg'],
    luteal: ['Cyclogest 200mg', 'Utrogestan 200mg']
  }
};

export const WHO_SPERM_PARAMS = {
  volume: 1.5,
  concentration: 15, // M/ml
  motility: 40, // %
  morphology: 4 // %
};
</file>

<file path="data/egyptian_drugs.ts">
export interface DrugEntry {
  tradeName: string;   // e.g., "Augmentin 1g"
  active: string;      // e.g., "Amoxicillin/Clavulanate"
  route: string;       // e.g., "Ø£Ù‚Ø±Ø§Øµ", "Ø­Ù‚Ù†", "Ù„Ø¨ÙˆØ³", "ÙƒØ±ÙŠÙ…"
  dose: string;        // e.g., "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„"
  category: string;    // e.g., "Antibiotics"
}

export const EGYPTIAN_MARKET_DRUGS: Record<string, DrugEntry[]> = {
  "Induction & IVF": [
    // Oral Induction
    { tradeName: "Clomid 50mg", active: "Clomiphene Citrate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 2-6 Ù„Ù„Ø¯ÙˆØ±Ø©", category: "Induction & IVF" },
    { tradeName: "Clostilbegyt 50mg", active: "Clomiphene Citrate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 2-6 Ù„Ù„Ø¯ÙˆØ±Ø©", category: "Induction & IVF" },
    { tradeName: "Technovula 50mg", active: "Clomiphene Citrate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 2-6 Ù„Ù„Ø¯ÙˆØ±Ø©", category: "Induction & IVF" },
    { tradeName: "Femara 2.5mg", active: "Letrozole", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 3-7 Ù„Ù„Ø¯ÙˆØ±Ø©", category: "Induction & IVF" },
    { tradeName: "Letrozole 2.5mg", active: "Letrozole", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 3-7 Ù„Ù„Ø¯ÙˆØ±Ø©", category: "Induction & IVF" },

    // FSH Injectables
    { tradeName: "Gonal-F 75IU Pen", active: "Follitropin Alfa", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Gonal-F 300IU Pen", active: "Follitropin Alfa", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Gonal-F 450IU Pen", active: "Follitropin Alfa", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Gonal-F 900IU Pen", active: "Follitropin Alfa", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Merional 75IU", active: "Menotrophin (FSH/LH)", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Merional 150IU", active: "Menotrophin (FSH/LH)", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Fostimon 75IU", active: "Urofollitropin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Fostimon 150IU", active: "Urofollitropin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Menogon 75IU", active: "Menotrophin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Epigonal 0.5mg", active: "Ganirelix", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 6 Ù„Ù„Ø¯ÙˆØ±Ø©", category: "Induction & IVF" },

    // LH/FSH Combinations
    { tradeName: "Pergoveris 150IU", active: "Follitropin Alfa/Lutropin Alfa", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },
    { tradeName: "Luveris 75IU", active: "Lutropin Alfa", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø·Ø¨ÙŠ", category: "Induction & IVF" },

    // GnRH Antagonists
    { tradeName: "Cetrotide 0.25mg", active: "Cetrorelix", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 6 Ù„Ù„Ø¯ÙˆØ±Ø©", category: "Induction & IVF" },
    { tradeName: "Orgalutran 0.25mg", active: "Ganirelix", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ÙŠÙˆÙ… 6 Ù„Ù„Ø¯ÙˆØ±Ø©", category: "Induction & IVF" },

    // GnRH Agonists
    { tradeName: "Decapeptyl 0.1mg Daily", active: "Triptorelin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„", category: "Induction & IVF" },
    { tradeName: "Decapeptyl 3.75mg Depot", active: "Triptorelin", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙƒÙ„ 28 ÙŠÙˆÙ… Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„", category: "Induction & IVF" },
    { tradeName: "Zoladex 3.6mg", active: "Goserelin", route: "Ø²Ø±Ø¹ ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø²Ø±Ø¹Ø© ÙƒÙ„ 28 ÙŠÙˆÙ… Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„", category: "Induction & IVF" },
    { tradeName: "Lupron Depot 3.75mg", active: "Leuprolide", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙƒÙ„ 28 ÙŠÙˆÙ… Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„", category: "Induction & IVF" },

    // Trigger Injections
    { tradeName: "Choriomon 5000IU", active: "hCG", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø¨Ø§Ø¶Ø©", category: "Induction & IVF" },
    { tradeName: "Choriomon 10000IU", active: "hCG", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø¨Ø§Ø¶Ø©", category: "Induction & IVF" },
    { tradeName: "Epifasi 5000IU", active: "hCG", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø¨Ø§Ø¶Ø©", category: "Induction & IVF" },
    { tradeName: "Pregnyl 5000IU", active: "hCG", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø¨Ø§Ø¶Ø©", category: "Induction & IVF" },
    { tradeName: "Ovitrelle 250mcg", active: "Choriogonadotropin Alfa", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø¨Ø§Ø¶Ø©", category: "Induction & IVF" },
  ],

  "Luteal Support": [
    { tradeName: "Cyclogest 200mg", active: "Progesterone", route: "Ù„Ø¨ÙˆØ³ Ù…Ù‡Ø¨Ù„ÙŠ", dose: "Ù„Ø¨ÙˆØ³Ø© Ù…Ø³Ø§Ø¡Ù‹ ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Cyclogest 400mg", active: "Progesterone", route: "Ù„Ø¨ÙˆØ³ Ù…Ù‡Ø¨Ù„ÙŠ", dose: "Ù„Ø¨ÙˆØ³Ø© Ù…Ø³Ø§Ø¡Ù‹ ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Prontogest 100mg", active: "Progesterone", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Prontogest 200mg", active: "Progesterone", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Prontogest 400mg", active: "Progesterone", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Utrogestan 100mg", active: "Progesterone", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª Ù…Ù‡Ø¨Ù„ÙŠØ©", dose: "ÙƒØ¨Ø³ÙˆÙ„ØªØ§Ù† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Utrogestan 200mg", active: "Progesterone", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª Ù…Ù‡Ø¨Ù„ÙŠØ©", dose: "ÙƒØ¨Ø³ÙˆÙ„ØªØ§Ù† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Duphaston 10mg", active: "Dydrogesterone", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Endometrin 100mg", active: "Progesterone", route: "Ù„Ø¨ÙˆØ³ Ù…Ù‡Ø¨Ù„ÙŠ", dose: "Ù„Ø¨ÙˆØ³Ø© Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Crinone 8% Gel", active: "Progesterone", route: "Ø¬ÙŠÙ„ Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
    { tradeName: "Lubgest 200mg", active: "Progesterone", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª Ù…Ù‡Ø¨Ù„ÙŠØ©", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Luteal Support" },
  ],

  "Pregnancy Supplements": [
    // Folic Acid
    { tradeName: "Folic Acid 5mg (Nile)", active: "Folic Acid", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
    { tradeName: "Folic Acid 5mg (Mepaco)", active: "Folic Acid", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
    { tradeName: "Methylfolate 400mcg", active: "L-Methylfolate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },

    // Iron Supplements
    { tradeName: "Ferrotron", active: "Iron/Folic Acid", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡", category: "Pregnancy Supplements" },
    { tradeName: "Haemoton", active: "Iron/Folic Acid", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡", category: "Pregnancy Supplements" },
    { tradeName: "Feroglobin", active: "Iron/Vitamins", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡", category: "Pregnancy Supplements" },
    { tradeName: "Pravotin", active: "Iron/Folic Acid", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡", category: "Pregnancy Supplements" },

    // Calcium & Vitamin D
    { tradeName: "Osteocare", active: "Calcium/Vitamin D3", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
    { tradeName: "Calcid", active: "Calcium Carbonate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡", category: "Pregnancy Supplements" },
    { tradeName: "Calcimate", active: "Calcium/Vitamin D3", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
    { tradeName: "Cal-Mag", active: "Calcium/Magnesium", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },

    // Prenatal Vitamins
    { tradeName: "Pregnacare Original", active: "Multivitamins", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
    { tradeName: "Pregnacare Plus", active: "Multivitamins/Iron", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
    { tradeName: "Elevit", active: "Multivitamins", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙˆØ§Ø­Ø¯ ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
    { tradeName: "Limitless Woman", active: "Multivitamins", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },

    // Omega 3
    { tradeName: "Omega 3 Plus", active: "Fish Oil/DHA", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
    { tradeName: "Maxepa", active: "Omega 3", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Pregnancy Supplements" },
  ],

  "Anticoagulants": [
    { tradeName: "Clexane 20mg", active: "Enoxaparin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Anticoagulants" },
    { tradeName: "Clexane 40mg", active: "Enoxaparin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Anticoagulants" },
    { tradeName: "Clexane 60mg", active: "Enoxaparin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Anticoagulants" },
    { tradeName: "Clexane 80mg", active: "Enoxaparin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Anticoagulants" },
    { tradeName: "Enoxa 40mg", active: "Enoxaparin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Anticoagulants" },
    { tradeName: "Innohep 4500IU", active: "Tinzaparin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Anticoagulants" },
    { tradeName: "Clexane T 4000IU", active: "Enoxaparin", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Anticoagulants" },
    { tradeName: "Juvespr 20mg", active: "Rivaroxaban", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Anticoagulants" },
    { tradeName: "Aspocid 75mg", active: "Aspirin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡", category: "Anticoagulants" },
    { tradeName: "Ezacard 75mg", active: "Aspirin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ø¨Ø¹Ø¯ Ø§Ù„ØºØ¯Ø§Ø¡", category: "Anticoagulants" },
  ],

  "Antibiotics": [
    // Penicillins
    { tradeName: "Augmentin 375mg", active: "Amoxicillin/Clavulanate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antibiotics" },
    { tradeName: "Augmentin 625mg", active: "Amoxicillin/Clavulanate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antibiotics" },
    { tradeName: "Augmentin 1g", active: "Amoxicillin/Clavulanate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antibiotics" },
    { tradeName: "Hibiotic 375mg", active: "Amoxicillin/Clavulanate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antibiotics" },
    { tradeName: "Megamox 375mg", active: "Amoxicillin/Clavulanate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antibiotics" },
    { tradeName: "Curam 625mg", active: "Amoxicillin/Clavulanate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antibiotics" },

    // Cephalosporins
    { tradeName: "Zinnat 250mg", active: "Cefuroxime", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©", category: "Antibiotics" },
    { tradeName: "Zinnat 500mg", active: "Cefuroxime", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©", category: "Antibiotics" },
    { tradeName: "Cefotax 1g", active: "Cefotaxime", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„/ÙˆØ±ÙŠØ¯ÙŠ", dose: "Ø­Ù‚Ù†Ø© ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©", category: "Antibiotics" },
    { tradeName: "Cefzone 1g", active: "Ceftriaxone", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„/ÙˆØ±ÙŠØ¯ÙŠ", dose: "Ø­Ù‚Ù†Ø© ÙƒÙ„ 24 Ø³Ø§Ø¹Ø©", category: "Antibiotics" },
    { tradeName: "Rocephin 1g", active: "Ceftriaxone", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„/ÙˆØ±ÙŠØ¯ÙŠ", dose: "Ø­Ù‚Ù†Ø© ÙƒÙ„ 24 Ø³Ø§Ø¹Ø©", category: "Antibiotics" },
    { tradeName: "Duricef 500mg", active: "Cefadroxil", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©", category: "Antibiotics" },

    // Macrolides
    { tradeName: "Zithromax 500mg", active: "Azithromycin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 3 Ø£ÙŠØ§Ù…", category: "Antibiotics" },
    { tradeName: "Zisrocin 500mg", active: "Azithromycin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 3 Ø£ÙŠØ§Ù…", category: "Antibiotics" },

    // Tetracyclines
    { tradeName: "Vibramycin 100mg", active: "Doxycycline", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antibiotics" },
    { tradeName: "Doxycast 100mg", active: "Doxycycline", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antibiotics" },

    // Lincosamides
    { tradeName: "Dalacin C 300mg", active: "Clindamycin", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Antibiotics" },

    // Nitroimidazoles
    { tradeName: "Flagyl 500mg", active: "Metronidazole", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ù„Ù…Ø¯Ø© Ø£Ø³Ø¨ÙˆØ¹", category: "Antibiotics" },
    { tradeName: "Amrizole 500mg", active: "Metronidazole", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ù„Ù…Ø¯Ø© Ø£Ø³Ø¨ÙˆØ¹", category: "Antibiotics" },

    // Antifungals
    { tradeName: "Diflucan 150mg", active: "Fluconazole", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©", category: "Antibiotics" },

    // UTI Specific
    { tradeName: "Uvamin Retard 400mg", active: "Fosfomycin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©", category: "Antibiotics" },
    { tradeName: "Macropur 3g", active: "Nitrofurantoin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Antibiotics" },
    { tradeName: "Monuril 3g", active: "Fosfomycin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©", category: "Antibiotics" },
  ],

  "Vaginal Preparations": [
    // Antifungal
    { tradeName: "Gyno-Daktarin 400mg", active: "Miconazole", route: "ÙƒØ±ÙŠÙ… Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø³Ø§Ø¡Ù‹", category: "Vaginal Preparations" },
    { tradeName: "Monicure 400mg", active: "Miconazole", route: "ÙƒØ±ÙŠÙ… Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø³Ø§Ø¡Ù‹", category: "Vaginal Preparations" },
    { tradeName: "Gyno-Zalain 300mg", active: "Sertaconazole", route: "ÙƒØ±ÙŠÙ… Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø³Ø§Ø¡Ù‹", category: "Vaginal Preparations" },
    { tradeName: "Candistan 100mg", active: "Clotrimazole", route: "ÙƒØ±ÙŠÙ… Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 3 Ø£ÙŠØ§Ù…", category: "Vaginal Preparations" },
    { tradeName: "Gyno-Trosyd 100mg", active: "Tioconazole", route: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ù‡Ø¨Ù„ÙŠØ©", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø³Ø§Ø¡Ù‹", category: "Vaginal Preparations" },

    // Antibacterial
    { tradeName: "Amrizole N", active: "Metronidazole", route: "ÙƒØ±ÙŠÙ… Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 5 Ø£ÙŠØ§Ù…", category: "Vaginal Preparations" },
    { tradeName: "Betadine", active: "Povidone Iodine", route: "ÙƒØ±ÙŠÙ… Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Vaginal Preparations" },
    { tradeName: "Albothyl", active: "Polymyxin/Neomycin", route: "ÙƒØ±ÙŠÙ… Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Vaginal Preparations" },
    { tradeName: "PolgyneX", active: "Polymyxin/Neomycin", route: "ÙƒØ±ÙŠÙ… Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Vaginal Preparations" },

    // Cleansers
    { tradeName: "Vagyl", active: "Lactic Acid", route: "ØºØ³ÙˆÙ„ Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØºØ³Ù„ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Vaginal Preparations" },
    { tradeName: "Tantum Rosa", active: "Benzydamine", route: "ØºØ³ÙˆÙ„ Ù…Ù‡Ø¨Ù„ÙŠ", dose: "ØºØ³Ù„ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Vaginal Preparations" },
  ],

  "Antihypertensives": [
    { tradeName: "Aldomet 250mg", active: "Methyldopa", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Antihypertensives" },
    { tradeName: "Aldomet 500mg", active: "Methyldopa", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Antihypertensives" },
    { tradeName: "Adalat LA 30mg", active: "Nifedipine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Antihypertensives" },
    { tradeName: "Adalat LA 60mg", active: "Nifedipine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Antihypertensives" },
    { tradeName: "Epilat 30mg", active: "Nifedipine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Antihypertensives" },
    { tradeName: "Dopegyt 250mg", active: "Methyldopa", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Antihypertensives" },
  ],

  "Antidiabetics": [
    // Metformin
    { tradeName: "Cidophage 500mg", active: "Metformin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antidiabetics" },
    { tradeName: "Cidophage 850mg", active: "Metformin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antidiabetics" },
    { tradeName: "Cidophage 1000mg", active: "Metformin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 12 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£ÙƒÙ„", category: "Antidiabetics" },
    { tradeName: "Glucophage XR 500mg", active: "Metformin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Antidiabetics" },
    { tradeName: "Glucophage XR 1000mg", active: "Metformin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Antidiabetics" },

    // Sulfonylureas
    { tradeName: "Amaryl 2mg", active: "Glimepiride", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„Ø¥ÙØ·Ø§Ø±", category: "Antidiabetics" },
    { tradeName: "Amaryl 4mg", active: "Glimepiride", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„Ø¥ÙØ·Ø§Ø±", category: "Antidiabetics" },

    // Insulin
    { tradeName: "Mixtard 30/70", active: "Insulin Human", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© Ù‚Ø¨Ù„ Ø§Ù„ÙˆØ¬Ø¨Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø©", category: "Antidiabetics" },
    { tradeName: "Lantus 100IU/ml", active: "Insulin Glargine", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Antidiabetics" },
    { tradeName: "Apidra 100IU/ml", active: "Insulin Glulisine", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© Ù‚Ø¨Ù„ Ø§Ù„ÙˆØ¬Ø¨Ø§Øª", category: "Antidiabetics" },
    { tradeName: "Actrapid 100IU/ml", active: "Insulin Human", route: "Ø­Ù‚Ù† ØªØ­Øª Ø§Ù„Ø¬Ù„Ø¯", dose: "Ø­Ù‚Ù†Ø© Ù‚Ø¨Ù„ Ø§Ù„ÙˆØ¬Ø¨Ø§Øª", category: "Antidiabetics" },
  ],

  "Analgesics": [
    // NSAIDs
    { tradeName: "Brufen 400mg", active: "Ibuprofen", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©", category: "Analgesics" },
    { tradeName: "Brufen 600mg", active: "Ibuprofen", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©", category: "Analgesics" },
    { tradeName: "Ponstan 500mg", active: "Mefenamic Acid", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Analgesics" },
    { tradeName: "Ponstan Forte 500mg", active: "Mefenamic Acid", route: "ÙƒØ¨Ø³ÙˆÙ„Ø§Øª", dose: "ÙƒØ¨Ø³ÙˆÙ„Ø© ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Analgesics" },
    { tradeName: "Cataflam 50mg", active: "Diclofenac", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 12 Ø³Ø§Ø¹Ø©", category: "Analgesics" },
    { tradeName: "Voltaren 75mg", active: "Diclofenac", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Analgesics" },
    { tradeName: "Ketolac 10mg", active: "Ketorolac", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª Ù„Ù…Ø¯Ø© 5 Ø£ÙŠØ§Ù…", category: "Analgesics" },

    // Paracetamol
    { tradeName: "Panadol 500mg", active: "Paracetamol", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©", category: "Analgesics" },
    { tradeName: "Panadol Extra 500mg", active: "Paracetamol/Caffeine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©", category: "Analgesics" },
    { tradeName: "Panadol Joint 665mg", active: "Paracetamol", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Analgesics" },
    { tradeName: "Abimol 500mg", active: "Paracetamol", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©", category: "Analgesics" },
    { tradeName: "Pyral 500mg", active: "Paracetamol", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©", category: "Analgesics" },

    // Antispasmodics
    { tradeName: "Buscopan 10mg", active: "Hyoscine Butylbromide", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Analgesics" },
    { tradeName: "Visceralgine 10mg", active: "Hyoscine Butylbromide", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Analgesics" },
    { tradeName: "Spasmo-digestin", active: "Hyoscine/Phenylpropanolamine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Analgesics" },
    { tradeName: "Spasmofree", active: "Hyoscine/Phenylpropanolamine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Analgesics" },
    { tradeName: "Spasmo-Amrase", active: "Hyoscine/Phenylpropanolamine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Analgesics" },
  ],

  "Contraceptives": [
    // Combined Oral Contraceptives
    { tradeName: "Yasmin", active: "Ethinylestradiol/Drospirenone", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 21 ÙŠÙˆÙ…Ø§Ù‹", category: "Contraceptives" },
    { tradeName: "Yaz", active: "Ethinylestradiol/Drospirenone", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 24 ÙŠÙˆÙ…Ø§Ù‹", category: "Contraceptives" },
    { tradeName: "Gynera", active: "Ethinylestradiol/Gestodene", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 21 ÙŠÙˆÙ…Ø§Ù‹", category: "Contraceptives" },
    { tradeName: "Marvelon", active: "Ethinylestradiol/Desogestrel", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 21 ÙŠÙˆÙ…Ø§Ù‹", category: "Contraceptives" },
    { tradeName: "Cilest", active: "Ethinylestradiol/Norgestimate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 21 ÙŠÙˆÙ…Ø§Ù‹", category: "Contraceptives" },
    { tradeName: "Microlut", active: "Levonorgestrel", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø¨Ø¯ÙˆÙ† ÙØªØ±Ø© Ø±Ø§Ø­Ø©", category: "Contraceptives" },
    { tradeName: "Diane 35", active: "Ethinylestradiol/Cyproterone", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙŠÙˆÙ…ÙŠØ§Ù‹ Ù„Ù…Ø¯Ø© 21 ÙŠÙˆÙ…Ø§Ù‹", category: "Contraceptives" },

    // Injectable Contraceptives
    { tradeName: "Depo-Provera 150mg", active: "Medroxyprogesterone", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙƒÙ„ 3 Ø£Ø´Ù‡Ø±", category: "Contraceptives" },
    { tradeName: "Mesigyna 150mg", active: "Medroxyprogesterone", route: "Ø­Ù‚Ù† Ø¹Ø¶Ù„", dose: "Ø­Ù‚Ù†Ø© ÙƒÙ„ 3 Ø£Ø´Ù‡Ø±", category: "Contraceptives" },

    // Emergency Contraception
    { tradeName: "Contraceplan II", active: "Levonorgestrel", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† Ù…Ø¹Ø§Ù‹ Ø®Ù„Ø§Ù„ 72 Ø³Ø§Ø¹Ø©", category: "Contraceptives" },
  ],

  "Anti-Emetics": [
    { tradeName: "Navidoxine", active: "Doxylamine/Pyridoxine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù‚Ø¨Ù„ Ø§Ù„Ù†ÙˆÙ…", category: "Anti-Emetics" },
    { tradeName: "Cortiplex B6", active: "Dexamethasone/Pyridoxine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù‚Ø¨Ù„ Ø§Ù„Ù†ÙˆÙ…", category: "Anti-Emetics" },
    { tradeName: "Zofran 8mg", active: "Ondansetron", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù‚Ø¨Ù„ Ø§Ù„Ø£ÙƒÙ„", category: "Anti-Emetics" },
    { tradeName: "Zofran 4mg", active: "Ondansetron", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù‚Ø¨Ù„ Ø§Ù„Ø£ÙƒÙ„", category: "Anti-Emetics" },
    { tradeName: "Danset 10mg", active: "Domperidone", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù‚Ø¨Ù„ Ø§Ù„Ø£ÙƒÙ„", category: "Anti-Emetics" },
    { tradeName: "Motinorm 10mg", active: "Domperidone", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù‚Ø¨Ù„ Ø§Ù„Ø£ÙƒÙ„", category: "Anti-Emetics" },
    { tradeName: "Primperan 10mg", active: "Metoclopramide", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù‚Ø¨Ù„ Ø§Ù„Ø£ÙƒÙ„", category: "Anti-Emetics" },
    { tradeName: "Maxolon 10mg", active: "Metoclopramide", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù‚Ø¨Ù„ Ø§Ù„Ø£ÙƒÙ„", category: "Anti-Emetics" },
  ],

  "Hemostatics": [
    { tradeName: "Kapron 500mg", active: "Tranexamic Acid", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Hemostatics" },
    { tradeName: "Cyklokapron 500mg", active: "Tranexamic Acid", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Hemostatics" },
    { tradeName: "Haemostop 500mg", active: "Tranexamic Acid", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Hemostatics" },
    { tradeName: "Dicynone 250mg", active: "Ethamsylate", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Hemostatics" },
    { tradeName: "Methergine 0.2mg", active: "Methylergometrine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ÙƒÙ„ 8 Ø³Ø§Ø¹Ø§Øª", category: "Hemostatics" },
  ],

  "Thyroid & Hormonal": [
    // Thyroid
    { tradeName: "Eltroxin 50mcg", active: "Levothyroxine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù†ØµÙ Ù‚Ø±Øµ ØµØ¨Ø§Ø­Ø§Ù‹", category: "Thyroid & Hormonal" },
    { tradeName: "Eltroxin 100mcg", active: "Levothyroxine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ØµØ¨Ø§Ø­Ø§Ù‹", category: "Thyroid & Hormonal" },
    { tradeName: "Euthyrox 50mcg", active: "Levothyroxine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù†ØµÙ Ù‚Ø±Øµ ØµØ¨Ø§Ø­Ø§Ù‹", category: "Thyroid & Hormonal" },
    { tradeName: "Euthyrox 100mcg", active: "Levothyroxine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ ØµØ¨Ø§Ø­Ø§Ù‹", category: "Thyroid & Hormonal" },
    { tradeName: "Thyronorm 25mcg", active: "Levothyroxine", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ø±Ø¨Ø¹ Ù‚Ø±Øµ ØµØ¨Ø§Ø­Ø§Ù‹", category: "Thyroid & Hormonal" },

    // Dopamine Agonists
    { tradeName: "Dostinex 0.5mg", active: "Cabergoline", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù†ØµÙ Ù‚Ø±Øµ ÙƒÙ„ 3 Ø£ÙŠØ§Ù…", category: "Thyroid & Hormonal" },

    // Progestins
    { tradeName: "Primolut N 5mg", active: "Norethisterone", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Thyroid & Hormonal" },
    { tradeName: "Provera 10mg", active: "Medroxyprogesterone", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Thyroid & Hormonal" },

    // Venotonics
    { tradeName: "Daflon 500mg", active: "Diosmin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±ØµÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Thyroid & Hormonal" },
    { tradeName: "Reparil 20mg", active: "Aescin", route: "Ø£Ù‚Ø±Ø§Øµ", dose: "Ù‚Ø±Øµ Ù…Ø±ØªÙŠÙ† ÙŠÙˆÙ…ÙŠØ§Ù‹", category: "Thyroid & Hormonal" },
  ]
};

// Helper function to get all drugs as a flat array
export const getAllDrugs = (): DrugEntry[] => {
  return Object.values(EGYPTIAN_MARKET_DRUGS).flat();
};

// Helper function to get drugs by category
export const getDrugsByCategory = (category: string): DrugEntry[] => {
  return EGYPTIAN_MARKET_DRUGS[category] || [];
};

// Helper function to search drugs by name
export const searchDrugs = (query: string): DrugEntry[] => {
  const allDrugs = getAllDrugs();
  const lowerQuery = query.toLowerCase();
  return allDrugs.filter(drug =>
    drug.tradeName.toLowerCase().includes(lowerQuery) ||
    drug.active.toLowerCase().includes(lowerQuery)
  );
};
</file>

<file path="electron/main.js">
const { app, BrowserWindow, ipcMain } = require('electron');
const path = require('path');

// Ù…Ù†Ø¹ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ù† Ø§Ù„ØªÙˆÙ‚Ù Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù†ÙˆØ§ÙØ° (ÙÙŠ Ù…Ø§Ùƒ)
let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1280,
    height: 800,
    minWidth: 1024,
    minHeight: 768,
    title: "Nile IVF Center EMR",
    webPreferences: {
      nodeIntegration: false, // Ù„Ù„Ø£Ù…Ø§Ù†
      contextIsolation: true, // Ù„Ù„Ø£Ù…Ø§Ù†
      preload: path.join(__dirname, 'preload.js')
    },
    // Ø¥Ø®ÙØ§Ø¡ Ø´Ø±ÙŠØ· Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø¹Ù„ÙˆÙŠ Ù„Ù…Ø¸Ù‡Ø± Ø£ÙƒØ«Ø± Ø§Ø­ØªØ±Ø§ÙÙŠØ©
    autoHideMenuBar: true 
  });

  // ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ·ÙˆÙŠØ±ØŒ Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³ÙŠØ±ÙØ± Ø§Ù„Ù…Ø­Ù„ÙŠ
  // ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ù†ØªØ§Ø¬ (Ø¨Ø¹Ø¯ Ø§Ù„ØªØ³Ø·ÙŠØ¨)ØŒ Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù index.html
  const isDev = !app.isPackaged;
  
  if (isDev) {
    mainWindow.loadURL('http://localhost:5173');
    // ÙØªØ­ Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·ÙˆØ± Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ Ø§Ù„ØªØµØ­ÙŠØ­
    // mainWindow.webContents.openDevTools();
  } else {
    mainWindow.loadFile(path.join(__dirname, '../dist/index.html'));
  }
}

app.whenReady().then(() => {
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Ù‡Ù†Ø§ Ø³Ù†Ø¶ÙŠÙ Ù„Ø§Ø­Ù‚Ø§Ù‹ (IPC Handlers) Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ø·Ø¨Ø§Ø¹Ø©
// Ù…Ø«Ø§Ù„:
// ipcMain.handle('save-patient', async (event, data) => { ... })
</file>

<file path="electron/preload.js">
const { contextBridge, ipcRenderer } = require('electron');

// Ù†Ø­Ù† Ù†ÙƒØ´Ù ÙÙ‚Ø· ÙˆØ¸Ø§Ø¦Ù Ù…Ø­Ø¯Ø¯Ø© Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù†Ø¸Ø§Ù…
contextBridge.exposeInMainWorld('electronAPI', {
  // Ù…Ø«Ø§Ù„ Ù„ÙˆØ¸Ø§Ø¦Ù Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©
  print: () => ipcRenderer.send('print-document'),
  saveToDb: (data) => ipcRenderer.invoke('db-save', data),
  getFromDb: (query) => ipcRenderer.invoke('db-get', query)
});
</file>

<file path="IVF_CYCLES_SETUP.sql">
-- ============================================================================
-- IVF CYCLES MODULE SETUP - Supabase SQL
-- ============================================================================
-- This script creates tables for IVF cycle management with assessment,
-- lab data, transfer, and outcome tracking.
-- ============================================================================

-- 1. CREATE IVF_CYCLES TABLE
CREATE TABLE IF NOT EXISTS ivf_cycles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  doctor_id UUID NOT NULL REFERENCES doctors(id) ON DELETE CASCADE,
  protocol TEXT NOT NULL CHECK (protocol IN ('Long', 'Antagonist', 'Flare-up', 'Mini-IVF')),
  status TEXT NOT NULL DEFAULT 'Active' CHECK (status IN ('Active', 'Completed', 'Cancelled')),
  start_date DATE NOT NULL,
  assessment_data JSONB DEFAULT NULL,
  lab_data JSONB DEFAULT NULL,
  transfer_data JSONB DEFAULT NULL,
  outcome_data JSONB DEFAULT NULL,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 2. CREATE STIMULATION_LOGS TABLE
CREATE TABLE IF NOT EXISTS stimulation_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cycle_id UUID NOT NULL REFERENCES ivf_cycles(id) ON DELETE CASCADE,
  cycle_day INTEGER NOT NULL,
  date DATE NOT NULL,
  fsh TEXT DEFAULT '',
  hmg TEXT DEFAULT '',
  e2 TEXT DEFAULT '',
  lh TEXT DEFAULT '',
  rt_follicles TEXT DEFAULT '',
  lt_follicles TEXT DEFAULT '',
  endometrium_thickness TEXT DEFAULT '',
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 3. CREATE INDEXES FOR PERFORMANCE
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_patient_id ON ivf_cycles(patient_id);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_doctor_id ON ivf_cycles(doctor_id);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_status ON ivf_cycles(status);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_start_date ON ivf_cycles(start_date DESC);
CREATE INDEX IF NOT EXISTS idx_stimulation_logs_cycle_id ON stimulation_logs(cycle_id);
CREATE INDEX IF NOT EXISTS idx_stimulation_logs_date ON stimulation_logs(date);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_assessment_data ON ivf_cycles USING GIN (assessment_data);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_lab_data ON ivf_cycles USING GIN (lab_data);

-- 4. ENABLE RLS
ALTER TABLE ivf_cycles ENABLE ROW LEVEL SECURITY;
ALTER TABLE stimulation_logs ENABLE ROW LEVEL SECURITY;

-- 5. DROP EXISTING POLICIES
DROP POLICY IF EXISTS "Doctors can read their IVF cycles" ON ivf_cycles;
DROP POLICY IF EXISTS "Doctors can insert IVF cycles" ON ivf_cycles;
DROP POLICY IF EXISTS "Doctors can update IVF cycles" ON ivf_cycles;
DROP POLICY IF EXISTS "Doctors can read stimulation logs" ON stimulation_logs;
DROP POLICY IF EXISTS "Doctors can insert stimulation logs" ON stimulation_logs;
DROP POLICY IF EXISTS "Doctors can update stimulation logs" ON stimulation_logs;

-- 6. RLS POLICIES FOR IVF_CYCLES
CREATE POLICY "Doctors can read their IVF cycles" ON ivf_cycles
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

CREATE POLICY "Doctors can insert IVF cycles" ON ivf_cycles
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

CREATE POLICY "Doctors can update IVF cycles" ON ivf_cycles
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

-- 7. RLS POLICIES FOR STIMULATION_LOGS
CREATE POLICY "Doctors can read stimulation logs" ON stimulation_logs
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND cycle_id IN (
      SELECT id FROM ivf_cycles
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

CREATE POLICY "Doctors can insert stimulation logs" ON stimulation_logs
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND cycle_id IN (
      SELECT id FROM ivf_cycles
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

CREATE POLICY "Doctors can update stimulation logs" ON stimulation_logs
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND cycle_id IN (
      SELECT id FROM ivf_cycles
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND cycle_id IN (
      SELECT id FROM ivf_cycles
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

-- 8. ADD TABLE COMMENTS
COMMENT ON TABLE ivf_cycles IS 'Stores IVF cycle information including protocol, status, and JSONB data for assessments, lab results, transfer, and outcomes';
COMMENT ON COLUMN ivf_cycles.assessment_data IS 'JSONB object containing couple profile, male/female factor, and tubal-uterine assessments';
COMMENT ON COLUMN ivf_cycles.lab_data IS 'JSONB object containing OPU data, embryo counts, and grading';
COMMENT ON COLUMN ivf_cycles.transfer_data IS 'JSONB object containing transfer details and luteal support options';
COMMENT ON COLUMN ivf_cycles.outcome_data IS 'JSONB object containing beta-HCG and clinical pregnancy outcomes';
</file>

<file path="IVF_MIGRATION_GUIDE.md">
# IVF Cycle Management Database Migration Guide

## Issue Resolution: "Failed to save assessment"

The "Failed to save assessment" error was occurring because the `ivf_cycles` table was missing the required JSONB columns (`assessment_data`, `lab_data`, `transfer_data`, `outcome_data`) in your Supabase database.

## Solution

A new SQL migration file has been created: `IVF_CYCLES_SETUP.sql`

This file creates:
1. **ivf_cycles** table with all required columns
2. **stimulation_logs** table for daily cycle tracking
3. Proper indexes for performance
4. Row-Level Security (RLS) policies for data access control

## How to Apply the Migration

### Step 1: Open Supabase SQL Editor
1. Go to [Supabase Dashboard](https://app.supabase.com)
2. Select your project
3. Navigate to **SQL Editor** in the left sidebar
4. Click **New Query**

### Step 2: Copy and Execute SQL
1. Open `IVF_CYCLES_SETUP.sql` from your project root
2. Copy the entire SQL content
3. Paste it into the Supabase SQL Editor
4. Click **Run** (or press Ctrl+Enter)

### Step 3: Verify Success
After running the migration, you should see:
- âœ… No error messages in the SQL editor
- âœ… Query succeeded notification

Verify the tables were created:
```sql
-- Check ivf_cycles table
SELECT * FROM ivf_cycles LIMIT 1;

-- Check stimulation_logs table
SELECT * FROM stimulation_logs LIMIT 1;
```

## What Changed in the Code

### New Database Schema
```
ivf_cycles (Main IVF Cycle Record)
â”œâ”€â”€ id (UUID, primary key)
â”œâ”€â”€ patient_id (UUID, foreign key)
â”œâ”€â”€ doctor_id (UUID, foreign key)
â”œâ”€â”€ protocol (TEXT: 'Long', 'Antagonist', 'Flare-up', 'Mini-IVF')
â”œâ”€â”€ status (TEXT: 'Active', 'Completed', 'Cancelled')
â”œâ”€â”€ start_date (DATE)
â”œâ”€â”€ assessment_data (JSONB) â† Now saves couple profile, male/female factor assessments
â”œâ”€â”€ lab_data (JSONB) â† Saves OPU and embryology data
â”œâ”€â”€ transfer_data (JSONB) â† Saves transfer details and luteal support
â”œâ”€â”€ outcome_data (JSONB) â† Saves beta-HCG and pregnancy outcomes
â””â”€â”€ timestamps (created_at, updated_at)

stimulation_logs (Daily Stimulation Records)
â”œâ”€â”€ id (UUID, primary key)
â”œâ”€â”€ cycle_id (UUID, foreign key to ivf_cycles)
â”œâ”€â”€ cycle_day (INTEGER)
â”œâ”€â”€ date (DATE)
â”œâ”€â”€ fsh, hmg, e2, lh (TEXT fields for hormone values)
â”œâ”€â”€ rt_follicles, lt_follicles (TEXT for follicle counts)
â”œâ”€â”€ endometrium_thickness (TEXT)
â””â”€â”€ timestamps (created_at, updated_at)
```

### Enhanced Error Handling
The following functions now provide detailed error messages:
- `updateCycleAssessment()` - Saves assessment data
- `updateCycleLabData()` - Saves lab data
- `updateCycleTransfer()` - Saves transfer data
- `updateCycleOutcome()` - Saves outcome data

**Before:**
```
toast.error('Failed to save assessment');
```

**After:**
```
toast.error('Failed to save assessment: [Detailed error message]');
console.error('Save assessment error:', error);
```

## Row-Level Security (RLS)

The migration includes RLS policies that ensure:
- Doctors can only access their own patient's cycles
- Each doctor is isolated from other doctors' data
- Automatic filtering based on authenticated user ID

## Troubleshooting

### If you still see "Failed to save assessment":

1. **Check browser console (F12)** for detailed error messages
2. **Verify RLS policies** are enabled:
   ```sql
   SELECT * FROM pg_policies 
   WHERE tablename IN ('ivf_cycles', 'stimulation_logs');
   ```

3. **Check doctor_id mapping** - ensure your doctor record exists:
   ```sql
   SELECT id, user_id FROM doctors WHERE user_id = 'YOUR_USER_ID';
   ```

4. **Verify table structure**:
   ```sql
   SELECT column_name, data_type FROM information_schema.columns 
   WHERE table_name = 'ivf_cycles';
   ```

## Database Relationships

```
auth.users (Supabase Auth)
    â†“
doctors (has doctor_id, user_id)
    â†“
patients (has doctor_id)
    â†“
ivf_cycles (has patient_id, doctor_id)
    â†“
stimulation_logs (has cycle_id)
```

## Next Steps

1. Run the migration using the steps above
2. Refresh your browser
3. Create a new IVF cycle - the "Save Assessment" button should now work
4. Check browser console (F12) for confirmation of successful saves

## Support

If you encounter any issues:
1. Check the browser console for detailed error messages
2. Run verification queries provided in Step 3
3. Ensure you're logged in with a valid doctor account
4. Verify the Supabase connection in `services/supabaseClient.ts`
</file>

<file path="metadata.json">
{
  "name": "Copy of Nile IVF & OB/GYN Center",
  "description": "A comprehensive, production-ready EMR system for IVF Clinics featuring patient management, clinical stations, and advanced IVF cycle tracking with stimulation logs. Designed with a Medical SaaS aesthetic and RTL support.",
  "requestFramePermissions": []
}
</file>

<file path="OBSTETRICS_IMPLEMENTATION.md">
# ğŸ¤° Smart Obstetrics Module - Implementation Guide

## Overview
A comprehensive **Antenatal Care (ANC) Dashboard** for the React/Supabase app with state-of-the-art pregnancy management features.

---

## âœ… What Was Built

### **1. Database Schema (Supabase)**
Three main tables created:

#### `pregnancies`
- `id` (UUID) - Primary key
- `patient_id` (UUID) - Link to patients table
- `lmp_date` - Last Menstrual Period
- `edd_date` - Estimated Delivery Date (calculated)
- `edd_by_scan` - EDD confirmed by ultrasound
- `ga_at_booking` - Gestational age at first booking
- `risk_level` - 'low', 'moderate', 'high'
- `risk_factors` - JSONB array of risk factors
- `aspirin_prescribed` - Boolean for pre-eclampsia prevention
- `thromboprophylaxis_needed` - Boolean for VTE prevention

#### `antenatal_visits`
- `id` (UUID)
- `pregnancy_id` (UUID) - Links to pregnancies
- `visit_date` - Date of visit
- `gestational_age_weeks`, `gestational_age_days` - Auto-calculated
- `systolic_bp`, `diastolic_bp` - Blood pressure
- `weight_kg` - Maternal weight
- `urine_albuminuria`, `urine_glycosuria` - Urine findings
- `fetal_heart_sound` - Boolean
- `fundal_height_cm` - Height of uterine fundus
- `edema` - Boolean
- `notes` - Clinical notes

#### `biometry_scans`
- `id` (UUID)
- `pregnancy_id` (UUID)
- `scan_date`
- `bpd_mm`, `hc_mm`, `ac_mm`, `fl_mm` - Biometric measurements
- `efw_grams` - Estimated Fetal Weight (calculated)
- `percentile` - Growth percentile (10th, 50th, 90th)

---

## ğŸ“Š Features Breakdown

### **1. ğŸ¤° Pregnancy Header**
**File:** `pages/components/obstetrics/PregnancyHeader.tsx`

Features:
- **Visual Timeline**: Progress bar from 0-40 weeks
- **Current GA Display**: "24 Weeks + 3 Days"
- **Smart Alerts**: Context-aware due actions based on GA
  - Week 11-13: NT Scan Due
  - Week 20-22: Anomaly Scan Due
  - Week 28: GTT/Anti-D Prophylaxis
  - Week 34-36: Growth Scan
  - Week 36+: Position Check & Birth Plan

- **Risk Badge**: Color-coded indicator (ğŸŸ¢ Low / ğŸŸ¡ Moderate / ğŸ”´ High)
- **Medication Alerts**: Aspirin prescription status

### **2. âš–ï¸ RCOG Risk Assessment**
**File:** `pages/components/obstetrics/RiskAssessment.tsx`

Checkboxes for 8 risk factors:
- Age > 40
- BMI > 30
- Previous Pre-eclampsia
- Multiple pregnancy (Twins)
- Autoimmune disease
- Hypertension
- Diabetes
- Kidney disease

**Logic:**
- â‰¥1 High Risk Factor â†’ **HIGH RISK** (Aspirin 150mg + close monitoring)
- â‰¥2 Moderate Factors â†’ **HIGH RISK**
- 1 Moderate Factor â†’ **MODERATE RISK**
- 0 Factors â†’ **LOW RISK**

**Outputs:**
- Risk stratification badge
- Medication recommendations (Aspirin, Clexane)
- Saves to database automatically

### **3. ğŸ“‹ ANC Flow Sheet**
**File:** `pages/components/obstetrics/ANCFlowSheet.tsx`

**Data Grid with:**
- Visit Date | GA | BP | Weight | Urine | FHS | Fundal Height | Edema

**Features:**
- Add new visit (modal form)
- Edit existing visits
- Delete visits
- Auto-calculate GA from LMP

**Trend Chart:**
- Line graph showing weight progression
- Blood pressure trends over time
- Helps identify anomalies (pre-eclampsia spikes)

### **4. ğŸ‘¶ Fetal Growth Chart (The "Wow" Feature)**
**File:** `pages/components/obstetrics/FetalGrowthChart.tsx`

**Biometry Input:**
- BPD (Biparietal Diameter) in mm
- HC (Head Circumference) in mm
- AC (Abdominal Circumference) in mm
- FL (Femur Length) in mm

**Auto-Calculations:**
- **Hadlock Formula** for EFW: 
  ```
  log10(EFW) = 1.3404 + 0.0438Ã—HC + 0.158Ã—AC + 0.0061Ã—BPD - 0.002322Ã—ACÃ—BPD
  ```
- **Growth Percentile**: Compared to RCOG/NICE standards
- **Flags**: Red if <10th percentile (growth restriction), Yellow if >90th (macrosomia)

**RCOG Reference Lines:**
- 10th Percentile (Green) - Minimum normal
- 50th Percentile (Blue) - Average
- 90th Percentile (Red) - Maximum normal

**Visual:** Line chart with reference curves and patient's EFW trend

---

## ğŸ› ï¸ Helper Functions (obstetricsService.ts)

### **Calculation Functions**

#### `calculateGestationalAge(lmpDate: string)`
- Input: ISO date string
- Output: `{ weeks, days }`
- Formula: Days difference Ã· 7 = weeks + remainder

#### `calculateEDD(lmpDate: string)`
- Input: LMP date
- Output: ISO date string
- Formula: LMP + 280 days (40 weeks)

#### `calculateEFW(bpd, hc, ac, fl)`
- Hadlock formula for fetal weight estimation
- Returns weight in grams

#### `calculatePercentile(efwGrams, gaWeeks)`
- Compares EFW to RCOG growth standards
- Returns percentile (10, 50, 90)

#### `getDueActions(gaWeeks: number)`
- Returns array of due actions for current GA
- Example: `["âš ï¸ Nuchal Translucency Scan Due", "ğŸ§ª Quad Screen Results Expected"]`

#### `assessRiskLevel(riskFactors)`
- RCOG-compliant risk stratification
- Returns: `{ level, riskFactorsList, aspirinNeeded, thromboprophylaxisNeeded }`

---

## ğŸ—‚ï¸ File Structure

```
pages/
â”œâ”€â”€ ObstetricsDashboard.tsx (Main page)
â””â”€â”€ components/obstetrics/
    â”œâ”€â”€ PregnancyHeader.tsx
    â”œâ”€â”€ RiskAssessment.tsx
    â”œâ”€â”€ ANCFlowSheet.tsx
    â””â”€â”€ FetalGrowthChart.tsx

services/
â”œâ”€â”€ obstetricsService.ts (All calculations & DB operations)
â””â”€â”€ supabaseClient.ts

types.ts (Pregnancy, AntenatalVisit, BiometryScan interfaces)
```

---

## ğŸ”§ Setup Instructions

### **Step 1: Run SQL Script**
```sql
-- Execute OBSTETRICS_SETUP.sql in Supabase SQL Editor
-- Creates: pregnancies, antenatal_visits, biometry_scans tables
-- Adds: RLS policies, indexes
```

### **Step 2: Verify Database**
```bash
# Check tables created:
SELECT * FROM pregnancies LIMIT 1;
SELECT * FROM antenatal_visits LIMIT 1;
SELECT * FROM biometry_scans LIMIT 1;
```

### **Step 3: Start Using**
1. Navigate to **Obstetrics** in the sidebar (new menu item)
2. Select a patient
3. Click **"Create New Pregnancy File"**
4. Enter LMP date or EDD by ultrasound
5. Add visits, scans, and track risk

---

## ğŸ’¡ Key Features

### âœ¨ Smart Alerts
- Automatic due dates calculation
- Context-aware clinical recommendations
- Color-coded risk indicators

### ğŸ“Š Data Visualization
- Growth curve charts with RCOG reference lines
- Weight/BP trends over time
- Percentile bands (10th, 50th, 90th)

### ğŸ§® Auto-Calculations
- GA calculation from any date
- EFW using Hadlock formula
- Growth percentile assessment
- Due action suggestions

### ğŸ’¾ Complete History
- All visits logged with trends
- All scans recorded with biometry
- Risk assessment evolution
- Edit/delete capability

---

## ğŸ¨ UI/UX Details

- **Color Scheme**: Medical teal (#14b8a6) with accent colors
- **Language**: Arabic RTL support throughout
- **Responsive**: Mobile-friendly (6-column BottomNav)
- **Icons**: Lucide React icons for visual clarity
- **Charts**: Recharts for professional data visualization

---

## ğŸš€ Next Steps (Optional Enhancements)

1. **Integration with Reception Module**
   - Link to patient records automatically
   - Sync with existing patient data

2. **Export Functionality**
   - PDF report generation
   - Growth charts export
   - ANC summary printout

3. **Alerts & Notifications**
   - Push notifications for due scans
   - Email reminders for next visit

4. **Mobile App**
   - Offline sync capability
   - Camera integration for ultrasound images

5. **Analytics**
   - Hospital-wide statistics
   - Risk stratification reports
   - Outcome tracking

---

## ğŸ“š References

- **RCOG Guidelines**: Management of Hypertensive Disorders
- **WHO Intergrowth Standards**: Fetal biometry standards
- **Hadlock Formula**: Gold standard for EFW calculation
- **Pre-eclampsia Prevention**: Aspirin 150mg daily from 16 weeks

---

## âš ï¸ Important Notes

1. **RLS Policies**: All authenticated doctors can view all pregnancies (adjust if needed)
2. **Data Validation**: Frontend validation present, add backend validation for production
3. **Backup**: Regular database backups recommended
4. **HIPAA Compliance**: Ensure proper access controls in production

---

## ğŸ› Troubleshooting

**Issue:** Patient list not showing
- **Solution**: Verify `patients` table exists in Supabase

**Issue:** Calculations giving wrong results
- **Solution**: Check LMP/EDD dates are in ISO format (YYYY-MM-DD)

**Issue:** Charts not rendering
- **Solution**: Ensure Recharts is installed: `npm list recharts`

---

**Version:** 1.0.0  
**Created:** December 2025  
**Status:** âœ… Production Ready
</file>

<file path="OBSTETRICS_SETUP_V2.sql">
-- ============================================================================
-- OBSTETRICS MODULE SETUP - Supabase SQL (FIXED RLS)
-- ============================================================================

-- 1. PREGNANCIES TABLE
CREATE TABLE IF NOT EXISTS pregnancies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  doctor_id UUID NOT NULL REFERENCES doctors(id) ON DELETE CASCADE,
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  lmp_date DATE,
  edd_date DATE,
  edd_by_scan DATE,
  ga_at_booking INTEGER,
  risk_level TEXT DEFAULT 'low' CHECK (risk_level IN ('low', 'moderate', 'high')),
  risk_factors JSONB DEFAULT '[]',
  aspirin_prescribed BOOLEAN DEFAULT FALSE,
  thromboprophylaxis_needed BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 2. ANTENATAL VISITS TABLE
CREATE TABLE IF NOT EXISTS antenatal_visits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pregnancy_id UUID NOT NULL REFERENCES pregnancies(id) ON DELETE CASCADE,
  visit_date DATE NOT NULL,
  gestational_age_weeks INTEGER,
  gestational_age_days INTEGER,
  systolic_bp INTEGER,
  diastolic_bp INTEGER,
  weight_kg DECIMAL(5, 2),
  urine_albuminuria TEXT,
  urine_glycosuria TEXT,
  fetal_heart_sound BOOLEAN,
  fundal_height_cm DECIMAL(5, 2),
  edema BOOLEAN,
  edema_grade TEXT,
  notes TEXT,
  next_visit_date DATE,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 3. BIOMETRY SCANS TABLE (Fetal Growth)
CREATE TABLE IF NOT EXISTS biometry_scans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pregnancy_id UUID NOT NULL REFERENCES pregnancies(id) ON DELETE CASCADE,
  scan_date DATE NOT NULL,
  gestational_age_weeks INTEGER,
  gestational_age_days INTEGER,
  bpd_mm DECIMAL(5, 2),
  hc_mm DECIMAL(5, 2),
  ac_mm DECIMAL(5, 2),
  fl_mm DECIMAL(5, 2),
  efw_grams INTEGER,
  percentile INTEGER,
  notes TEXT,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 4. CREATE INDEXES
CREATE INDEX IF NOT EXISTS idx_pregnancies_patient_id ON pregnancies(patient_id);
CREATE INDEX IF NOT EXISTS idx_pregnancies_doctor_id ON pregnancies(doctor_id);
CREATE INDEX IF NOT EXISTS idx_antenatal_visits_pregnancy_id ON antenatal_visits(pregnancy_id);
CREATE INDEX IF NOT EXISTS idx_biometry_scans_pregnancy_id ON biometry_scans(pregnancy_id);

-- 5. ENABLE RLS
ALTER TABLE pregnancies ENABLE ROW LEVEL SECURITY;
ALTER TABLE antenatal_visits ENABLE ROW LEVEL SECURITY;
ALTER TABLE biometry_scans ENABLE ROW LEVEL SECURITY;

-- 6. DROP EXISTING POLICIES
DROP POLICY IF EXISTS "Doctors can read all pregnancies" ON pregnancies;
DROP POLICY IF EXISTS "Doctors can insert pregnancies" ON pregnancies;
DROP POLICY IF EXISTS "Doctors can update pregnancies" ON pregnancies;
DROP POLICY IF EXISTS "Doctors can read all antenatal visits" ON antenatal_visits;
DROP POLICY IF EXISTS "Doctors can insert antenatal visits" ON antenatal_visits;
DROP POLICY IF EXISTS "Doctors can update antenatal visits" ON antenatal_visits;
DROP POLICY IF EXISTS "Doctors can read all biometry scans" ON biometry_scans;
DROP POLICY IF EXISTS "Doctors can insert biometry scans" ON biometry_scans;
DROP POLICY IF EXISTS "Doctors can update biometry scans" ON biometry_scans;

-- 7. NEW RLS POLICIES for pregnancies - Link to authenticated doctor
CREATE POLICY "Doctors can read their pregnancies" ON pregnancies
  FOR SELECT 
  USING (
    auth.uid() IS NOT NULL 
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

CREATE POLICY "Doctors can insert pregnancies" ON pregnancies
  FOR INSERT 
  WITH CHECK (
    auth.uid() IS NOT NULL 
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

CREATE POLICY "Doctors can update their pregnancies" ON pregnancies
  FOR UPDATE 
  USING (
    auth.uid() IS NOT NULL 
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  )
  WITH CHECK (
    auth.uid() IS NOT NULL 
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

-- 8. RLS POLICIES for antenatal_visits
CREATE POLICY "Doctors can read antenatal visits" ON antenatal_visits
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies 
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

CREATE POLICY "Doctors can insert antenatal visits" ON antenatal_visits
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies 
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

CREATE POLICY "Doctors can update antenatal visits" ON antenatal_visits
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies 
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies 
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

-- 9. RLS POLICIES for biometry_scans
CREATE POLICY "Doctors can read biometry scans" ON biometry_scans
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies 
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

CREATE POLICY "Doctors can insert biometry scans" ON biometry_scans
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies 
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

CREATE POLICY "Doctors can update biometry scans" ON biometry_scans
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies 
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies 
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );
</file>

<file path="OBSTETRICS_SETUP.sql">
-- ============================================================================
-- OBSTETRICS MODULE SETUP - Supabase SQL
-- ============================================================================

-- 1. PREGNANCIES TABLE
CREATE TABLE IF NOT EXISTS pregnancies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  lmp_date DATE,
  edd_date DATE,
  edd_by_scan DATE,
  ga_at_booking INTEGER,
  risk_level TEXT DEFAULT 'low' CHECK (risk_level IN ('low', 'moderate', 'high')),
  risk_factors JSONB DEFAULT '[]',
  aspirin_prescribed BOOLEAN DEFAULT FALSE,
  thromboprophylaxis_needed BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 2. ANTENATAL VISITS TABLE
CREATE TABLE IF NOT EXISTS antenatal_visits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pregnancy_id UUID NOT NULL REFERENCES pregnancies(id) ON DELETE CASCADE,
  visit_date DATE NOT NULL,
  gestational_age_weeks INTEGER,
  gestational_age_days INTEGER,
  systolic_bp INTEGER,
  diastolic_bp INTEGER,
  weight_kg DECIMAL(5, 2),
  urine_albuminuria TEXT,
  urine_glycosuria TEXT,
  fetal_heart_sound BOOLEAN,
  fundal_height_cm DECIMAL(5, 2),
  edema BOOLEAN,
  edema_grade TEXT,
  notes TEXT,
  next_visit_date DATE,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 3. BIOMETRY SCANS TABLE (Fetal Growth)
CREATE TABLE IF NOT EXISTS biometry_scans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pregnancy_id UUID NOT NULL REFERENCES pregnancies(id) ON DELETE CASCADE,
  scan_date DATE NOT NULL,
  gestational_age_weeks INTEGER,
  gestational_age_days INTEGER,
  bpd_mm DECIMAL(5, 2),
  hc_mm DECIMAL(5, 2),
  ac_mm DECIMAL(5, 2),
  fl_mm DECIMAL(5, 2),
  efw_grams INTEGER,
  percentile INTEGER,
  notes TEXT,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 4. CREATE INDEXES
CREATE INDEX idx_pregnancies_patient_id ON pregnancies(patient_id);
CREATE INDEX idx_antenatal_visits_pregnancy_id ON antenatal_visits(pregnancy_id);
CREATE INDEX idx_biometry_scans_pregnancy_id ON biometry_scans(pregnancy_id);

-- 5. ENABLE RLS
ALTER TABLE pregnancies ENABLE ROW LEVEL SECURITY;
ALTER TABLE antenatal_visits ENABLE ROW LEVEL SECURITY;
ALTER TABLE biometry_scans ENABLE ROW LEVEL SECURITY;

-- 6. RLS POLICIES for pregnancies
CREATE POLICY "Doctors can read all pregnancies" ON pregnancies
  FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Doctors can insert pregnancies" ON pregnancies
  FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Doctors can update pregnancies" ON pregnancies
  FOR UPDATE USING (auth.role() = 'authenticated');

-- 7. RLS POLICIES for antenatal_visits
CREATE POLICY "Doctors can read all antenatal visits" ON antenatal_visits
  FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Doctors can insert antenatal visits" ON antenatal_visits
  FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Doctors can update antenatal visits" ON antenatal_visits
  FOR UPDATE USING (auth.role() = 'authenticated');

-- 8. RLS POLICIES for biometry_scans
CREATE POLICY "Doctors can read all biometry scans" ON biometry_scans
  FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Doctors can insert biometry scans" ON biometry_scans
  FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Doctors can update biometry scans" ON biometry_scans
  FOR UPDATE USING (auth.role() = 'authenticated');
</file>

<file path="pages/components/InfertilityWizard.tsx">
import React, { useState, useEffect } from 'react';
import { Microscope, Baby, Activity, Heart, Save, AlertCircle, CheckCircle, Clock } from 'lucide-react';
import toast from 'react-hot-toast';
import { getWorkup, saveWorkup, generateDiagnosis, WorkupState } from '../../services/workupService';

interface InfertilityWizardProps {
  patientId: string;
  patientName?: string;
}

const InfertilityWizard: React.FC<InfertilityWizardProps> = ({ patientId, patientName }) => {
  const [workupData, setWorkupData] = useState<WorkupState>({
    patientId,
    ovarianFactor: {},
    maleFactor: {},
    tubalFactor: {},
    uterineFactor: {},
  });
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  // Load data on mount
  useEffect(() => {
    const loadWorkup = async () => {
      try {
        const data = await getWorkup(patientId);
        setWorkupData(data);
      } catch (error) {
        toast.error('Failed to load infertility workup data');
      } finally {
        setLoading(false);
      }
    };

    loadWorkup();
  }, [patientId]);

  // Auto-generate diagnosis whenever data changes
  useEffect(() => {
    const diagnosis = generateDiagnosis(workupData);
    setWorkupData(prev => ({
      ...prev,
      diagnosis: diagnosis.diagnosis,
      plan: diagnosis.plan,
    }));
  }, [workupData.ovarianFactor, workupData.maleFactor, workupData.tubalFactor, workupData.uterineFactor]);

  // Handle input changes
  const updateOvarianFactor = (field: keyof WorkupState['ovarianFactor'], value: any) => {
    setWorkupData(prev => ({
      ...prev,
      ovarianFactor: {
        ...prev.ovarianFactor,
        [field]: value,
      },
    }));
  };

  const updateMaleFactor = (field: keyof WorkupState['maleFactor'], value: any) => {
    setWorkupData(prev => ({
      ...prev,
      maleFactor: {
        ...prev.maleFactor,
        [field]: value,
      },
    }));
  };

  const updateTubalFactor = (field: keyof WorkupState['tubalFactor'], value: any) => {
    setWorkupData(prev => ({
      ...prev,
      tubalFactor: {
        ...prev.tubalFactor,
        [field]: value,
      },
    }));
  };

  const updateUterineFactor = (field: keyof WorkupState['uterineFactor'], value: any) => {
    setWorkupData(prev => ({
      ...prev,
      uterineFactor: {
        ...prev.uterineFactor,
        [field]: value,
      },
    }));
  };

  // Determine card status and color
  const getCardStatus = (factor: any, checks: (() => boolean)[]) => {
    const hasData = Object.values(factor).some(value => value !== undefined && value !== '');
    if (!hasData) return { status: 'missing', color: 'border-gray-300 bg-gray-50', icon: Clock };

    const hasIssues = checks.some(check => check());
    return hasIssues
      ? { status: 'problem', color: 'border-red-300 bg-red-50', icon: AlertCircle }
      : { status: 'normal', color: 'border-green-300 bg-green-50', icon: CheckCircle };
  };

  const ovarianStatus = getCardStatus(workupData.ovarianFactor, [
    () => workupData.ovarianFactor.amh !== undefined && (workupData.ovarianFactor.amh < 1.1 || workupData.ovarianFactor.amh > 3.5),
    () => workupData.ovarianFactor.cycleRegularity === 'Irregular',
  ]);

  const maleStatus = getCardStatus(workupData.maleFactor, [
    () => workupData.maleFactor.spermCount !== undefined && workupData.maleFactor.spermCount < 15,
    () => workupData.maleFactor.motility !== undefined && workupData.maleFactor.motility < 40,
    () => workupData.maleFactor.morphology !== undefined && workupData.maleFactor.morphology < 4,
  ]);

  const tubalStatus = getCardStatus(workupData.tubalFactor, [
    () => workupData.tubalFactor.leftTube === 'Blocked' || workupData.tubalFactor.rightTube === 'Blocked',
    () => workupData.tubalFactor.leftTube === 'Hydrosalpinx' || workupData.tubalFactor.rightTube === 'Hydrosalpinx',
  ]);

  const uterineStatus = getCardStatus(workupData.uterineFactor, [
    () => workupData.uterineFactor.cavityStatus && workupData.uterineFactor.cavityStatus !== 'Normal',
  ]);

  // Handle save
  const handleSave = async () => {
    setSaving(true);
    try {
      await saveWorkup(workupData);
      toast.success('Infertility workup saved successfully!');
    } catch (error) {
      toast.error('Failed to save infertility workup');
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-teal-600"></div>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto space-y-6" style={{ fontFamily: 'Tajawal, sans-serif' }}>
      {/* Header */}
      <div className="bg-gradient-to-r from-teal-600 to-indigo-600 text-white p-6 rounded-2xl shadow-lg">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold mb-2">ğŸ”¬ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø¹Ù‚Ù… Ø§Ù„Ø¢Ù„ÙŠ - Infertility Workup Wizard</h1>
            <p className="text-teal-100">
              Patient: <span className="font-semibold">{patientName || 'Unknown'}</span>
            </p>
          </div>
          <Microscope className="w-16 h-16 text-teal-200" />
        </div>

        {/* Auto-Diagnosis Preview */}
        <div className="mt-6 bg-white/10 backdrop-blur-sm rounded-lg p-4">
          <h3 className="text-lg font-semibold mb-2 flex items-center gap-2">
            <Activity className="w-5 h-5" />
            ØªØ´Ø®ÙŠØµ ØªÙ„Ù‚Ø§Ø¦ÙŠ - Auto-Diagnosis
          </h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <span className="text-sm text-teal-200">Ø§Ù„ØªØ´Ø®ÙŠØµ:</span>
              <p className="font-semibold text-white mt-1">
                {workupData.diagnosis || 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Please enter data'}
              </p>
            </div>
            <div>
              <span className="text-sm text-teal-200">Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø¹Ù„Ø§Ø¬ÙŠØ©:</span>
              <p className="font-semibold text-white mt-1">
                {workupData.plan || 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Please enter data'}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Cards Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        {/* Ovarian Factor Card */}
        <div className={`rounded-xl border-2 p-6 transition-all duration-300 ${ovarianStatus.color}`}>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-white rounded-lg">
                <Baby className="w-6 h-6 text-teal-600" />
              </div>
              <h3 className="text-lg font-bold text-gray-800">Ø§Ù„Ø¹Ø§Ù…Ù„ Ø§Ù„Ù…Ø¨ÙŠØ¶ÙŠ</h3>
            </div>
            <ovarianStatus.icon className={`w-6 h-6 ${
              ovarianStatus.status === 'normal' ? 'text-green-600' :
              ovarianStatus.status === 'problem' ? 'text-red-600' : 'text-gray-400'
            }`} />
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">AMH (ng/mL)</label>
              <input
                type="number"
                step="0.1"
                value={workupData.ovarianFactor.amh || ''}
                onChange={(e) => updateOvarianFactor('amh', parseFloat(e.target.value) || undefined)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                placeholder="e.g., 2.5"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Ø§Ù†ØªØ¸Ø§Ù… Ø§Ù„Ø¯ÙˆØ±Ø©</label>
              <select
                value={workupData.ovarianFactor.cycleRegularity || ''}
                onChange={(e) => updateOvarianFactor('cycleRegularity', e.target.value || undefined)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              >
                <option value="">Ø§Ø®ØªØ± - Select</option>
                <option value="Regular">Ù…Ù†ØªØ¸Ù… - Regular</option>
                <option value="Irregular">ØºÙŠØ± Ù…Ù†ØªØ¸Ù… - Irregular</option>
              </select>
            </div>
          </div>
        </div>

        {/* Male Factor Card */}
        <div className={`rounded-xl border-2 p-6 transition-all duration-300 ${maleStatus.color}`}>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-white rounded-lg">
                <Heart className="w-6 h-6 text-teal-600" />
              </div>
              <h3 className="text-lg font-bold text-gray-800">Ø§Ù„Ø¹Ø§Ù…Ù„ Ø§Ù„Ø°ÙƒØ±ÙŠ</h3>
            </div>
            <maleStatus.icon className={`w-6 h-6 ${
              maleStatus.status === 'normal' ? 'text-green-600' :
              maleStatus.status === 'problem' ? 'text-red-600' : 'text-gray-400'
            }`} />
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Ø¹Ø¯Ø¯ Ø§Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª Ø§Ù„Ù…Ù†ÙˆÙŠØ© (M/mL)</label>
              <input
                type="number"
                value={workupData.maleFactor.spermCount || ''}
                onChange={(e) => updateMaleFactor('spermCount', parseFloat(e.target.value) || undefined)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                placeholder="e.g., 25"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Ø§Ù„Ø­Ø±ÙƒØ© (%)</label>
              <input
                type="number"
                min="0"
                max="100"
                value={workupData.maleFactor.motility || ''}
                onChange={(e) => updateMaleFactor('motility', parseFloat(e.target.value) || undefined)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                placeholder="e.g., 45"
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Ø§Ù„Ø´ÙƒÙ„ (%)</label>
              <input
                type="number"
                min="0"
                max="100"
                value={workupData.maleFactor.morphology || ''}
                onChange={(e) => updateMaleFactor('morphology', parseFloat(e.target.value) || undefined)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                placeholder="e.g., 6"
              />
            </div>
          </div>
        </div>

        {/* Tubal Factor Card */}
        <div className={`rounded-xl border-2 p-6 transition-all duration-300 ${tubalStatus.color}`}>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-white rounded-lg">
                <Activity className="w-6 h-6 text-teal-600" />
              </div>
              <h3 className="text-lg font-bold text-gray-800">Ø§Ù„Ø¹Ø§Ù…Ù„ Ø§Ù„Ø£Ù†Ø¨ÙˆØ¨ÙŠ</h3>
            </div>
            <tubalStatus.icon className={`w-6 h-6 ${
              tubalStatus.status === 'normal' ? 'text-green-600' :
              tubalStatus.status === 'problem' ? 'text-red-600' : 'text-gray-400'
            }`} />
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Ø§Ù„Ø£Ù†Ø¨ÙˆØ¨ Ø§Ù„Ø£ÙŠØ³Ø±</label>
              <select
                value={workupData.tubalFactor.leftTube || ''}
                onChange={(e) => updateTubalFactor('leftTube', e.target.value || undefined)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              >
                <option value="">Ø§Ø®ØªØ± - Select</option>
                <option value="Patent">Ù…ÙØªÙˆØ­ - Patent</option>
                <option value="Blocked">Ù…Ø³Ø¯ÙˆØ¯ - Blocked</option>
                <option value="Hydrosalpinx">Ù‡ÙŠØ¯Ø± Ø³Ø§Ù„Ø¨ÙŠÙ†ÙƒØ³ - Hydrosalpinx</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Ø§Ù„Ø£Ù†Ø¨ÙˆØ¨ Ø§Ù„Ø£ÙŠÙ…Ù†</label>
              <select
                value={workupData.tubalFactor.rightTube || ''}
                onChange={(e) => updateTubalFactor('rightTube', e.target.value || undefined)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              >
                <option value="">Ø§Ø®ØªØ± - Select</option>
                <option value="Patent">Ù…ÙØªÙˆØ­ - Patent</option>
                <option value="Blocked">Ù…Ø³Ø¯ÙˆØ¯ - Blocked</option>
                <option value="Hydrosalpinx">Ù‡ÙŠØ¯Ø± Ø³Ø§Ù„Ø¨ÙŠÙ†ÙƒØ³ - Hydrosalpinx</option>
              </select>
            </div>
          </div>
        </div>

        {/* Uterine Factor Card */}
        <div className={`rounded-xl border-2 p-6 transition-all duration-300 ${uterineStatus.color}`}>
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-3">
              <div className="p-2 bg-white rounded-lg">
                <Microscope className="w-6 h-6 text-teal-600" />
              </div>
              <h3 className="text-lg font-bold text-gray-800">Ø§Ù„Ø¹Ø§Ù…Ù„ Ø§Ù„Ø±Ø­Ù…ÙŠ</h3>
            </div>
            <uterineStatus.icon className={`w-6 h-6 ${
              uterineStatus.status === 'normal' ? 'text-green-600' :
              uterineStatus.status === 'problem' ? 'text-red-600' : 'text-gray-400'
            }`} />
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Ø­Ø§Ù„Ø© Ø§Ù„ØªØ¬ÙˆÙŠÙ</label>
              <select
                value={workupData.uterineFactor.cavityStatus || ''}
                onChange={(e) => updateUterineFactor('cavityStatus', e.target.value || undefined)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              >
                <option value="">Ø§Ø®ØªØ± - Select</option>
                <option value="Normal">Ø·Ø¨ÙŠØ¹ÙŠ - Normal</option>
                <option value="Septum">Ø­Ø§Ø¬Ø² - Septum</option>
                <option value="Polyp">Ø³Ù„ÙŠÙ„Ø© - Polyp</option>
                <option value="Adhesions">Ø§Ù„ØªØµØ§Ù‚Ø§Øª - Adhesions</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      {/* Save Button */}
      <div className="flex justify-center">
        <button
          onClick={handleSave}
          disabled={saving}
          className="bg-teal-600 text-white px-8 py-3 rounded-lg font-bold hover:bg-teal-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
        >
          <Save className="w-5 h-5" />
          {saving ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...' : 'Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… - Save Workup'}
        </button>
      </div>
    </div>
  );
};

export default InfertilityWizard;
</file>

<file path="pages/components/obstetrics/ANCFlowSheet.tsx">
import React, { useState, useEffect } from 'react';
import { Plus, Trash2, Save, X } from 'lucide-react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import toast from 'react-hot-toast';
import { AntenatalVisit } from '../../../types';
import { obstetricsService, calculateGestationalAge } from '../../../services/obstetricsService';

interface ANCFlowSheetProps {
  pregnancyId: string;
  lmpDate?: string;
}

const ANCFlowSheet: React.FC<ANCFlowSheetProps> = ({ pregnancyId, lmpDate }) => {
  const [visits, setVisits] = useState<AntenatalVisit[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [showForm, setShowForm] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [editingId, setEditingId] = useState<string | null>(null);

  const [formData, setFormData] = useState({
    visit_date: new Date().toISOString().split('T')[0],
    systolic_bp: '',
    diastolic_bp: '',
    weight_kg: '',
    urine_albuminuria: 'negative',
    urine_glycosuria: 'negative',
    fetal_heart_sound: true,
    fundal_height_cm: '',
    edema: false,
    edema_grade: 'none',
    notes: '',
    next_visit_date: '',
  });

  useEffect(() => {
    fetchVisits();
  }, [pregnancyId]);

  const fetchVisits = async () => {
    try {
      setIsLoading(true);
      const data = await obstetricsService.getANCVisits(pregnancyId);
      setVisits(data || []);
    } catch (error) {
      console.error('Error fetching visits:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø³Ø¬Ù„ Ø§Ù„Ø²ÙŠØ§Ø±Ø§Øª');
    } finally {
      setIsLoading(false);
    }
  };

  const handleAddVisit = async () => {
    try {
      if (!formData.visit_date) {
        toast.error('ØªØ§Ø±ÙŠØ® Ø§Ù„Ø²ÙŠØ§Ø±Ø© Ù…Ø·Ù„ÙˆØ¨');
        return;
      }

      setIsSaving(true);

      let ga = { weeks: 0, days: 0 };
      if (lmpDate && formData.visit_date) {
        try {
          const lmpTimestamp = new Date(lmpDate).getTime();
          const visitTimestamp = new Date(formData.visit_date).getTime();
          if (!isNaN(lmpTimestamp) && !isNaN(visitTimestamp)) {
            const diffTime = Math.abs(visitTimestamp - lmpTimestamp);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            ga = { weeks: Math.max(0, Math.floor(diffDays / 7)), days: Math.max(0, diffDays % 7) };
          }
        } catch (err) {
          console.warn('Error calculating GA:', err);
          ga = { weeks: 0, days: 0 };
        }
      }

      const systolicBP = formData.systolic_bp ? parseInt(formData.systolic_bp) : null;
      const diastolicBP = formData.diastolic_bp ? parseInt(formData.diastolic_bp) : null;
      const weightKg = formData.weight_kg ? parseFloat(formData.weight_kg) : null;
      const fundalHeight = formData.fundal_height_cm ? parseFloat(formData.fundal_height_cm) : null;
      const nextVisitDate = formData.next_visit_date?.trim() || null;

      const visitData = {
        visit_date: formData.visit_date,
        pregnancy_id: pregnancyId,
        gestational_age_weeks: Math.max(0, ga.weeks),
        gestational_age_days: Math.max(0, ga.days),
        systolic_bp: !isNaN(Number(systolicBP)) && systolicBP !== null ? systolicBP : null,
        diastolic_bp: !isNaN(Number(diastolicBP)) && diastolicBP !== null ? diastolicBP : null,
        weight_kg: !isNaN(Number(weightKg)) && weightKg !== null ? weightKg : null,
        urine_albuminuria: formData.urine_albuminuria || 'negative',
        urine_glycosuria: formData.urine_glycosuria || 'negative',
        fetal_heart_sound: Boolean(formData.fetal_heart_sound),
        fundal_height_cm: !isNaN(Number(fundalHeight)) && fundalHeight !== null ? fundalHeight : null,
        edema: Boolean(formData.edema),
        edema_grade: formData.edema_grade || 'none',
        notes: formData.notes?.trim() || '',
        next_visit_date: nextVisitDate,
      };

      if (editingId) {
        await obstetricsService.updateANCVisit(editingId, visitData);
        toast.success('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø²ÙŠØ§Ø±Ø© Ø¨Ù†Ø¬Ø§Ø­');
      } else {
        await obstetricsService.createANCVisit(visitData);
        toast.success('ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø²ÙŠØ§Ø±Ø© Ø¨Ù†Ø¬Ø§Ø­');
      }

      fetchVisits();
      resetForm();
    } catch (error) {
      console.error('Error saving visit:', error);
      toast.error('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø²ÙŠØ§Ø±Ø©');
    } finally {
      setIsSaving(false);
    }
  };

  const handleDeleteVisit = async (visitId: string) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ø²ÙŠØ§Ø±Ø©ØŸ')) return;

    try {
      await obstetricsService.deleteANCVisit(visitId);
      toast.success('ØªÙ… Ø­Ø°Ù Ø§Ù„Ø²ÙŠØ§Ø±Ø© Ø¨Ù†Ø¬Ø§Ø­');
      fetchVisits();
    } catch (error) {
      console.error('Error deleting visit:', error);
      toast.error('ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ø²ÙŠØ§Ø±Ø©');
    }
  };

  const handleEditVisit = (visit: AntenatalVisit) => {
    setFormData({
      visit_date: visit.visit_date,
      systolic_bp: visit.systolic_bp?.toString() || '',
      diastolic_bp: visit.diastolic_bp?.toString() || '',
      weight_kg: visit.weight_kg?.toString() || '',
      urine_albuminuria: visit.urine_albuminuria || 'negative',
      urine_glycosuria: visit.urine_glycosuria || 'negative',
      fetal_heart_sound: visit.fetal_heart_sound ?? true,
      fundal_height_cm: visit.fundal_height_cm?.toString() || '',
      edema: visit.edema || false,
      edema_grade: visit.edema_grade || 'none',
      notes: visit.notes || '',
      next_visit_date: visit.next_visit_date || '',
    });
    setEditingId(visit.id);
    setShowForm(true);
  };

  const resetForm = () => {
    setFormData({
      visit_date: new Date().toISOString().split('T')[0],
      systolic_bp: '',
      diastolic_bp: '',
      weight_kg: '',
      urine_albuminuria: 'negative',
      urine_glycosuria: 'negative',
      fetal_heart_sound: true,
      fundal_height_cm: '',
      edema: false,
      edema_grade: 'none',
      notes: '',
      next_visit_date: '',
    });
    setEditingId(null);
    setShowForm(false);
  };

  const chartData = visits && Array.isArray(visits)
    ? visits
        .slice()
        .reverse()
        .map(visit => {
          try {
            const visitDate = visit?.visit_date ? new Date(visit.visit_date).toLocaleDateString('ar-EG') : 'Unknown Date';
            return {
              date: visitDate,
              weight: Number(visit?.weight_kg) || 0,
              systolic: Number(visit?.systolic_bp) || 0,
              diastolic: Number(visit?.diastolic_bp) || 0,
            };
          } catch (err) {
            console.warn('Error mapping visit data:', err);
            return { date: 'Error', weight: 0, systolic: 0, diastolic: 0 };
          }
        })
        .filter(d => d.weight > 0 || d.systolic > 0)
    : [];

  return (
    <div className="bg-white rounded-lg shadow-md p-6 mb-6" dir="ltr">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-bold text-gray-900 font-[Tajawal]">ğŸ“‹ ANC Flowsheet</h2>
        <button
          onClick={() => setShowForm(!showForm)}
          className="flex items-center gap-2 bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-lg font-semibold transition-colors"
        >
          <Plus size={18} />
          Add Visit
        </button>
      </div>

      {showForm && (
        <div className="mb-6 p-6 bg-gray-50 rounded-lg border-2 border-teal-200" dir="ltr">
          <div className="grid md:grid-cols-2 gap-4 mb-4 text-left">
            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Visit Date
              </label>
              <input
                type="date"
                value={formData.visit_date}
                onChange={(e) => setFormData(prev => ({ ...prev, visit_date: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Weight (kg)
              </label>
              <input
                type="number"
                step="0.1"
                value={formData.weight_kg}
                onChange={(e) => setFormData(prev => ({ ...prev, weight_kg: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Systolic BP (mmHg)
              </label>
              <input
                type="number"
                value={formData.systolic_bp}
                onChange={(e) => setFormData(prev => ({ ...prev, systolic_bp: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Diastolic BP (mmHg)
              </label>
              <input
                type="number"
                value={formData.diastolic_bp}
                onChange={(e) => setFormData(prev => ({ ...prev, diastolic_bp: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Urine Albuminuria
              </label>
              <select
                value={formData.urine_albuminuria}
                onChange={(e) => setFormData(prev => ({ ...prev, urine_albuminuria: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
              >
                <option value="negative">Ø³Ø§Ù„Ø¨</option>
                <option value="trace">Ø£Ø«Ø±</option>
                <option value="1plus">+1</option>
                <option value="2plus">+2</option>
                <option value="3plus">+3</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Urine Glycosuria
              </label>
              <select
                value={formData.urine_glycosuria}
                onChange={(e) => setFormData(prev => ({ ...prev, urine_glycosuria: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
              >
                <option value="negative">Ø³Ø§Ù„Ø¨</option>
                <option value="trace">Ø£Ø«Ø±</option>
                <option value="1plus">+1</option>
                <option value="2plus">+2</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Fundal Height (cm)
              </label>
              <input
                type="number"
                step="0.5"
                value={formData.fundal_height_cm}
                onChange={(e) => setFormData(prev => ({ ...prev, fundal_height_cm: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Next Visit Date
              </label>
              <input
                type="date"
                value={formData.next_visit_date}
                onChange={(e) => setFormData(prev => ({ ...prev, next_visit_date: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>
          </div>

          <div className="flex items-center gap-4 mb-4">
            <label className="flex items-center gap-2 cursor-pointer">
              <input
                type="checkbox"
                checked={formData.fetal_heart_sound}
                onChange={(e) => setFormData(prev => ({ ...prev, fetal_heart_sound: e.target.checked }))}
                className="w-4 h-4"
              />
              <span className="text-sm text-gray-700">Fetal Heart Sound (FHS) Detected</span>
            </label>

            <label className="flex items-center gap-2 cursor-pointer">
              <input
                type="checkbox"
                checked={formData.edema}
                onChange={(e) => setFormData(prev => ({ ...prev, edema: e.target.checked }))}
                className="w-4 h-4"
              />
              <span className="text-sm text-gray-700">Edema Present</span>
            </label>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-semibold text-gray-700 mb-2">
              Clinical Notes
            </label>
            <textarea
              value={formData.notes}
              onChange={(e) => setFormData(prev => ({ ...prev, notes: e.target.value }))}
              rows={3}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
            />
          </div>

          <div className="flex gap-2">
            <button
              onClick={handleAddVisit}
              disabled={isSaving}
              className="flex items-center gap-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
            >
              <Save size={18} />
              {isSaving ? 'Saving...' : editingId ? 'Update Visit' : 'Add Visit'}
            </button>
            <button
              onClick={resetForm}
              className="flex items-center gap-2 bg-gray-400 hover:bg-gray-500 text-white px-6 py-2 rounded-lg font-semibold transition-colors"
            >
              <X size={18} />
              Cancel
            </button>
          </div>
        </div>
      )}

      {chartData.length > 1 && (
        <div className="mb-6 p-4 bg-gray-50 rounded-lg" dir="ltr">
          <h3 className="text-sm font-bold text-gray-900 mb-4">ğŸ“ˆ Weight & BP Trends</h3>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={chartData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis yAxisId="left" />
              <YAxis yAxisId="right" orientation="right" />
              <Tooltip />
              <Legend />
              <Line yAxisId="left" type="monotone" dataKey="weight" stroke="#14b8a6" name="Weight (kg)" />
              <Line yAxisId="right" type="monotone" dataKey="systolic" stroke="#dc2626" name="Systolic BP (mmHg)" />
            </LineChart>
          </ResponsiveContainer>
        </div>
      )}

      {isLoading ? (
        <div className="text-center py-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-teal-600 mx-auto"></div>
        </div>
      ) : visits.length > 0 ? (
        <div className="overflow-x-auto" dir="ltr">
          <table className="w-full text-sm text-left">
            <thead className="bg-gray-100">
              <tr>
                <th className="px-4 py-2">Visit Date</th>
                <th className="px-4 py-2">GA (wks+days)</th>
                <th className="px-4 py-2">Weight (kg)</th>
                <th className="px-4 py-2">BP (mmHg)</th>
                <th className="px-4 py-2">Urine Alb</th>
                <th className="px-4 py-2">Fundal Height (cm)</th>
                <th className="px-4 py-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {Array.isArray(visits) && visits.map((visit) => {
                try {
                  if (!visit || !visit.id) return null;
                  return (
                    <tr key={visit.id} className="border-b hover:bg-gray-50">
                      <td className="px-4 py-2">
                        {visit?.visit_date ? new Date(visit.visit_date).toLocaleDateString('ar-EG') : '-'}
                      </td>
                      <td className="px-4 py-2">
                        {Number(visit?.gestational_age_weeks) || 0}w+{Number(visit?.gestational_age_days) || 0}d
                      </td>
                      <td className="px-4 py-2">{visit?.weight_kg || '-'}</td>
                      <td className="px-4 py-2">
                        {visit?.systolic_bp && visit?.diastolic_bp
                          ? `${visit.systolic_bp}/${visit.diastolic_bp}`
                          : '-'}
                      </td>
                      <td className="px-4 py-2">{visit?.urine_albuminuria || '-'}</td>
                      <td className="px-4 py-2">{visit?.fundal_height_cm || '-'}</td>
                      <td className="px-4 py-2 flex gap-2">
                        <button
                          onClick={() => handleEditVisit(visit)}
                          className="text-blue-600 hover:text-blue-800 font-semibold"
                        >
                          Edit
                        </button>
                        <button
                          onClick={() => handleDeleteVisit(visit.id)}
                          className="text-red-600 hover:text-red-800"
                        >
                          <Trash2 size={16} />
                        </button>
                      </td>
                    </tr>
                  );
                } catch (err) {
                  console.warn('Error rendering visit row:', err);
                  return null;
                }
              })}
            </tbody>
          </table>
        </div>
      ) : (
        <p className="text-center text-gray-500 py-8">No visits recorded yet</p>
      )}
    </div>
  );
};

export default ANCFlowSheet;
</file>

<file path="pages/components/obstetrics/FetalGrowthChart.tsx">
import React, { useState, useEffect } from 'react';
import { Plus, Save, Trash2, X } from 'lucide-react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import toast from 'react-hot-toast';
import { BiometryScan } from '../../../types';
import { obstetricsService, calculateEFW, calculatePercentile, calculateGestationalAge } from '../../../services/obstetricsService';

interface FetalGrowthChartProps {
  pregnancyId: string;
  lmpDate?: string;
}

const FetalGrowthChart: React.FC<FetalGrowthChartProps> = ({ pregnancyId, lmpDate }) => {
  const [scans, setScans] = useState<BiometryScan[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [showForm, setShowForm] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [editingId, setEditingId] = useState<string | null>(null);

  const [formData, setFormData] = useState({
    scan_date: new Date().toISOString().split('T')[0],
    bpd_mm: '',
    hc_mm: '',
    ac_mm: '',
    fl_mm: '',
    notes: '',
  });

  useEffect(() => {
    fetchScans();
  }, [pregnancyId]);

  const fetchScans = async () => {
    try {
      setIsLoading(true);
      const data = await obstetricsService.getBiometryScans(pregnancyId);
      setScans(data || []);
    } catch (error) {
      console.error('Error fetching scans:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠÙˆÙ…ÙŠØªØ±ÙŠ');
    } finally {
      setIsLoading(false);
    }
  };

  const handleAddScan = async () => {
    try {
      if (!formData.scan_date || !formData.bpd_mm || !formData.hc_mm || !formData.ac_mm || !formData.fl_mm) {
        toast.error('Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨Ø©');
        return;
      }

      setIsSaving(true);

      const bpd = parseFloat(formData.bpd_mm);
      const hc = parseFloat(formData.hc_mm);
      const ac = parseFloat(formData.ac_mm);
      const fl = parseFloat(formData.fl_mm);

      let ga = { weeks: 20, days: 0 };
      if (lmpDate && formData.scan_date) {
        try {
          const lmpTimestamp = new Date(lmpDate).getTime();
          const scanTimestamp = new Date(formData.scan_date).getTime();
          if (!isNaN(lmpTimestamp) && !isNaN(scanTimestamp)) {
            const diffTime = Math.abs(scanTimestamp - lmpTimestamp);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            ga = { weeks: Math.max(0, Math.floor(diffDays / 7)), days: Math.max(0, diffDays % 7) };
          }
        } catch (err) {
          console.warn('Error calculating GA:', err);
          ga = { weeks: 20, days: 0 };
        }
      }

      if (isNaN(bpd) || isNaN(hc) || isNaN(ac) || isNaN(fl) || bpd <= 0 || hc <= 0 || ac <= 0 || fl <= 0) {
        toast.error('Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø£Ø±Ù‚Ø§Ù… Ù…ÙˆØ¬Ø¨Ø©');
        setIsSaving(false);
        return;
      }

      const efw = calculateEFW(bpd, hc, ac, fl);
      const percentile = calculatePercentile(efw, ga.weeks);

      if (!efw || efw === 0) {
        toast.error('ÙØ´Ù„ Ø­Ø³Ø§Ø¨ ÙˆØ²Ù† Ø§Ù„Ø¬Ù†ÙŠÙ† Ø§Ù„Ù…Ù‚Ø¯Ø±. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª');
        setIsSaving(false);
        return;
      }

      const scanData = {
        scan_date: formData.scan_date,
        bpd_mm: Math.max(0, bpd),
        hc_mm: Math.max(0, hc),
        ac_mm: Math.max(0, ac),
        fl_mm: Math.max(0, fl),
        efw_grams: Math.max(0, efw),
        percentile: Math.max(0, Math.round(percentile)),
        pregnancy_id: pregnancyId,
        gestational_age_weeks: Math.max(0, ga.weeks),
        gestational_age_days: Math.max(0, ga.days),
        notes: formData.notes?.trim() || '',
      };

      if (editingId) {
        await obstetricsService.updateBiometryScan(editingId, scanData);
        toast.success('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³Ø­ Ø¨Ù†Ø¬Ø§Ø­');
      } else {
        await obstetricsService.createBiometryScan(scanData);
        toast.success('ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³Ø­ Ø¨Ù†Ø¬Ø§Ø­');
      }

      fetchScans();
      resetForm();
    } catch (error) {
      console.error('Error saving scan:', error);
      toast.error('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù…Ø³Ø­');
    } finally {
      setIsSaving(false);
    }
  };

  const handleDeleteScan = async (scanId: string) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³Ø­ØŸ')) return;

    try {
      await obstetricsService.deleteBiometryScan(scanId);
      toast.success('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø­ Ø¨Ù†Ø¬Ø§Ø­');
      fetchScans();
    } catch (error) {
      console.error('Error deleting scan:', error);
      toast.error('ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø³Ø­');
    }
  };

  const handleEditScan = (scan: BiometryScan) => {
    setFormData({
      scan_date: scan.scan_date,
      bpd_mm: scan.bpd_mm?.toString() || '',
      hc_mm: scan.hc_mm?.toString() || '',
      ac_mm: scan.ac_mm?.toString() || '',
      fl_mm: scan.fl_mm?.toString() || '',
      notes: scan.notes || '',
    });
    setEditingId(scan.id);
    setShowForm(true);
  };

  const resetForm = () => {
    setFormData({
      scan_date: new Date().toISOString().split('T')[0],
      bpd_mm: '',
      hc_mm: '',
      ac_mm: '',
      fl_mm: '',
      notes: '',
    });
    setEditingId(null);
    setShowForm(false);
  };

  const chartData = scans && Array.isArray(scans)
    ? scans
        .slice()
        .reverse()
        .map((scan, idx) => {
          try {
            const gaWeeks = Number(scan?.gestational_age_weeks) || 20;
            return {
              name: `${gaWeeks}w`,
              efw: Number(scan?.efw_grams) || 0,
              p10: getP10(gaWeeks),
              p50: getP50(gaWeeks),
              p90: getP90(gaWeeks),
              percentile: Number(scan?.percentile) || 50,
            };
          } catch (err) {
            console.warn('Error mapping scan data:', err);
            return { name: '20w', efw: 0, p10: 0, p50: 0, p90: 0, percentile: 50 };
          }
        })
    : [];

  const getP10 = (weeks: number): number => {
    const weights: { [key: number]: number } = {
      20: 300, 22: 430, 24: 600, 26: 760, 28: 1000, 30: 1300, 32: 1600, 34: 2100, 36: 2600, 38: 3000, 40: 3200,
    };
    return weights[weeks] || 0;
  };

  const getP50 = (weeks: number): number => {
    const weights: { [key: number]: number } = {
      20: 330, 22: 475, 24: 660, 26: 850, 28: 1100, 30: 1440, 32: 1840, 34: 2450, 36: 3000, 38: 3400, 40: 3500,
    };
    return weights[weeks] || 0;
  };

  const getP90 = (weeks: number): number => {
    const weights: { [key: number]: number } = {
      20: 370, 22: 540, 24: 750, 26: 980, 28: 1270, 30: 1680, 32: 2150, 34: 2850, 36: 3500, 38: 3900, 40: 3900,
    };
    return weights[weeks] || 0;
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6 mb-6">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-bold text-gray-900 font-[Tajawal]">ğŸ‘¶ Ù…Ø®Ø·Ø· Ù†Ù…Ùˆ Ø§Ù„Ø¬Ù†ÙŠÙ†</h2>
        <button
          onClick={() => setShowForm(!showForm)}
          className="flex items-center gap-2 bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-lg font-[Tajawal] font-semibold transition-colors"
        >
          <Plus size={18} />
          Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø­
        </button>
      </div>

      {showForm && (
        <div className="mb-6 p-6 bg-gray-50 rounded-lg border-2 border-teal-200">
          <div className="grid md:grid-cols-2 gap-4 mb-4">
            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
                ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø³Ø­
              </label>
              <input
                type="date"
                value={formData.scan_date}
                onChange={(e) => setFormData(prev => ({ ...prev, scan_date: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
                BPD (Biparietal Diameter) - Ù…Ù„Ù…
              </label>
              <input
                type="number"
                step="0.1"
                value={formData.bpd_mm}
                onChange={(e) => setFormData(prev => ({ ...prev, bpd_mm: e.target.value }))}
                placeholder="Ù…Ø«Ø§Ù„: 54.2"
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
                HC (Head Circumference) - Ù…Ù„Ù…
              </label>
              <input
                type="number"
                step="0.1"
                value={formData.hc_mm}
                onChange={(e) => setFormData(prev => ({ ...prev, hc_mm: e.target.value }))}
                placeholder="Ù…Ø«Ø§Ù„: 285"
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
                AC (Abdominal Circumference) - Ù…Ù„Ù…
              </label>
              <input
                type="number"
                step="0.1"
                value={formData.ac_mm}
                onChange={(e) => setFormData(prev => ({ ...prev, ac_mm: e.target.value }))}
                placeholder="Ù…Ø«Ø§Ù„: 254"
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
                FL (Femur Length) - Ù…Ù„Ù…
              </label>
              <input
                type="number"
                step="0.1"
                value={formData.fl_mm}
                onChange={(e) => setFormData(prev => ({ ...prev, fl_mm: e.target.value }))}
                placeholder="Ù…Ø«Ø§Ù„: 68"
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>

            <div>
              <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
                Ù…Ù„Ø§Ø­Ø¸Ø§Øª
              </label>
              <input
                type="text"
                value={formData.notes}
                onChange={(e) => setFormData(prev => ({ ...prev, notes: e.target.value }))}
                className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
              />
            </div>
          </div>

          <div className="flex gap-2">
            <button
              onClick={handleAddScan}
              disabled={isSaving}
              className="flex items-center gap-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white px-6 py-2 rounded-lg font-[Tajawal] font-semibold transition-colors"
            >
              <Save size={18} />
              {isSaving ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...' : editingId ? 'ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³Ø­' : 'Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³Ø­'}
            </button>
            <button
              onClick={resetForm}
              className="flex items-center gap-2 bg-gray-400 hover:bg-gray-500 text-white px-6 py-2 rounded-lg font-[Tajawal] font-semibold transition-colors"
            >
              <X size={18} />
              Ø¥Ù„ØºØ§Ø¡
            </button>
          </div>
        </div>
      )}

      {isLoading ? (
        <div className="text-center py-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-teal-600 mx-auto"></div>
        </div>
      ) : scans.length > 0 ? (
        <>
          <div className="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
            <p className="text-sm text-blue-900 font-[Tajawal]">
              ğŸ“Š <strong>Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø±Ø¬Ø¹ÙŠØ© (RCOG/NICE):</strong> Ø§Ù„Ø®Ø· Ø§Ù„Ø£Ø®Ø¶Ø± = 10th percentile (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ)ØŒ Ø§Ù„Ø£Ø²Ø±Ù‚ = 50th (Ø§Ù„Ù…ØªÙˆØ³Ø·)ØŒ Ø§Ù„Ø£Ø­Ù…Ø± = 90th (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¹Ù„Ù‰)
            </p>
          </div>

          <div className="mb-6">
            <ResponsiveContainer width="100%" height={400}>
              <LineChart data={chartData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis label={{ value: 'Ø§Ù„ÙˆØ²Ù† (Ø¬Ø±Ø§Ù…)', angle: -90, position: 'insideLeft' }} />
                <Tooltip
                  formatter={(value: any) => `${value.toLocaleString()} g`}
                  labelFormatter={(label) => `Ø£Ø³Ø§Ø¨ÙŠØ¹: ${label}`}
                />
                <Legend />
                <Line
                  type="monotone"
                  dataKey="p10"
                  stroke="#16a34a"
                  strokeDasharray="5 5"
                  name="10th Percentile"
                  isAnimationActive={false}
                />
                <Line
                  type="monotone"
                  dataKey="p50"
                  stroke="#3b82f6"
                  strokeDasharray="5 5"
                  name="50th Percentile"
                  isAnimationActive={false}
                />
                <Line
                  type="monotone"
                  dataKey="p90"
                  stroke="#dc2626"
                  strokeDasharray="5 5"
                  name="90th Percentile"
                  isAnimationActive={false}
                />
                <Line
                  type="monotone"
                  dataKey="efw"
                  stroke="#14b8a6"
                  name="ÙˆØ²Ù† Ø§Ù„Ø¬Ù†ÙŠÙ† Ø§Ù„Ù…Ù‚Ø¯Ø± (EFW)"
                  strokeWidth={2}
                  connectNulls
                />
              </LineChart>
            </ResponsiveContainer>
          </div>

          <div className="overflow-x-auto">
            <table className="w-full text-sm font-[Tajawal]">
              <thead className="bg-gray-100">
                <tr>
                  <th className="px-4 py-2 text-right">Ø§Ù„ØªØ§Ø±ÙŠØ®</th>
                  <th className="px-4 py-2 text-right">GA</th>
                  <th className="px-4 py-2 text-right">BPD</th>
                  <th className="px-4 py-2 text-right">HC</th>
                  <th className="px-4 py-2 text-right">AC</th>
                  <th className="px-4 py-2 text-right">FL</th>
                  <th className="px-4 py-2 text-right">EFW</th>
                  <th className="px-4 py-2 text-right">Ø§Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø¦ÙˆÙŠØ©</th>
                  <th className="px-4 py-2 text-right">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</th>
                </tr>
              </thead>
              <tbody>
                {Array.isArray(scans) && scans.map((scan) => {
                  try {
                    if (!scan || !scan.id) return null;
                    const scanDate = scan?.scan_date ? new Date(scan.scan_date).toLocaleDateString('ar-EG') : '-';
                    const gaWeeks = Number(scan?.gestational_age_weeks) || 0;
                    const gaDays = Number(scan?.gestational_age_days) || 0;
                    const efwGrams = Number(scan?.efw_grams) || 0;
                    const percentile = Number(scan?.percentile) || 50;

                    return (
                      <tr key={scan.id} className="border-b hover:bg-gray-50">
                        <td className="px-4 py-2">{scanDate}</td>
                        <td className="px-4 py-2">{gaWeeks}w+{gaDays}d</td>
                        <td className="px-4 py-2">{scan?.bpd_mm || '-'} Ù…Ù„Ù…</td>
                        <td className="px-4 py-2">{scan?.hc_mm || '-'} Ù…Ù„Ù…</td>
                        <td className="px-4 py-2">{scan?.ac_mm || '-'} Ù…Ù„Ù…</td>
                        <td className="px-4 py-2">{scan?.fl_mm || '-'} Ù…Ù„Ù…</td>
                        <td className="px-4 py-2 font-bold text-teal-700">
                          {efwGrams > 0 ? efwGrams.toLocaleString() : '-'} g
                        </td>
                        <td className="px-4 py-2">
                          <span
                            className={`px-3 py-1 rounded-full text-xs font-bold ${
                              percentile < 10
                                ? 'bg-red-100 text-red-800'
                                : percentile > 90
                                ? 'bg-yellow-100 text-yellow-800'
                                : 'bg-green-100 text-green-800'
                            }`}
                          >
                            {percentile}th
                          </span>
                        </td>
                        <td className="px-4 py-2 flex gap-2">
                          <button
                            onClick={() => handleEditScan(scan)}
                            className="text-blue-600 hover:text-blue-800 font-semibold"
                          >
                            ØªØ­Ø±ÙŠØ±
                          </button>
                          <button
                            onClick={() => handleDeleteScan(scan.id)}
                            className="text-red-600 hover:text-red-800"
                          >
                            <Trash2 size={16} />
                          </button>
                        </td>
                      </tr>
                    );
                  } catch (err) {
                    console.warn('Error rendering scan row:', err);
                    return null;
                  }
                })}
              </tbody>
            </table>
          </div>
        </>
      ) : (
        <p className="text-center text-gray-500 py-8 font-[Tajawal]">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³ÙˆØ­Ø§Øª Ø¨ÙŠÙˆÙ…ÙŠØªØ±ÙŠØ© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†</p>
      )}
    </div>
  );
};

export default FetalGrowthChart;
</file>

<file path="pages/components/obstetrics/RiskAssessment.tsx">
import React, { useState } from 'react';
import { ChevronDown, ChevronUp, Save } from 'lucide-react';
import { Pregnancy } from '../../../types';
import { assessRiskLevel, RiskFactors } from '../../../services/obstetricsService';
import toast from 'react-hot-toast';

interface RiskAssessmentProps {
  pregnancy: Pregnancy;
  onUpdate: (updates: Partial<Pregnancy>) => Promise<void>;
}

const RiskAssessment: React.FC<RiskAssessmentProps> = ({ pregnancy, onUpdate }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // Fix the risk factors parsing - ensure we handle null/undefined safely
  const currentFactors = pregnancy.risk_factors || []; // Fallback to empty array
  const initialRiskFactors: RiskFactors = {
    age_over_40: currentFactors.includes('age_over_40'),
    bmi_over_30: currentFactors.includes('bmi_over_30'),
    previous_preeclampsia: currentFactors.includes('previous_preeclampsia'),
    twins: currentFactors.includes('twins'),
    autoimmune: currentFactors.includes('autoimmune'),
    hypertension: currentFactors.includes('hypertension'),
    diabetes: currentFactors.includes('diabetes'),
    kidney_disease: currentFactors.includes('kidney_disease'),
  };

  const [riskFactors, setRiskFactors] = useState<RiskFactors>(initialRiskFactors);
  const riskAssessment = assessRiskLevel(riskFactors);

  const riskFactorOptions = [
    { key: 'age_over_40', label: 'Ø§Ù„Ø¹Ù…Ø± > 40 Ø³Ù†Ø©' },
    { key: 'bmi_over_30', label: 'Ù…Ø¤Ø´Ø± ÙƒØªÙ„Ø© Ø§Ù„Ø¬Ø³Ù… > 30' },
    { key: 'previous_preeclampsia', label: 'ØªØ³Ù…Ù… Ø§Ù„Ø­Ù…Ù„ Ø§Ù„Ø³Ø§Ø¨Ù‚' },
    { key: 'twins', label: 'Ø­Ù…Ù„ Ù…ØªØ¹Ø¯Ø¯ (ØªÙˆØ£Ù… Ø£Ùˆ Ø£ÙƒØ«Ø±)' },
    { key: 'autoimmune', label: 'Ø£Ù…Ø±Ø§Ø¶ Ø§Ù„Ù…Ù†Ø§Ø¹Ø© Ø§Ù„Ø°Ø§ØªÙŠØ©' },
    { key: 'hypertension', label: 'Ø§Ø±ØªÙØ§Ø¹ Ø¶ØºØ· Ø§Ù„Ø¯Ù…' },
    { key: 'diabetes', label: 'Ø§Ù„Ø³ÙƒØ±ÙŠ' },
    { key: 'kidney_disease', label: 'Ø£Ù…Ø±Ø§Ø¶ Ø§Ù„ÙƒÙ„Ù‰' },
  ];

  const handleFactorChange = (key: keyof RiskFactors) => {
    setRiskFactors(prev => ({
      ...prev,
      [key]: !prev[key],
    }));
  };

  const handleSave = async () => {
    try {
      setIsSaving(true);
      
      const updatedRiskFactors = Object.keys(riskFactors)
        .filter(key => riskFactors[key as keyof RiskFactors])
        .map(key => key as string);

      if (!Array.isArray(updatedRiskFactors)) {
        throw new Error('Risk factors must be an array');
      }

      await onUpdate({
        risk_factors: updatedRiskFactors || [],
        risk_level: riskAssessment.level,
        aspirin_prescribed: riskAssessment.aspirinNeeded,
        thromboprophylaxis_needed: riskAssessment.thromboprophylaxisNeeded,
      });

      toast.success('ØªÙ… ØªØ­Ø¯ÙŠØ« ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('Error saving risk assessment:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…Ø®Ø§Ø·Ø±');
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6 mb-6">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="w-full flex items-center justify-between text-lg font-bold text-gray-900 hover:text-teal-700 transition-colors font-[Tajawal]"
      >
        <span>âš–ï¸ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø­Ø³Ø¨ RCOG</span>
        {isExpanded ? <ChevronUp size={24} /> : <ChevronDown size={24} />}
      </button>

      {isExpanded && (
        <div className="mt-6 space-y-4">
          <div className="grid md:grid-cols-2 gap-4">
            {riskFactorOptions.map(option => (
              <label
                key={option.key}
                className="flex items-center gap-3 p-3 bg-gray-50 rounded-lg cursor-pointer hover:bg-gray-100 transition-colors"
              >
                <input
                  type="checkbox"
                  checked={riskFactors[option.key as keyof RiskFactors]}
                  onChange={() => handleFactorChange(option.key as keyof RiskFactors)}
                  className="w-4 h-4 text-teal-600 rounded cursor-pointer"
                />
                <span className="text-sm text-gray-700 font-[Tajawal]">{option.label}</span>
              </label>
            ))}
          </div>

          <div className="mt-6 p-4 rounded-lg border-2" style={{
            borderColor: riskAssessment.level === 'high' ? '#dc2626' : riskAssessment.level === 'moderate' ? '#f97316' : '#16a34a',
            backgroundColor: riskAssessment.level === 'high' ? '#fef2f2' : riskAssessment.level === 'moderate' ? '#fff7ed' : '#f0fdf4',
          }}>
            <div className="flex items-center justify-between mb-3">
              <h3 className="font-bold text-lg font-[Tajawal]" style={{
                color: riskAssessment.level === 'high' ? '#991b1b' : riskAssessment.level === 'moderate' ? '#9a3412' : '#166534',
              }}>
                {riskAssessment.level === 'high' && 'ğŸ”´ Ø­Ù…Ù„ Ø¹Ø§Ù„ÙŠ Ø§Ù„Ø®Ø·ÙˆØ±Ø©'}
                {riskAssessment.level === 'moderate' && 'ğŸŸ¡ Ø­Ù…Ù„ Ù…ØªÙˆØ³Ø· Ø§Ù„Ø®Ø·ÙˆØ±Ø©'}
                {riskAssessment.level === 'low' && 'ğŸŸ¢ Ø­Ù…Ù„ Ù…Ù†Ø®ÙØ¶ Ø§Ù„Ø®Ø·ÙˆØ±Ø©'}
              </h3>
            </div>

            {riskAssessment.riskFactorsList.length > 0 && (
              <div className="mb-3">
                <p className="text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ø®Ø·ÙˆØ±Ø©:</p>
                <ul className="list-disc list-inside space-y-1">
                  {riskAssessment.riskFactorsList.map((factor, idx) => (
                    <li key={idx} className="text-sm text-gray-700 font-[Tajawal]">{factor}</li>
                  ))}
                </ul>
              </div>
            )}

            {riskAssessment.aspirinNeeded && (
              <div className="p-3 bg-white rounded border border-current mb-2">
                <p className="text-sm font-semibold text-gray-900 font-[Tajawal]">
                  ğŸ’Š ÙˆØµÙØ© Ù…ÙˆØµÙ‰ Ø¨Ù‡Ø§: Aspirin 150mg ÙŠÙˆÙ…ÙŠØ§Ù‹ (Ù„ØªÙ‚Ù„ÙŠÙ„ Ø®Ø·Ø± ØªØ³Ù…Ù… Ø§Ù„Ø­Ù…Ù„)
                </p>
              </div>
            )}

            {riskAssessment.thromboprophylaxisNeeded && (
              <div className="p-3 bg-white rounded border border-current">
                <p className="text-sm font-semibold text-gray-900 font-[Tajawal]">
                  ğŸ’‰ ØªÙ†Ø¨ÙŠÙ‡: Ù‚Ø¯ ØªÙƒÙˆÙ† Ø§Ù„ÙˆÙ‚Ø§ÙŠØ© Ù…Ù† Ø§Ù„ØªØ¬Ù„Ø· (Clexane) Ù…Ø·Ù„ÙˆØ¨Ø©
                </p>
              </div>
            )}
          </div>

          <button
            onClick={handleSave}
            disabled={isSaving}
            className="w-full flex items-center justify-center gap-2 bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-[Tajawal] font-semibold transition-colors"
          >
            <Save size={18} />
            {isSaving ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...' : 'Ø­ÙØ¸ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…Ø®Ø§Ø·Ø±'}
          </button>
        </div>
      )}
    </div>
  );
};

export default RiskAssessment;
</file>

<file path="SUPABASE_SETUP.sql">
-- ============================================================================
-- SUPABASE SETUP FOR NILE IVF EMR - Doctor Settings
-- ============================================================================
-- Run this SQL script in Supabase SQL Editor
-- ============================================================================

-- ============================================================================
-- 1. ALTER DOCTORS TABLE - Add new columns for doctor and clinic info
-- ============================================================================

ALTER TABLE IF EXISTS doctors 
ADD COLUMN IF NOT EXISTS doctor_image TEXT DEFAULT NULL,
ADD COLUMN IF NOT EXISTS clinic_name TEXT DEFAULT NULL,
ADD COLUMN IF NOT EXISTS clinic_address TEXT DEFAULT NULL,
ADD COLUMN IF NOT EXISTS clinic_phone TEXT DEFAULT NULL,
ADD COLUMN IF NOT EXISTS clinic_image TEXT DEFAULT NULL,
ADD COLUMN IF NOT EXISTS clinic_latitude TEXT DEFAULT NULL,
ADD COLUMN IF NOT EXISTS clinic_longitude TEXT DEFAULT NULL;

-- ============================================================================
-- 2. CREATE INDEX for better query performance
-- ============================================================================

CREATE INDEX IF NOT EXISTS idx_doctors_user_id ON doctors(user_id);

-- ============================================================================
-- 3. STORAGE POLICIES - These must be run in SQL Editor or via UI
-- ============================================================================

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can upload files to doctor-files" ON storage.objects;
DROP POLICY IF EXISTS "Anyone can read files from doctor-files" ON storage.objects;
DROP POLICY IF EXISTS "Users can update their own files in doctor-files" ON storage.objects;
DROP POLICY IF EXISTS "Users can delete their own files from doctor-files" ON storage.objects;

-- Policy 1: Allow authenticated users to upload files
CREATE POLICY "Users can upload files to doctor-files"
ON storage.objects
FOR INSERT
WITH CHECK (
  bucket_id = 'doctor-files'
  AND auth.role() = 'authenticated'
);

-- Policy 2: Allow anyone to read/view files
CREATE POLICY "Anyone can read files from doctor-files"
ON storage.objects
FOR SELECT
USING (bucket_id = 'doctor-files');

-- Policy 3: Allow users to update their own files
CREATE POLICY "Users can update their own files in doctor-files"
ON storage.objects
FOR UPDATE
USING (
  bucket_id = 'doctor-files'
  AND auth.role() = 'authenticated'
)
WITH CHECK (
  bucket_id = 'doctor-files'
  AND auth.role() = 'authenticated'
);

-- Policy 4: Allow users to delete their own files
CREATE POLICY "Users can delete their own files from doctor-files"
ON storage.objects
FOR DELETE
USING (
  bucket_id = 'doctor-files'
  AND auth.role() = 'authenticated'
);

-- ============================================================================
-- DONE! 
-- ============================================================================
-- Next steps:
-- 1. Make sure the 'doctor-files' bucket exists in Storage
-- 2. If it doesn't exist, create it manually in the Supabase UI:
--    - Go to Storage â†’ New bucket
--    - Name: doctor-files
--    - Access: Public (so images can be viewed by anyone)
-- ============================================================================
</file>

<file path="write_file.py">
import os  
print(os.getcwd())
</file>

<file path="check-db.js">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'https://ladqitwqkkfiijregqlu.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxhZHFpdHdxa2tmaWlqcmVncWx1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4Njk0MDgsImV4cCI6MjA4MDQ0NTQwOH0.qSAjg1kIcAO5DFnz5InlW4u3pxzeDTIbLdB6uN_CEUc';
const supabase = createClient(supabaseUrl, supabaseKey);

async function checkDatabase() {
  try {
    console.log('ğŸ“Š Checking database...\n');

    const tables = ['patients', 'doctors', 'ivf_cycles', 'visits', 'pregnancies'];

    for (const table of tables) {
      try {
        const { data, error, count } = await supabase
          .from(table)
          .select('*', { count: 'exact', head: true });

        if (error) {
          console.log(`âŒ ${table}: ${error.message}`);
        } else {
          console.log(`âœ… ${table}: ${count} records`);
        }
      } catch (err) {
        console.log(`âš ï¸ ${table}: ${err.message}`);
      }
    }

    console.log('\nğŸ” Checking auth...');
    const { data: { session } } = await supabase.auth.getSession();
    if (session) {
      console.log('âœ… User logged in:', session.user.email);
      
      console.log('\nğŸ‘¤ Checking doctor profile...');
      const { data: doctor, error: docError } = await supabase
        .from('doctors')
        .select('*')
        .eq('user_id', session.user.id)
        .single();
      
      if (docError) {
        console.log(`âŒ Doctor profile: ${docError.message}`);
      } else if (doctor) {
        console.log(`âœ… Doctor found:`, doctor.name);
      } else {
        console.log('âš ï¸ No doctor profile found for user');
      }
    } else {
      console.log('âŒ No active session');
    }

    console.log('\nğŸ—„ï¸ Checking table structures...');
    const tables_info = ['information_schema.tables'];
    
  } catch (error) {
    console.error('âŒ Error:', error.message);
  }
}

checkDatabase();
</file>

<file path="components/PrescriptionComponent.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Plus, Trash2, Pill, Printer, ChevronDown } from 'lucide-react';
import { PrescriptionItem } from '../types';
import { EGYPTIAN_MARKET_DRUGS, DrugEntry, searchDrugs, getDrugsByCategory, getAllDrugs } from '../data/egyptian_drugs';

interface PrescriptionComponentProps {
  prescriptions: PrescriptionItem[];
  onPrescriptionsChange: (prescriptions: PrescriptionItem[]) => void;
  onPrint?: () => void;
  showPrintButton?: boolean;
}

const PrescriptionComponent: React.FC<PrescriptionComponentProps> = ({
  prescriptions,
  onPrescriptionsChange,
  onPrint,
  showPrintButton = false
}) => {
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [isDropdownOpen, setIsDropdownOpen] = useState<boolean>(false);
  const [highlightedIndex, setHighlightedIndex] = useState<number>(-1);
  const [customDose, setCustomDose] = useState<string>('');
  const inputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);

  // Get suggestions based on search query
  const getSuggestions = (): DrugEntry[] => {
    if (!searchQuery.trim()) {
      // Show common categories when no search query
      const commonCategories = ['Antibiotics', 'Analgesics', 'Pregnancy Supplements', 'Luteal Support'];
      return commonCategories.flatMap(category => getDrugsByCategory(category).slice(0, 3));
    }
    return searchDrugs(searchQuery);
  };

  const suggestions = getSuggestions();

  // Handle keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!isDropdownOpen) return;

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          setHighlightedIndex(prev =>
            prev < suggestions.length - 1 ? prev + 1 : prev
          );
          break;
        case 'ArrowUp':
          e.preventDefault();
          setHighlightedIndex(prev => prev > 0 ? prev - 1 : -1);
          break;
        case 'Enter':
          e.preventDefault();
          if (highlightedIndex >= 0 && highlightedIndex < suggestions.length) {
            handleSelectDrug(suggestions[highlightedIndex]);
          }
          break;
        case 'Escape':
          setIsDropdownOpen(false);
          setHighlightedIndex(-1);
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isDropdownOpen, highlightedIndex, suggestions]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node) &&
          inputRef.current && !inputRef.current.contains(event.target as Node)) {
        setIsDropdownOpen(false);
        setHighlightedIndex(-1);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleSelectDrug = (drug: DrugEntry) => {
    const dose = customDose || drug.dose;

    const newPrescription: PrescriptionItem = {
      category: drug.category,
      drug: drug.tradeName,
      dose: dose
    };

    onPrescriptionsChange([...prescriptions, newPrescription]);

    // Reset form
    setSearchQuery('');
    setCustomDose('');
    setIsDropdownOpen(false);
    setHighlightedIndex(-1);
  };

  const highlightMatch = (text: string, query: string) => {
    if (!query) return text;
    const regex = new RegExp(`(${query})`, 'gi');
    const parts = text.split(regex);
    return parts.map((part, index) =>
      regex.test(part) ? <mark key={index} className="bg-yellow-200">{part}</mark> : part
    );
  };

  const handleRemoveDrug = (index: number) => {
    const updatedPrescriptions = prescriptions.filter((_, i) => i !== index);
    onPrescriptionsChange(updatedPrescriptions);
  };

  const handleUpdateDose = (index: number, newDose: string) => {
    const updatedPrescriptions = prescriptions.map((prescription, i) =>
      i === index ? { ...prescription, dose: newDose } : prescription
    );
    onPrescriptionsChange(updatedPrescriptions);
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <Pill className="w-5 h-5 text-purple-600" />
          <h3 className="text-lg font-semibold text-gray-900">Prescription</h3>
        </div>
        {showPrintButton && prescriptions.length > 0 && onPrint && (
          <button
            onClick={onPrint}
            className="flex items-center gap-2 px-3 py-1 bg-teal-600 hover:bg-teal-700 text-white rounded-lg text-sm transition-colors"
          >
            <Printer className="w-4 h-4" />
            Print Prescription
          </button>
        )}
      </div>

      {/* Smart Combobox */}
      <div className="relative">
        <div className="relative">
          <input
            ref={inputRef}
            type="text"
            placeholder="Search for medication... (e.g., Augmentin, Paracetamol)"
            value={searchQuery}
            onChange={(e) => {
              setSearchQuery(e.target.value);
              setIsDropdownOpen(true);
              setHighlightedIndex(-1);
            }}
            onFocus={() => setIsDropdownOpen(true)}
            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent pr-10"
          />
          <ChevronDown
            className={`absolute right-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400 transition-transform ${
              isDropdownOpen ? 'rotate-180' : ''
            }`}
          />
        </div>

        {/* Dropdown */}
        {isDropdownOpen && (
          <div
            ref={dropdownRef}
            className="absolute z-50 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-60 overflow-y-auto"
          >
            {suggestions.length > 0 ? (
              suggestions.map((drug, index) => (
                <div
                  key={`${drug.tradeName}-${index}`}
                  onClick={() => handleSelectDrug(drug)}
                  className={`px-4 py-3 cursor-pointer border-b border-gray-100 last:border-b-0 hover:bg-purple-50 ${
                    index === highlightedIndex ? 'bg-purple-100' : ''
                  }`}
                >
                  <div className="font-medium text-gray-900">
                    {highlightMatch(drug.tradeName, searchQuery)}
                  </div>
                  <div className="text-sm text-gray-600">
                    {highlightMatch(drug.active, searchQuery)} ({drug.category})
                  </div>
                  <div className="text-xs text-gray-500 mt-1">
                    {drug.dose}
                  </div>
                </div>
              ))
            ) : searchQuery ? (
              <div className="px-4 py-3 text-gray-500 text-center">
                No medications found for "{searchQuery}"
              </div>
            ) : (
              <div className="px-4 py-3 text-gray-500 text-center">
                Start typing to search medications...
              </div>
            )}
          </div>
        )}
      </div>

      {/* Custom Dose Input (shown when there's a search query) */}
      {searchQuery && (
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Custom Dose (optional - leave empty for standard dose)
          </label>
          <input
            type="text"
            value={customDose}
            onChange={(e) => setCustomDose(e.target.value)}
            placeholder="e.g., 1 tablet twice daily after meals"
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500"
          />
        </div>
      )}

      {/* Current Prescriptions */}
      <div className="space-y-3">
        <h4 className="font-medium text-gray-900">Current Prescriptions</h4>

        {prescriptions.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            <Pill className="w-12 h-12 mx-auto mb-4 text-gray-300" />
            <p>No medications prescribed yet</p>
          </div>
        ) : (
          <div className="space-y-2 max-h-60 overflow-y-auto">
            {prescriptions.map((prescription, index) => (
              <div key={index} className="bg-white border border-gray-200 rounded-lg p-3">
                <div className="flex justify-between items-start">
                  <div className="flex-1">
                    <div className="font-semibold text-gray-900">{prescription.drug}</div>
                    <div className="text-sm text-purple-600 mt-1">{prescription.category}</div>
                    <input
                      type="text"
                      value={prescription.dose}
                      onChange={(e) => handleUpdateDose(index, e.target.value)}
                      className="w-full mt-2 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-1 focus:ring-purple-500"
                      placeholder="Enter dose..."
                    />
                  </div>
                  <button
                    onClick={() => handleRemoveDrug(index)}
                    className="text-red-500 hover:text-red-700 ml-2"
                  >
                    <Trash2 className="w-4 h-4" />
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default PrescriptionComponent;
</file>

<file path="components/PrescriptionPrinter.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { Printer, X } from 'lucide-react';
import { PrescriptionItem, Patient, Doctor } from '../types';
import { authService } from '../services/authService';
import { useBranding } from '../context/BrandingContext';
import toast from 'react-hot-toast';

interface PrescriptionPrinterProps {
  patient: Patient | null;
  prescriptions: PrescriptionItem[];
  diagnosis?: string;
  notes?: string;
  isOpen: boolean;
  onClose: () => void;
}

const PrescriptionPrinter: React.FC<PrescriptionPrinterProps> = ({
  patient,
  prescriptions,
  diagnosis,
  notes,
  isOpen,
  onClose
}) => {
  const { branding } = useBranding();
  const [doctor, setDoctor] = useState<Doctor | null>(null);
  const printRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (isOpen) {
      fetchDoctorInfo();
    }
  }, [isOpen]);

  const fetchDoctorInfo = async () => {
    try {
      const user = await authService.getCurrentUser();
      if (user) {
        const doctorData = await authService.getDoctorProfile(user.id);
        setDoctor(doctorData);
      }
    } catch (error) {
      console.error('Error fetching doctor info:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø¨ÙŠØ¨');
    }
  };

  const handlePrint = () => {
    const printContent = printRef.current;
    if (!printContent) return;

    const printWindow = window.open('', '', 'height=800,width=1000');
    if (!printWindow) {
      toast.error('ÙØ´Ù„ ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©');
      return;
    }

    const styles = `
      <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; padding: 20px; }
        .prescription-container { max-width: 800px; margin: 0 auto; background: white; padding: 40px; border: 1px solid #ddd; }
        .header { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #2d5a6b; padding-bottom: 20px; margin-bottom: 30px; }
        .clinic-info { flex: 1; }
        .clinic-name { font-size: 24px; font-weight: bold; color: #2d5a6b; margin-bottom: 8px; }
        .clinic-details { font-size: 12px; color: #666; line-height: 1.8; }
        .logo-area { flex: 1; text-align: right; color: #2d5a6b; font-weight: bold; font-size: 14px; }
        .patient-doctor-section { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; border-bottom: 1px solid #eee; padding-bottom: 20px; }
        .info-block { }
        .info-label { font-weight: bold; color: #2d5a6b; font-size: 13px; margin-bottom: 5px; }
        .info-value { font-size: 14px; color: #333; }
        .rx-title { font-size: 18px; font-weight: bold; color: #2d5a6b; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 1px; }
        .prescriptions-list { margin-bottom: 30px; }
        .prescription-item { background: #f9f9f9; border: 1px solid #e0e0e0; padding: 12px 15px; margin-bottom: 10px; border-radius: 4px; }
        .prescription-number { display: inline-block; background: #2d5a6b; color: white; width: 28px; height: 28px; border-radius: 50%; text-align: center; line-height: 28px; font-weight: bold; margin-right: 10px; font-size: 12px; }
        .prescription-content { margin-left: 38px; }
        .drug-name { font-weight: bold; font-size: 14px; color: #333; }
        .drug-dose { font-size: 12px; color: #666; margin-top: 3px; }
        .drug-category { font-size: 11px; color: #999; margin-top: 3px; }
        .diagnosis-section, .notes-section { margin-bottom: 25px; padding: 15px; background: #f5f5f5; border-left: 4px solid #2d5a6b; }
        .section-title { font-weight: bold; color: #2d5a6b; margin-bottom: 8px; font-size: 13px; text-transform: uppercase; }
        .section-content { color: #333; font-size: 13px; line-height: 1.6; }
        .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
        .signature-box { }
        .signature-label { font-size: 12px; font-weight: bold; color: #666; margin-top: 40px; border-top: 1px solid #333; padding-top: 5px; text-align: center; }
        .date-time { font-size: 12px; color: #666; margin-top: 15px; text-align: center; }
        @media print {
          body { padding: 0; }
          .prescription-container { border: none; padding: 0; }
        }
      </style>
    `;

    const content = printContent.innerHTML;

    printWindow.document.write(`
      <!DOCTYPE html>
      <html dir="rtl" lang="ar">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Ø±ÙˆØ´ØªØ© Ø·Ø¨ÙŠØ©</title>
          ${styles}
        </head>
        <body>
          ${content}
        </body>
      </html>
    `);

    printWindow.document.close();
    setTimeout(() => {
      printWindow.print();
    }, 250);
  };

  const getCurrentDateTime = () => {
    const now = new Date();
    return {
      date: now.toLocaleDateString('ar-EG', { year: 'numeric', month: 'long', day: 'numeric' }),
      time: now.toLocaleTimeString('ar-EG', { hour: '2-digit', minute: '2-digit' })
    };
  };

  const { date, time } = getCurrentDateTime();

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="sticky top-0 bg-teal-600 text-white px-6 py-4 flex items-center justify-between">
          <h2 className="text-xl font-bold">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø±ÙˆØ´ØªØ© Ø§Ù„Ø·Ø¨ÙŠØ©</h2>
          <button
            onClick={onClose}
            className="hover:bg-teal-700 p-2 rounded-lg transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Content */}
        <div className="p-6">
          <div ref={printRef} className="prescription-container">
            {/* Header */}
            <div className="header">
              <div className="clinic-info">
                <div className="clinic-name">
                  {branding?.clinic_name || 'Ø¹ÙŠØ§Ø¯Ø© Ù…ØªØ®ØµØµØ©'}
                </div>
                <div className="clinic-details">
                  {branding?.clinic_address && <div>{branding.clinic_address}</div>}
                  {branding?.clinic_phone && <div>Øª: {branding.clinic_phone}</div>}
                  {doctor?.email && <div>Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ: {doctor.email}</div>}
                </div>
              </div>
              <div className="logo-area">
                {branding?.logo_url ? (
                  <img src={branding.logo_url} alt="Logo" style={{ maxWidth: '80px', maxHeight: '80px' }} />
                ) : (
                  'â„œ'
                )}
              </div>
            </div>

            {/* Patient & Doctor Info */}
            <div className="patient-doctor-section">
              <div className="info-block">
                <div className="info-label">Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ÙŠØ¶Ø©</div>
                <div className="info-value">{patient?.name || 'N/A'}</div>
                <div className="info-value" style={{ fontSize: '12px', marginTop: '5px', color: '#666' }}>
                  Ø§Ù„Ø¹Ù…Ø±: {patient?.age || 'N/A'} Ø³Ù†Ø©
                </div>
                <div className="info-value" style={{ fontSize: '12px', marginTop: '5px', color: '#666' }}>
                  Ø§Ù„Ù‡Ø§ØªÙ: {patient?.phone || 'N/A'}
                </div>
              </div>
              <div className="info-block">
                <div className="info-label">Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø¨ÙŠØ¨</div>
                <div className="info-value">{doctor?.name || 'N/A'}</div>
                <div className="info-value" style={{ fontSize: '12px', marginTop: '5px', color: '#666' }}>
                  {doctor?.specialization || ''}
                </div>
                <div className="info-value" style={{ fontSize: '12px', marginTop: '5px', color: '#666' }}>
                  {date} - {time}
                </div>
              </div>
            </div>

            {/* Diagnosis */}
            {diagnosis && (
              <div className="diagnosis-section">
                <div className="section-title">Ø§Ù„ØªØ´Ø®ÙŠØµ</div>
                <div className="section-content">{diagnosis}</div>
              </div>
            )}

            {/* Prescriptions */}
            {prescriptions.length > 0 && (
              <>
                <div className="rx-title">Ø§Ù„Ø±ÙˆØ´ØªØ© Ø§Ù„Ø·Ø¨ÙŠØ©</div>
                <div className="prescriptions-list">
                  {prescriptions.map((prescription, index) => (
                    <div key={index} className="prescription-item">
                      <span className="prescription-number">{index + 1}</span>
                      <div className="prescription-content">
                        <div className="drug-name">{prescription.drug}</div>
                        <div className="drug-dose">
                          {prescription.dose || 'Ø§Ù„Ø¬Ø±Ø¹Ø© Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠØ©'}
                        </div>
                        <div className="drug-category">Ø§Ù„ØªØµÙ†ÙŠÙ: {prescription.category}</div>
                      </div>
                    </div>
                  ))}
                </div>
              </>
            )}

            {/* Notes */}
            {notes && (
              <div className="notes-section">
                <div className="section-title">Ù…Ù„Ø§Ø­Ø¸Ø§Øª</div>
                <div className="section-content">{notes}</div>
              </div>
            )}

            {/* Footer */}
            <div className="footer">
              <div className="signature-box">
                <div className="signature-label">ØªÙˆÙ‚ÙŠØ¹ Ø§Ù„Ø·Ø¨ÙŠØ¨</div>
              </div>
              <div className="signature-box">
                <div className="signature-label">ØªÙˆÙ‚ÙŠØ¹ Ø§Ù„Ù…Ø±ÙŠØ¶Ø©</div>
              </div>
            </div>

            {/* System Signature */}
            <div style={{
              marginTop: '30px',
              paddingTop: '15px',
              borderTop: '1px solid #ccc',
              fontSize: '10px',
              color: '#999',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center'
            }}>
              <div>
                {branding?.clinic_address && <div>{branding.clinic_address}</div>}
                {branding?.clinic_phone && <div>Tel: {branding.clinic_phone}</div>}
              </div>
              <div style={{ textAlign: 'right' }}>
                System developed by Dr. Mohamed Salah Gabr
              </div>
            </div>

            {/* Date Time */}
            <div className="date-time">
              ØªÙ… Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©: {date} ÙÙŠ {time}
            </div>
          </div>

          {/* Print Button */}
          <div className="mt-6 flex gap-3 justify-end sticky bottom-0 bg-gray-50 p-4 rounded-b-lg">
            <button
              onClick={onClose}
              className="px-6 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
            >
              Ø¥ØºÙ„Ø§Ù‚
            </button>
            <button
              onClick={handlePrint}
              className="px-6 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700 transition-colors flex items-center gap-2"
            >
              <Printer className="w-4 h-4" />
              Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø±ÙˆØ´ØªØ©
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PrescriptionPrinter;
</file>

<file path="components/RefreshButton.tsx">
import React, { useState } from 'react';
import { RefreshCw } from 'lucide-react';
import { syncManager } from '../src/services/syncService';
import toast from 'react-hot-toast';

interface RefreshButtonProps {
  onRefreshComplete?: () => void;
  showLabel?: boolean;
  size?: 'sm' | 'md' | 'lg';
  variant?: 'primary' | 'secondary';
}

const RefreshButton: React.FC<RefreshButtonProps> = ({
  onRefreshComplete,
  showLabel = true,
  size = 'md',
  variant = 'primary'
}) => {
  const [isRefreshing, setIsRefreshing] = useState(false);

  const handleRefresh = async () => {
    setIsRefreshing(true);
    try {
      await syncManager.forceSync();
      toast.success('Data refreshed successfully');
      onRefreshComplete?.();
    } catch (error) {
      console.error('Failed to refresh data:', error);
      toast.error('Failed to refresh data');
    } finally {
      setIsRefreshing(false);
    }
  };

  const sizeClasses = {
    sm: 'px-2 py-1 text-sm gap-1',
    md: 'px-4 py-2 gap-2',
    lg: 'px-6 py-3 gap-2'
  };

  const iconSizes = {
    sm: 'w-4 h-4',
    md: 'w-5 h-5',
    lg: 'w-6 h-6'
  };

  const variantClasses = {
    primary: 'bg-teal-600 text-white hover:bg-teal-700',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300'
  };

  return (
    <button
      onClick={handleRefresh}
      disabled={isRefreshing}
      className={`flex items-center ${sizeClasses[size]} ${variantClasses[variant]} rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-colors`}
      title="Refresh data from server"
    >
      <RefreshCw className={`${iconSizes[size]} ${isRefreshing ? 'animate-spin' : ''}`} />
      {showLabel && <span className="hidden sm:inline">{isRefreshing ? 'Refreshing...' : 'Refresh'}</span>}
    </button>
  );
};

export default RefreshButton;
</file>

<file path="components/SyncStatus.tsx">
import React, { useState, useEffect } from 'react';
import { Cloud, CloudOff, AlertCircle, RotateCw } from 'lucide-react';
import { syncService } from '../src/services/syncService';
import toast from 'react-hot-toast';

interface SyncStatusState {
  isOnline: boolean;
  syncInProgress: boolean;
  pendingCount: number;
  hasErrors: boolean;
}

const SyncStatus: React.FC = () => {
  const [status, setStatus] = useState<SyncStatusState>({
    isOnline: navigator.onLine,
    syncInProgress: false,
    pendingCount: 0,
    hasErrors: false
  });
  const [showTooltip, setShowTooltip] = useState(false);
  const [isRetrying, setIsRetrying] = useState(false);

  useEffect(() => {
    const updateStatus = () => {
      const syncStatus = syncService.getSyncStatus();
      setStatus(prev => ({
        ...prev,
        isOnline: syncStatus.isOnline,
        syncInProgress: syncStatus.syncInProgress
      }));
    };

    // Check status every 2 seconds
    const interval = setInterval(updateStatus, 2000);
    
    // Listen for network changes
    const handleOnline = () => {
      setStatus(prev => ({ ...prev, isOnline: true }));
      toast.success('ğŸ”„ Connection restored - syncing...');
    };

    const handleOffline = () => {
      setStatus(prev => ({ ...prev, isOnline: false }));
      toast.error('ğŸ“´ Connection lost');
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      clearInterval(interval);
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  const handleRetrySync = async () => {
    setIsRetrying(true);
    try {
      await syncService.forceSync();
      toast.success('âœ… Sync completed');
    } catch (error) {
      toast.error('âŒ Sync failed - check your connection');
    } finally {
      setIsRetrying(false);
    }
  };

  // Determine status color and icon
  const getStatusDisplay = () => {
    if (!status.isOnline) {
      return {
        color: 'text-gray-400',
        bgColor: 'bg-gray-100 hover:bg-gray-200',
        icon: <CloudOff className="w-5 h-5" />,
        label: 'Offline',
        description: 'Waiting for connection...'
      };
    }

    if (status.hasErrors) {
      return {
        color: 'text-red-500',
        bgColor: 'bg-red-100 hover:bg-red-200',
        icon: <AlertCircle className="w-5 h-5" />,
        label: 'Sync Error',
        description: 'Click to retry'
      };
    }

    if (status.syncInProgress || status.pendingCount > 0) {
      return {
        color: 'text-amber-500',
        bgColor: 'bg-amber-100 hover:bg-amber-200',
        icon: (
          <Cloud className={`w-5 h-5 ${status.syncInProgress ? 'animate-pulse' : ''}`} />
        ),
        label: 'Syncing...',
        description: `${status.pendingCount} pending items`
      };
    }

    return {
      color: 'text-green-500',
      bgColor: 'bg-green-100 hover:bg-green-200',
      icon: <Cloud className="w-5 h-5" />,
      label: 'All Synced',
      description: 'Everything is up to date'
    };
  };

  const display = getStatusDisplay();
  const isError = status.hasErrors;

  return (
    <div className="relative">
      <button
        onClick={() => {
          setShowTooltip(!showTooltip);
          if (isError) handleRetrySync();
        }}
        disabled={isRetrying}
        className={`${display.bgColor} ${display.color} p-2 rounded-full transition-all duration-200 relative group cursor-pointer disabled:opacity-50`}
        title={display.label}
      >
        {isRetrying ? (
          <RotateCw className="w-5 h-5 animate-spin" />
        ) : (
          display.icon
        )}
      </button>

      {/* Tooltip */}
      {showTooltip && (
        <div className="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg p-3 z-50 border border-gray-200">
          <div className="text-sm font-semibold text-gray-900 mb-1">
            {display.label}
          </div>
          <div className="text-xs text-gray-600 mb-2">
            {display.description}
          </div>
          
          {/* Status indicators */}
          <div className="space-y-1 text-xs">
            <div className="flex items-center gap-2">
              <span className={`w-2 h-2 rounded-full ${status.isOnline ? 'bg-green-500' : 'bg-gray-400'}`}></span>
              <span className="text-gray-700">
                {status.isOnline ? 'Online' : 'Offline'}
              </span>
            </div>
            <div className="flex items-center gap-2">
              <span className={`w-2 h-2 rounded-full ${status.syncInProgress ? 'bg-amber-500 animate-pulse' : 'bg-green-500'}`}></span>
              <span className="text-gray-700">
                {status.syncInProgress ? 'Syncing' : 'Idle'}
              </span>
            </div>
          </div>

          {/* Retry button */}
          {isError && (
            <button
              onClick={handleRetrySync}
              disabled={isRetrying}
              className="mt-3 w-full bg-blue-500 hover:bg-blue-600 disabled:opacity-50 text-white text-xs font-medium py-1 rounded transition-colors"
            >
              {isRetrying ? 'Retrying...' : 'Retry Sync'}
            </button>
          )}
        </div>
      )}
    </div>
  );
};

export default SyncStatus;
</file>

<file path="components/ui/SearchableSelect.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { ChevronDown, X } from 'lucide-react';

interface SearchableSelectProps {
  options: string[];
  value: string | string[];
  onChange: (value: string | string[]) => void;
  placeholder?: string;
  label?: string;
  multi?: boolean;
  allowCustom?: boolean;
  disabled?: boolean;
  className?: string;
}

const SearchableSelect: React.FC<SearchableSelectProps> = ({
  options,
  value,
  onChange,
  placeholder = 'Search or type...',
  label,
  multi = false,
  allowCustom = true,
  disabled = false,
  className = '',
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [highlightedIndex, setHighlightedIndex] = useState(0);
  const inputRef = useRef<HTMLInputElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const selectedArray = Array.isArray(value) ? value : value ? [value] : [];
  const normalizedOptions = options.map(opt => opt.toLowerCase());
  const searchLower = searchQuery.toLowerCase();

  const filteredOptions = options.filter(opt =>
    opt.toLowerCase().includes(searchLower)
  );

  const showAddCustom = allowCustom && searchQuery.trim() && !filteredOptions.some(opt => opt.toLowerCase() === searchLower);

  const displayOptions = filteredOptions.length > 0 ? filteredOptions : (showAddCustom ? [] : options);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (!isOpen && e.key === 'ArrowDown') {
      e.preventDefault();
      setIsOpen(true);
      return;
    }

    if (!isOpen) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setHighlightedIndex(prev => (prev + 1) % (displayOptions.length + (showAddCustom ? 1 : 0)));
        break;
      case 'ArrowUp':
        e.preventDefault();
        setHighlightedIndex(prev => (prev - 1 + (displayOptions.length + (showAddCustom ? 1 : 0))) % (displayOptions.length + (showAddCustom ? 1 : 0)));
        break;
      case 'Enter':
        e.preventDefault();
        if (highlightedIndex < displayOptions.length) {
          handleSelect(displayOptions[highlightedIndex]);
        } else if (showAddCustom) {
          handleSelect(searchQuery.trim());
        }
        break;
      case 'Escape':
        e.preventDefault();
        setIsOpen(false);
        break;
    }
  };

  const handleSelect = (selectedValue: string) => {
    if (multi) {
      if (selectedArray.includes(selectedValue)) {
        onChange(selectedArray.filter(v => v !== selectedValue));
      } else {
        onChange([...selectedArray, selectedValue]);
      }
      setSearchQuery('');
      setHighlightedIndex(0);
    } else {
      onChange(selectedValue);
      setSearchQuery('');
      setIsOpen(false);
      setHighlightedIndex(0);
    }
  };

  const handleRemoveTag = (removedValue: string) => {
    if (multi) {
      onChange(selectedArray.filter(v => v !== removedValue));
    }
  };

  return (
    <div ref={containerRef} className={`relative w-full ${className}`}>
      {label && (
        <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
          {label}
        </label>
      )}

      <div className="relative">
        <div className="flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg bg-white focus-within:ring-2 focus-within:ring-teal-500 focus-within:border-transparent transition-all">
          <div className="flex flex-wrap gap-2 flex-1">
            {multi && selectedArray.length > 0 ? (
              selectedArray.map(item => (
                <div key={item} className="bg-teal-100 text-teal-700 px-3 py-1 rounded-full flex items-center gap-2 text-sm font-[Tajawal]">
                  {item}
                  <button
                    type="button"
                    onClick={() => handleRemoveTag(item)}
                    className="hover:text-teal-900"
                  >
                    <X size={14} />
                  </button>
                </div>
              ))
            ) : null}
            <input
              ref={inputRef}
              type="text"
              value={searchQuery}
              onChange={(e) => {
                setSearchQuery(e.target.value);
                setIsOpen(true);
                setHighlightedIndex(0);
              }}
              onFocus={() => setIsOpen(true)}
              onKeyDown={handleKeyDown}
              placeholder={selectedArray.length === 0 ? placeholder : ''}
              disabled={disabled}
              className="flex-1 min-w-32 outline-none bg-transparent font-[Tajawal]"
            />
          </div>
          <ChevronDown
            size={18}
            className={`text-gray-400 transition-transform ${isOpen ? 'transform rotate-180' : ''}`}
          />
        </div>

        {isOpen && (
          <div className="absolute top-full left-0 right-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg z-50 max-h-64 overflow-y-auto">
            {displayOptions.length > 0 ? (
              displayOptions.map((option, index) => (
                <button
                  key={option}
                  type="button"
                  onClick={() => handleSelect(option)}
                  className={`w-full text-left px-4 py-2.5 transition-colors font-[Tajawal] ${
                    highlightedIndex === index ? 'bg-teal-50' : ''
                  } ${
                    selectedArray.includes(option) ? 'bg-teal-100 text-teal-700 font-semibold' : 'hover:bg-gray-50'
                  }`}
                >
                  {option}
                </button>
              ))
            ) : null}

            {showAddCustom && (
              <button
                type="button"
                onClick={() => handleSelect(searchQuery.trim())}
                className={`w-full text-left px-4 py-2.5 transition-colors font-[Tajawal] border-t border-gray-200 text-teal-600 hover:bg-teal-50 ${
                  highlightedIndex === displayOptions.length ? 'bg-teal-50' : ''
                }`}
              >
                â• Ø¥Ø¶Ø§ÙØ©: "{searchQuery.trim()}"
              </button>
            )}

            {displayOptions.length === 0 && !showAddCustom && (
              <div className="px-4 py-8 text-center text-gray-500 font-[Tajawal]">
                Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬
              </div>
            )}
          </div>
        )}
      </div>

      {!multi && value && selectedArray.length > 0 && (
        <div className="mt-2 text-xs text-gray-500 font-[Tajawal]">
          ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ¯: <span className="font-semibold text-gray-700">{selectedArray[0]}</span>
        </div>
      )}
    </div>
  );
};

export default SearchableSelect;
</file>

<file path="data/medical_terms.ts">
export const COMMON_COMPLAINTS = [
  'Abdominal Pain',
  'Vaginal Discharge',
  'Infertility',
  'Amenorrhea',
  'Dysmenorrhea',
  'Post-coital Bleeding',
  'Vaginal Bleeding',
  'Irregular Periods',
  'Pelvic Pain',
  'Heavy Menstrual Bleeding',
  'Painful Intercourse',
  'Vulvar Itching',
  'Vaginal Dryness',
  'Hot Flushes',
  'Night Sweats',
  'Breast Pain',
  'Breast Discharge',
  'Urinary Incontinence',
  'Urinary Frequency',
  'Urinary Urgency',
  'Pelvic Pressure',
  'Lower Back Pain',
  'Pelvic Mass',
  'Infertility - Primary',
  'Infertility - Secondary',
  'Delayed Puberty',
  'Abnormal Uterine Bleeding',
  'Anovulation',
  'Oligomenorrhea',
  'Polymenorrhea',
  'Metrorrhagia',
  'Menorrhagia',
  'Postmenopausal Bleeding',
  'Intermenstrual Bleeding',
  'Pelvic Inflammatory Disease',
  'Recurrent Pregnancy Loss',
];

export const ICD10_DIAGNOSES = [
  'N93.9 - Abnormal Uterine Bleeding (AUB), unspecified',
  'N80 - Endometriosis',
  'N80.0 - Endometriosis of uterus',
  'N80.1 - Endometriosis of ovary',
  'N80.3 - Endometriosis of pelvic peritoneum',
  'E28.2 - Polycystic Ovarian Syndrome (PCOS)',
  'E28.3 - Primary Ovarian Failure',
  'N73 - Pelvic Inflammatory Disease (PID)',
  'N73.0 - Acute Parametritis and Pelvic Cellulitis',
  'N73.1 - Chronic Parametritis and Pelvic Cellulitis',
  'N73.2 - Unspecified Parametritis and Pelvic Cellulitis',
  'N73.3 - Female Acute Pelvitis',
  'N73.4 - Female Chronic Pelvitis',
  'N73.5 - Female Pelvitis, unspecified',
  'N73.9 - Female Pelvic Inflammatory Disease, unspecified',
  'O20.0 - Threatened Abortion',
  'O03.9 - Unspecified Abortion',
  'O04.9 - Abortion, unspecified',
  'O06.9 - Unspecified Miscarriage',
  'N91.2 - Amenorrhea, unspecified',
  'N91.1 - Primary Amenorrhea',
  'N91.0 - Primary and Secondary Amenorrhea',
  'N92.0 - Excessive and Frequent Menstruation with Regular Cycle',
  'N92.1 - Excessive and Frequent Menstruation with Irregular Cycle',
  'N92.2 - Excessive Menstruation at Puberty',
  'N92.3 - Ovulation Bleeding',
  'N92.4 - Excessive Bleeding in the Premenopausal Period',
  'N95.0 - Postmenopausal Bleeding',
  'N81.1 - Cystocele',
  'N81.2 - Incomplete Uterovaginal Prolapse',
  'N81.3 - Complete Uterovaginal Prolapse',
  'N81.4 - Uterine Prolapse, unspecified',
  'N81.5 - Vaginal Enterocele',
  'N82 - Fistula Involving Female Genital Tract',
  'N84 - Polyp of Female Genital Tract',
  'N84.0 - Polyp of Corpus Uteri',
  'N84.1 - Polyp of Cervix',
  'N84.2 - Polyp of Vagina',
  'N84.3 - Polyp of Vulva',
  'N85.0 - Adenomatous Hyperplasia of Endometrium',
  'N85.2 - Hypertrophy of Uterus',
  'N86 - Erosion and Ectropion of Cervix Uteri',
  'N87.0 - Mild Cervical Dysplasia (CIN I)',
  'N87.1 - Moderate Cervical Dysplasia (CIN II)',
  'N87.2 - Severe Cervical Dysplasia (CIN III)',
  'C53.9 - Malignant Neoplasm of Cervix Uteri, unspecified',
  'D25.9 - Leiomyoma of Uterus, unspecified',
  'D25.0 - Submucosal Leiomyoma of Uterus',
  'D25.1 - Intramural Leiomyoma of Uterus',
  'D25.2 - Subserosal Leiomyoma of Uterus',
  'N35.9 - Urethral Stricture, unspecified',
  'N39.3 - Urge Incontinence',
  'N39.4 - Other Specified Urinary Incontinence',
  'N39.45 - Unspecified Urinary Incontinence',
  'N76 - Inflammation of Vagina and Vulva',
  'N76.0 - Acute Vaginitis',
  'N76.1 - Subacute and Chronic Vaginitis',
  'N76.2 - Acute Vulvitis',
  'N76.3 - Subacute and Chronic Vulvitis',
  'N77.0 - Abscess of Vulva',
  'N77.1 - Ulceration of Vulva',
  'B37.3 - Candidiasis of Vulva and Vagina',
  'A59.0 - Trichomoniasis of Genitourinary Tract',
  'A56.0 - Chlamydial Infection of Lower Genitourinary Tract',
  'A54.0 - Gonococcal Infection of Lower Genitourinary Tract',
  'N90.6 - Vulvar Cyst',
  'N90.7 - Vulvar Cyst, unspecified',
  'N90.8 - Hypertrophy of Clitoris',
  'N90.89 - Other Specified Noninflammatory Disorders of Vulva and Perineum',
  'N89.9 - Noninflammatory Disorder of Vagina, unspecified',
  'Z12.4 - Encounter for Screening for Malignant Neoplasm of Cervix',
  'N39.0 - Urinary Tract Infection, Site Not Specified',
];

export const PROCEDURE_ORDERS = [
  'Pap Smear (Cervical Cytology)',
  'HPV Testing',
  'Transvaginal Ultrasound',
  'Transabdominal Ultrasound',
  'Pelvic Ultrasound',
  'Hysterosalpingography (HSG)',
  'Hysteroscopy',
  'Laparoscopy',
  'Colposcopy',
  'Endometrial Biopsy',
  'Cervical Biopsy',
  'Vulval Biopsy',
  'Culdocentesis',
  'Dilation & Curettage (D&C)',
  'Myomectomy',
  'Hysterectomy',
  'Tubal Ligation',
  'IUD Insertion',
  'Contraceptive Implant Insertion',
  'Endometrial Ablation',
  'Cone Biopsy (LEEP)',
  'Cauterization of Cervix',
  'Polypectomy',
  'Cyst Aspiration',
  'Diagnostic Laparoscopy',
  'Therapeutic Laparoscopy',
  'Egg Retrieval (OPU)',
  'Embryo Transfer',
  'Intrauterine Insemination (IUI)',
  'Semen Analysis',
  'Follicle Tracking Ultrasound',
  'Progesterone Level Test',
  'Pelvic MRI',
  'CT Pelvis',
  'Sonohysterography',
  'Saline Infusion Sonography (SIS)',
  'Anti-Sperm Antibody Test',
  'Postcoital Test',
];

export const PELVIC_EXAM_FINDINGS = [
  'Normal',
  'Cervical Friability',
  'Cervical Discharge',
  'Cervical Polyp',
  'Cervical Erosion',
  'Cervical Stenosis',
  'Cervical Laceration',
  'Vaginal Atrophy',
  'Vaginal Tear',
  'Vaginal Stenosis',
  'Vaginal Ulcer',
  'Vulvar Lesion',
  'Vulvar Ulcer',
  'Vulvar Edema',
  'Enlarged Clitoris',
  'Bartholin Cyst',
  'Abnormal Uterine Position',
  'Uterine Tenderness',
  'Uterine Fibroids',
  'Adnexal Mass',
  'Ovarian Tenderness',
  'Adnexal Tenderness',
  'Rebound Tenderness',
  'Guarding',
  'Cul-de-sac Fullness',
  'Normal External Genitalia',
  'Vaginal Discharge - Clear',
  'Vaginal Discharge - White',
  'Vaginal Discharge - Yellow',
  'Vaginal Discharge - Purulent',
  'Vaginal Discharge - Bloody',
];

export const ULTRASOUND_FINDINGS = [
  'Normal',
  'Endometrial Thickening',
  'Endometrial Thinning',
  'Endometrial Hyperplasia',
  'Endometrial Polyp',
  'Endometrial Cancer',
  'Myomatous Uterus',
  'Submucosal Fibroid',
  'Intramural Fibroid',
  'Subserosal Fibroid',
  'Simple Ovarian Cyst',
  'Complex Ovarian Cyst',
  'Hemorrhagic Cyst',
  'Ovarian Mass',
  'Ovarian Torsion',
  'Free Fluid in Pelvis',
  'Ascites',
  'Hydrosalpinx',
  'Pyosalpinx',
  'Tubal Blockage',
  'Gestational Sac',
  'Yolk Sac',
  'Fetal Heart Rate Present',
  'Ectopic Pregnancy',
  'Intrauterine Device Visible',
  'Adenomyosis',
  'Uterine Septum',
  'Bicornuate Uterus',
  'Unicornuate Uterus',
  'Absent Uterus',
];

export const TREATMENT_PLANS = [
  'Watchful Waiting',
  'Symptomatic Treatment',
  'Hormonal Contraception',
  'Nonsteroidal Anti-inflammatory Drugs (NSAIDs)',
  'Antibiotics',
  'Antifungals',
  'Antiparasitics',
  'Hormone Replacement Therapy (HRT)',
  'Progestin Therapy',
  'Gonadotropin-releasing Hormone (GnRH) Agonists',
  'Danazol',
  'Fertility Treatment',
  'Assisted Reproductive Technology (ART)',
  'Intrauterine Insemination (IUI)',
  'In Vitro Fertilization (IVF)',
  'Surgical Intervention',
  'Myomectomy',
  'Hysterectomy',
  'Dilation & Curettage (D&C)',
  'Hysteroscopic Ablation',
  'Laparoscopic Surgery',
  'Vaginal Delivery',
  'Cesarean Section',
  'Counseling',
  'Lifestyle Modification',
  'Weight Loss',
  'Smoking Cessation',
  'Physical Therapy',
  'Pelvic Floor Exercises',
];
</file>

<file path="DATABASE_MIGRATION.md">
# Database Migration Guide - Dexie to PowerSync

## âœ… What Was Done

### 1. Removed Old Database Files
- âŒ Deleted `src/db/localDB.ts` (Dexie database)
- âŒ Deleted `src/lib/localDb.ts` (Dexie database)
- âœ… Created `src/lib/powerSyncHelpers.ts` (PowerSync utilities)

### 2. Removed Dependencies
- âŒ Removed `dexie-react-hooks` from `package.json`

### 3. PowerSync Helpers Created
New file: `src/lib/powerSyncHelpers.ts` provides:
- **Hooks**: `usePatients()`, `useVisits()`, `useIVFCycles()`, etc.
- **Database operations**: `db.patients.add()`, `db.visits.add()`, etc.

## ğŸ”„ Migration Steps for Each File

### Files That Need Updates:
1. `pages/IvfJourney.tsx`
2. `pages/Reception.tsx`
3. `pages/PatientMasterRecord.tsx`
4. `pages/ObstetricsDashboard.tsx`
5. `pages/Gynecology.tsx`
6. `pages/Dashboard.tsx`
7. `services/visitsService.ts`
8. `components/SyncStatus.tsx`

### Migration Pattern:

**Before (Dexie):**
```typescript
import { useLiveQuery } from 'dexie-react-hooks';
import { db as dexieDB } from '../src/db/localDB';

const patients = useLiveQuery(() => dexieDB.patients.toArray(), []) || [];
```

**After (PowerSync):**
```typescript
import { usePatients } from '../src/lib/powerSyncHelpers';

const { data: patients = [] } = usePatients();
```

## ğŸ“ Next Steps

Run `npm install` to update dependencies, then update each file to use PowerSync helpers.
</file>

<file path="debug-sync.js">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'https://ladqitwqkkfiijregqlu.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxhZHFpdHdxa2tmaWlqcmVncWx1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4Njk0MDgsImV4cCI6MjA4MDQ0NTQwOH0.qSAjg1kIcAO5DFnz5InlW4u3pxzeDTIbLdB6uN_CEUc';
const supabase = createClient(supabaseUrl, supabaseKey);

async function debug() {
  try {
    console.log('ğŸ” DEBUGGING DATA SYNC\n');

    console.log('0ï¸âƒ£ Checking current user...');
    const { data: { user } } = await supabase.auth.getUser();
    console.log(`Current user: ${user?.email || 'No user logged in'}`);

    console.log('\n1ï¸âƒ£ Checking doctors...');
    const { data: doctors, error: docError } = await supabase.from('doctors').select('*');
    if (docError) console.error('Error:', docError.message);
    console.log(`Found ${doctors?.length || 0} doctors`);
    if (doctors && doctors.length > 0) {
      doctors.forEach(d => {
        console.log(`- ${d.name} (user_id: ${d.user_id})`);
      });
    }

    console.log('\n2ï¸âƒ£ Checking patients...');
    const { data: patients, error: patError } = await supabase.from('patients').select('*');
    if (patError) console.error('Error:', patError.message);
    console.log(`Found ${patients?.length || 0} patients`);
    if (patients && patients.length > 0) {
      patients.forEach(p => {
        console.log(`- ${p.name} (doctor_id: ${p.doctor_id})`);
      });
    }

    console.log('\n3ï¸âƒ£ Checking IVF cycles...');
    const { data: cycles, error: cycError } = await supabase.from('ivf_cycles').select('*');
    if (cycError) console.error('Error:', cycError.message);
    console.log(`Found ${cycles?.length || 0} cycles`);

    console.log('\n4ï¸âƒ£ Checking visits...');
    const { data: visits, error: visError } = await supabase.from('visits').select('*');
    if (visError) console.error('Error:', visError.message);
    console.log(`Found ${visits?.length || 0} visits`);

  } catch (error) {
    console.error('âŒ Error:', error.message);
  }
}

debug();
</file>

<file path="DEPLOYMENT_QUICK_START.md">
# Deployment Quick Start Guide

## Current Status
- âœ… Database schema prepared (POWERSYNC_SCHEMA_SETUP.sql)
- âœ… Service layer with error handling (dbService.ts)
- âœ… AppSchema updated for PowerSync (optional, offline mode)

---

## Option 1: Quick Deploy (Recommended - Supabase Direct)

### Step 1: Apply Database Schema
1. Go to **Supabase Dashboard â†’ SQL Editor**
2. Click **New Query**
3. Copy entire content of `POWERSYNC_SCHEMA_SETUP.sql`
4. Paste and run
5. Verify all 10 tables created with RLS enabled

**Expected output:**
```
doctors          true
patients         true
visits           true
ivf_cycles       true
stimulation_logs true
pregnancies      true
antenatal_visits true
biometry_scans   true
patient_files    true
app_settings     true
```

### Step 2: Update Application Code

**Replace ivfService imports** in your components:

```typescript
// OLD
import { db } from '../services/ivfService';

// NEW
import { dbService as db } from '../services/dbService';
```

**Or create alias in ivfService.ts:**

```typescript
export { dbService as db } from './dbService';
```

### Step 3: Build & Deploy
```bash
npm run build
npm run preview  # Test locally
# Then deploy to hosting
```

---

## Option 2: With PowerSync (Advanced - Offline First)

### Prerequisites
- PowerSync account at https://powersync.journeyapps.com
- PowerSync URL from dashboard

### Step 1-3: Same as Option 1

### Step 4: Configure PowerSync Sync Rules
1. Go to **PowerSync Dashboard â†’ Settings â†’ Sync Rules**
2. Copy rules from `src/powersync/SyncRules.ts`
3. Configure each bucket rule:

```yaml
bucket_definitions:
  doctors:
    table: doctors
    rule: 'auth.uid() = user_id'
  
  patients:
    table: patients
    rule: 'doctor_id in (select id from doctors where user_id = auth.uid())'
  
  # ... add rest from SyncRules.ts
```

### Step 5: Build with PowerSync
```bash
npm run build
```

**Note:** PowerSync is optional. App works fine with Supabase direct (Option 1).

---

## Verification Checklist

### Database
- [ ] All 10 tables exist
- [ ] RLS enabled on all tables
- [ ] Publication "powersync" created (if using PowerSync)
- [ ] Sample data inserts without errors

### Application
- [ ] Build completes without errors
- [ ] Can login with doctor credentials
- [ ] Can create patient
- [ ] Can create IVF cycle
- [ ] Can add stimulation logs
- [ ] Can save assessments
- [ ] Can update cycle data

### (Optional) PowerSync
- [ ] Sync rules configured
- [ ] Data syncs offline/online
- [ ] Conflicts resolve correctly

---

## Troubleshooting

### Tables Not Created?
```sql
-- Check tables
SELECT tablename FROM pg_tables 
WHERE schemaname = 'public' 
ORDER BY tablename;

-- Check RLS
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public';
```

### "Doctor not found" Error?
```sql
-- Verify doctor record exists
SELECT * FROM doctors WHERE user_id = 'your-user-id';

-- Insert if missing (replace with real UUID)
INSERT INTO doctors (user_id, email, name) 
VALUES ('your-user-id', 'doctor@example.com', 'Dr. Name');
```

### Data Not Saving?
1. Check browser console (F12) for detailed errors
2. Verify doctor_id exists: `SELECT * FROM doctors;`
3. Check Supabase logs: Dashboard â†’ Logs

### Build Errors?
```bash
# Clear cache
rm -rf node_modules package-lock.json
npm install
npm run build
```

---

## File Changes Summary

### New Files Created:
- `services/dbService.ts` - Direct Supabase database layer
- `src/powersync/SyncRules.ts` - PowerSync configuration
- `POWERSYNC_SCHEMA_SETUP.sql` - Complete database schema

### Modified Files:
- `src/powersync/AppSchema.ts` - Fixed column definitions
- `services/ivfService.ts` - Enhanced error handling
- `src/powersync/SupabaseConnector.ts` - Retry logic

---

## Database Structure

```
doctors (1)
  â”œâ”€â”€ patients (N)
  â”‚   â”œâ”€â”€ visits (N)
  â”‚   â”œâ”€â”€ patient_files (N)
  â”‚   â””â”€â”€ ivf_cycles (N)
  â”‚       â””â”€â”€ stimulation_logs (N)
  â”œâ”€â”€ pregnancies (N)
  â”‚   â”œâ”€â”€ antenatal_visits (N)
  â”‚   â””â”€â”€ biometry_scans (N)
  â””â”€â”€ app_settings (shared)
```

Each doctor sees only their own data via RLS policies.

---

## Performance Tips

1. **Indexes**: All created automatically
2. **JSONB**: Use for flexible data (assessment_data, lab_data, etc.)
3. **Batch Operations**: Use for multiple inserts/updates
4. **Connection Pool**: Handled by Supabase

---

## Support

- Supabase Docs: https://supabase.com/docs
- PowerSync Docs: https://powersync.journeyapps.com/docs
- Check Supabase Dashboard Logs for errors

---

## Next Steps

1. âœ… Run POWERSYNC_SCHEMA_SETUP.sql in Supabase
2. âœ… Update imports to use dbService
3. âœ… Build and test locally
4. âœ… Deploy to production
5. (Optional) Add PowerSync for offline support
</file>

<file path="ENV_SETUP.md">
# Ø¥Ø¹Ø¯Ø§Ø¯ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©

## Ù…Ù„Ù .env

Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù `.env` ÙÙŠ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„Ù…Ø´Ø±ÙˆØ¹ ÙˆØ£Ø¶Ù Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:

```env
# Supabase Configuration
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key-here

# PowerSync Configuration
VITE_POWERSYNC_URL=https://6938cd7948645822f36663c8.powersync.journeyapps.com
```

## ÙƒÙŠÙÙŠØ© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ…:

### Supabase:
1. Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ [Supabase Dashboard](https://app.supabase.com)
2. Ø§Ø®ØªØ± Ù…Ø´Ø±ÙˆØ¹Ùƒ
3. Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ **Settings** > **API**
4. Ø§Ù†Ø³Ø®:
   - **Project URL** â†’ `VITE_SUPABASE_URL`
   - **anon public key** â†’ `VITE_SUPABASE_ANON_KEY`

### PowerSync:
1. Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ [PowerSync Dashboard](https://app.powersync.com)
2. Ø§Ø®ØªØ± instance Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
3. Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ **Settings** > **Instance URL**
4. Ø§Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· â†’ `VITE_POWERSYNC_URL`

## Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù‡Ù…Ø©:

- âš ï¸ **Ù„Ø§ ØªØ±ÙØ¹ Ù…Ù„Ù `.env` Ø¥Ù„Ù‰ Git** - ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­Ø³Ø§Ø³Ø©
- âœ… Ø¨Ø¹Ø¯ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ØªØºÙŠØ±Ø§ØªØŒ **Ø£Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø³ÙŠØ±ÙØ± Ø§Ù„ØªØ·ÙˆÙŠØ±** (`npm run dev`)
- âœ… ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ÙÙŠ **Settings > Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„**
</file>

<file path="INFERTILITY_WORKUPS_SETUP.sql">
-- ============================================================================
-- INFERTILITY WORKUPS MODULE SETUP - Supabase SQL
-- ============================================================================
-- This script creates the infertility_workups table for infertility assessment
-- ============================================================================

-- 1. CREATE INFERTILITY_WORKUPS TABLE
CREATE TABLE IF NOT EXISTS infertility_workups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- 2. ADD MISSING COLUMNS
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS amh DECIMAL(5, 2);
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS cycle_regularity TEXT CHECK (cycle_regularity IN ('Regular', 'Irregular'));
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS sperm_count INTEGER;
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS motility INTEGER;
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS morphology INTEGER;
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS left_tube TEXT CHECK (left_tube IN ('Patent', 'Blocked', 'Hydrosalpinx'));
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS right_tube TEXT CHECK (right_tube IN ('Patent', 'Blocked', 'Hydrosalpinx'));
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS cavity_status TEXT CHECK (cavity_status IN ('Normal', 'Septum', 'Polyp', 'Adhesions'));
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS diagnosis TEXT;
ALTER TABLE infertility_workups ADD COLUMN IF NOT EXISTS plan TEXT;

-- 2. CREATE INDEXES FOR PERFORMANCE
CREATE INDEX IF NOT EXISTS idx_infertility_workups_patient_id ON infertility_workups(patient_id);

-- 3. ENABLE RLS
ALTER TABLE infertility_workups ENABLE ROW LEVEL SECURITY;

-- 4. DROP EXISTING POLICIES
DROP POLICY IF EXISTS "Doctors can read their infertility workups" ON infertility_workups;
DROP POLICY IF EXISTS "Doctors can insert infertility workups" ON infertility_workups;
DROP POLICY IF EXISTS "Doctors can update infertility workups" ON infertility_workups;

-- 5. RLS POLICIES FOR INFERTILITY_WORKUPS
CREATE POLICY "Doctors can read their infertility workups" ON infertility_workups
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients WHERE doctor_id = auth.uid()
    )
  );

CREATE POLICY "Doctors can insert infertility workups" ON infertility_workups
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients WHERE doctor_id = auth.uid()
    )
  );

CREATE POLICY "Doctors can update infertility workups" ON infertility_workups
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients WHERE doctor_id = auth.uid()
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients WHERE doctor_id = auth.uid()
    )
  );

-- 6. ADD TABLE COMMENTS
COMMENT ON TABLE infertility_workups IS 'Stores infertility assessment data including ovarian, male, tubal, and uterine factors';
COMMENT ON COLUMN infertility_workups.amh IS 'Anti-Mullerian Hormone level';
COMMENT ON COLUMN infertility_workups.cycle_regularity IS 'Menstrual cycle regularity';
COMMENT ON COLUMN infertility_workups.sperm_count IS 'Sperm count in millions';
COMMENT ON COLUMN infertility_workups.motility IS 'Sperm motility percentage';
COMMENT ON COLUMN infertility_workups.morphology IS 'Sperm morphology percentage';
COMMENT ON COLUMN infertility_workups.left_tube IS 'Left fallopian tube status';
COMMENT ON COLUMN infertility_workups.right_tube IS 'Right fallopian tube status';
COMMENT ON COLUMN infertility_workups.cavity_status IS 'Uterine cavity status';
COMMENT ON COLUMN infertility_workups.diagnosis IS 'Auto-generated diagnosis based on factors';
COMMENT ON COLUMN infertility_workups.plan IS 'Auto-generated treatment plan';
</file>

<file path="MIGRATION_ADD_RX_NOTES.sql">
-- Add default_rx_notes column to app_settings table
ALTER TABLE app_settings ADD COLUMN IF NOT EXISTS default_rx_notes TEXT;
</file>

<file path="pages/ClinicalStation.tsx">
import React, { useState, useEffect } from 'react';
import { db, calculateBMI, analyzeSemenAnalysis } from '../services/ivfService';
import { EGYPTIAN_DRUGS } from '../constants';
import { PrescriptionItem, Patient } from '../types';
import { AlertTriangle, Plus, Trash2, Printer, FileText, Activity, Microscope, Info } from 'lucide-react';
import RefreshButton from '../components/RefreshButton';

interface FemaleFactor {
  // Hormones
  fsh: string;
  lh: string;
  e2: string;
  prolactin: string;
  tsh: string;
  amh: string;
  // Ultrasound
  endoThickness: string;
  afcR: string;
  afcL: string;
  uterusPathology: string[];
  ovaryPathology: string[];
  // Tubes & Scope
  tubalStatus: string;
  hydrosalpinx: boolean;
  hysteroscopy: string[];
  laparoscopy: string[];
}

const ClinicalStation: React.FC = () => {
  const [patients, setPatients] = useState<Patient[]>([]);
  const [selectedPatientId, setSelectedPatientId] = useState('');
  
  // Vitals & Male
  const [vitals, setVitals] = useState({ weight: '', height: '' });
  const [maleParams, setMaleParams] = useState({ vol: 0, conc: 0, mot: 0, morph: 0 });
  
  // Female Workup State
  const [activeFemaleTab, setActiveFemaleTab] = useState<'hormones' | 'us' | 'scope'>('hormones');
  const [femaleData, setFemaleData] = useState<FemaleFactor>({
    fsh: '', lh: '', e2: '', prolactin: '', tsh: '', amh: '',
    endoThickness: '', afcR: '', afcL: '',
    uterusPathology: [], ovaryPathology: [],
    tubalStatus: 'Patent', hydrosalpinx: false,
    hysteroscopy: [], laparoscopy: []
  });

  // Rx State
  const [rxItems, setRxItems] = useState<PrescriptionItem[]>([]);
  const [drugCategory, setDrugCategory] = useState('');
  const [selectedDrug, setSelectedDrug] = useState('');

  // Initial Fetch
  useEffect(() => {
    db.getPatients().then(setPatients);
  }, []);

  const selectedPatient = patients.find(p => p.id === selectedPatientId);

  // Computed Values
  const bmiInfo = calculateBMI(Number(vitals.weight), Number(vitals.height));
  const spermDiagnosis = analyzeSemenAnalysis(maleParams.vol, maleParams.conc, maleParams.mot, maleParams.morph);

  // --- Female Logic Engine ---
  const getFemaleDiagnosis = () => {
    const findings: string[] = [];
    const fsh = Number(femaleData.fsh);
    const lh = Number(femaleData.lh);
    const e2 = Number(femaleData.e2);
    const prl = Number(femaleData.prolactin);
    const tsh = Number(femaleData.tsh);
    const amh = Number(femaleData.amh);
    const et = Number(femaleData.endoThickness);
    const afcTotal = Number(femaleData.afcR) + Number(femaleData.afcL);

    // Hormones
    if (fsh > 10) findings.push("Diminished Ovarian Reserve (FSH > 10)");
    if (fsh > 0 && lh / fsh > 2) findings.push("Suspect PCOS (LH/FSH ratio > 2)");
    if (e2 > 80) findings.push("Functional Cyst / Poor Responder Risk (High E2)");
    if (prl > 25) findings.push(prl > 100 ? "Hyperprolactinemia (Check MRI)" : "Hyperprolactinemia");
    if (tsh > 2.5) findings.push("Subclinical Hypothyroidism (Treat for Fertility)");
    if (femaleData.amh && amh < 1.0) findings.push("Low Ovarian Reserve (Poseidon Group)");
    if (amh > 3.5) findings.push("High Reserve (PCOS Risk)");

    // Ultrasound
    if (femaleData.endoThickness && et < 7) findings.push("Thin Endometrium (< 7mm)");
    if ((femaleData.afcR || femaleData.afcL) && afcTotal < 5) findings.push("Low AFC (< 5 Total)");
    if (femaleData.uterusPathology.length > 0) findings.push(`Uterus: ${femaleData.uterusPathology.join(', ')}`);
    if (femaleData.ovaryPathology.length > 0) findings.push(`Ovary: ${femaleData.ovaryPathology.join(', ')}`);

    // Tubes
    if (femaleData.hydrosalpinx) findings.push("CRITICAL: Hydrosalpinx (Clip/Remove before IVF)");
    if (femaleData.tubalStatus !== 'Patent') findings.push(`Tubes: ${femaleData.tubalStatus}`);
    
    // Scopes
    if (femaleData.laparoscopy.includes('Endometriosis')) findings.push("Endometriosis Confirmed");

    return findings;
  };

  const femaleFindings = getFemaleDiagnosis();

  // Handlers
  const handleAddDrug = () => {
    if (!drugCategory || !selectedDrug) return;
    // @ts-ignore
    const drugInfo = EGYPTIAN_DRUGS[drugCategory][selectedDrug];
    const dose = drugInfo ? drugInfo.dose : '';
    setRxItems([...rxItems, { category: drugCategory, drug: selectedDrug, dose }]);
    setSelectedDrug('');
  };

  const removeDrug = (idx: number) => {
    setRxItems(rxItems.filter((_, i) => i !== idx));
  };

  const handlePrint = () => {
    if (!selectedPatient || rxItems.length === 0) return;
    setTimeout(() => {
      window.print();
    }, 100);
  };

  const toggleCheckbox = (field: keyof FemaleFactor, value: string) => {
    const list = femaleData[field] as string[];
    const newList = list.includes(value) 
      ? list.filter(item => item !== value)
      : [...list, value];
    setFemaleData({ ...femaleData, [field]: newList });
  };

  return (
    <div className="space-y-6">
      {/* Header with Refresh */}
      <div className="flex items-center justify-between">
        <h1 className="text-4xl font-bold text-gray-900">Clinical Station</h1>
        <RefreshButton />
      </div>

      {/* Patient Selector */}
      <div className="bg-white p-3 md:p-6 rounded-2xl shadow-sm border border-gray-100 no-print">
        <label className="block text-xs md:text-sm font-bold text-gray-700 mb-2">Select Patient</label>
        <select 
          className="w-full px-3 md:px-4 py-2 md:py-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-teal-500 outline-none bg-white text-sm"
          value={selectedPatientId}
          onChange={(e) => setSelectedPatientId(e.target.value)}
        >
          <option value="">-- Choose from Directory --</option>
          {patients.map(p => (
            <option key={p.id} value={p.id}>{p.name} (Husband: {p.husbandName})</option>
          ))}
        </select>
      </div>

      {selectedPatient && (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-12 gap-3 md:gap-6 no-print">
            
            {/* LEFT COLUMN: Vitals + Male (3 cols on desktop, 1 col on md) */}
            <div className="md:col-span-1 lg:col-span-3 space-y-6">
              {/* BMI Calculator */}
              <div className="bg-white p-3 md:p-5 rounded-2xl shadow-sm border border-gray-100">
                <h3 className="text-sm md:text-base font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <Activity className="w-4 h-4 text-teal-600" /> Vitals & BMI
                </h3>
                <div className="space-y-3">
                  <div className="flex gap-2">
                     <div className="flex-1">
                        <label className="text-xs text-gray-500">Weight (kg)</label>
                        <input type="number" className="w-full p-3 md:p-2 border rounded text-sm min-h-[48px]" value={vitals.weight} onChange={e => setVitals({...vitals, weight: e.target.value})} />
                     </div>
                     <div className="flex-1">
                        <label className="text-xs text-gray-500">Height (cm)</label>
                        <input type="number" className="w-full p-3 md:p-2 border rounded text-sm min-h-[48px]" value={vitals.height} onChange={e => setVitals({...vitals, height: e.target.value})} />
                     </div>
                  </div>
                  {bmiInfo.bmi > 0 && (
                    <div className={`p-2 rounded text-xs flex items-center gap-2 ${bmiInfo.alert ? 'bg-red-50 text-red-700' : 'bg-green-50 text-green-700'}`}>
                      {bmiInfo.alert ? <AlertTriangle className="w-4 h-4" /> : <div className="w-4 h-4 rounded-full border-2 border-green-600" />}
                      <span className="font-bold">{bmiInfo.bmi} {bmiInfo.alert && "(Obese)"}</span>
                    </div>
                  )}
                </div>
              </div>

              {/* Male Diagnosis */}
              <div className="bg-white p-3 md:p-5 rounded-2xl shadow-sm border border-gray-100">
                <h3 className="text-sm md:text-base font-bold text-gray-800 mb-3 flex items-center gap-2">
                   <Microscope className="w-4 h-4 text-blue-600" /> Male Factor
                </h3>
                <div className="space-y-3 text-sm">
                  <div>
                    <label className="text-xs text-gray-500">Volume (ml)</label>
                    <input type="number" placeholder="> 1.5" className="w-full p-3 md:p-2 border rounded min-h-[48px]" onChange={e => setMaleParams({...maleParams, vol: parseFloat(e.target.value)})} />
                  </div>
                  <div>
                    <label className="text-xs text-gray-500">Conc (M/ml)</label>
                    <input type="number" placeholder="> 15" className="w-full p-3 md:p-2 border rounded min-h-[48px]" onChange={e => setMaleParams({...maleParams, conc: parseFloat(e.target.value)})} />
                  </div>
                  <div>
                    <label className="text-xs text-gray-500">Motility (%)</label>
                    <input type="number" placeholder="> 40" className="w-full p-3 md:p-2 border rounded min-h-[48px]" onChange={e => setMaleParams({...maleParams, mot: parseFloat(e.target.value)})} />
                  </div>
                  <div>
                    <label className="text-xs text-gray-500">Morphology (%)</label>
                    <input type="number" placeholder="> 4" className="w-full p-3 md:p-2 border rounded min-h-[48px]" onChange={e => setMaleParams({...maleParams, morph: parseFloat(e.target.value)})} />
                  </div>
                </div>
                <div className="mt-3 p-2 bg-blue-50 rounded text-xs font-bold text-blue-800 border border-blue-100">
                  {spermDiagnosis}
                </div>
              </div>
            </div>

            {/* MIDDLE COLUMN: Female Workup (6 cols on desktop, 1 col on md) */}
            <div className="md:col-span-1 lg:col-span-5 flex flex-col gap-6">
              <div className="bg-white rounded-2xl shadow-sm border border-gray-100 flex-1 overflow-hidden flex flex-col">
                <div className="border-b border-gray-100">
                  <nav className="flex -mb-px">
                    <button
                      onClick={() => setActiveFemaleTab('hormones')}
                      className={`flex-1 py-4 text-center text-sm font-medium border-b-2 transition-colors ${activeFemaleTab === 'hormones' ? 'border-pink-500 text-pink-600 bg-pink-50' : 'border-transparent text-gray-500 hover:text-gray-700'}`}
                    >
                      Ø§Ù„Ù‡Ø±Ù…ÙˆÙ†Ø§Øª (Hormones)
                    </button>
                    <button
                      onClick={() => setActiveFemaleTab('us')}
                      className={`flex-1 py-4 text-center text-sm font-medium border-b-2 transition-colors ${activeFemaleTab === 'us' ? 'border-pink-500 text-pink-600 bg-pink-50' : 'border-transparent text-gray-500 hover:text-gray-700'}`}
                    >
                      Ø§Ù„Ø³ÙˆÙ†Ø§Ø± (Ultrasound)
                    </button>
                    <button
                      onClick={() => setActiveFemaleTab('scope')}
                      className={`flex-1 py-4 text-center text-sm font-medium border-b-2 transition-colors ${activeFemaleTab === 'scope' ? 'border-pink-500 text-pink-600 bg-pink-50' : 'border-transparent text-gray-500 hover:text-gray-700'}`}
                    >
                      Ø§Ù„Ù…Ù†Ø§Ø¸ÙŠØ± (Endoscopy)
                    </button>
                  </nav>
                </div>

                <div className="p-6 flex-1 overflow-y-auto">
                  
                  {/* TAB 1: HORMONES */}
                  {activeFemaleTab === 'hormones' && (
                    <div className="grid grid-cols-2 gap-4">
                      <div className="col-span-2 text-xs text-gray-400 mb-2 font-bold">Day 2-3 Profile</div>
                      
                      <div className="relative">
                        <label className="block text-xs font-medium text-gray-700 mb-1">FSH (IU/L)</label>
                        <input type="number" className={`w-full p-2 border rounded-lg ${Number(femaleData.fsh) > 10 ? 'border-red-300 bg-red-50' : ''}`} 
                          value={femaleData.fsh} onChange={e => setFemaleData({...femaleData, fsh: e.target.value})} />
                        {Number(femaleData.fsh) > 10 && <span className="text-[10px] text-red-600 absolute bottom-[-16px] right-0">Diminished Reserve</span>}
                      </div>

                      <div className="relative">
                        <label className="block text-xs font-medium text-gray-700 mb-1">LH (IU/L)</label>
                        <input type="number" className="w-full p-2 border rounded-lg" 
                          value={femaleData.lh} onChange={e => setFemaleData({...femaleData, lh: e.target.value})} />
                      </div>

                      <div className="relative">
                        <label className="block text-xs font-medium text-gray-700 mb-1">E2 (pg/mL)</label>
                        <input type="number" className={`w-full p-2 border rounded-lg ${Number(femaleData.e2) > 80 ? 'border-yellow-300 bg-yellow-50' : ''}`}
                          value={femaleData.e2} onChange={e => setFemaleData({...femaleData, e2: e.target.value})} />
                      </div>

                      <div className="relative">
                        <label className="block text-xs font-medium text-gray-700 mb-1">Prolactin (ng/mL)</label>
                        <input type="number" className={`w-full p-2 border rounded-lg ${Number(femaleData.prolactin) > 25 ? 'border-red-300 bg-red-50' : ''}`}
                          value={femaleData.prolactin} onChange={e => setFemaleData({...femaleData, prolactin: e.target.value})} />
                      </div>

                      <div className="relative">
                        <label className="block text-xs font-medium text-gray-700 mb-1">TSH (mIU/L)</label>
                        <input type="number" className={`w-full p-2 border rounded-lg ${Number(femaleData.tsh) > 2.5 ? 'border-yellow-300 bg-yellow-50' : ''}`}
                          value={femaleData.tsh} onChange={e => setFemaleData({...femaleData, tsh: e.target.value})} />
                      </div>

                      <div className="relative">
                        <label className="block text-xs font-medium text-gray-700 mb-1">AMH (ng/mL)</label>
                        <input type="number" className={`w-full p-2 border rounded-lg ${Number(femaleData.amh) < 1 ? 'border-red-300 bg-red-50' : Number(femaleData.amh) > 3.5 ? 'border-blue-300 bg-blue-50' : ''}`}
                          value={femaleData.amh} onChange={e => setFemaleData({...femaleData, amh: e.target.value})} />
                      </div>
                    </div>
                  )}

                  {/* TAB 2: ULTRASOUND */}
                  {activeFemaleTab === 'us' && (
                    <div className="space-y-4">
                      <div className="grid grid-cols-3 gap-4">
                        <div>
                          <label className="block text-xs font-medium text-gray-700 mb-1">Ø¨Ø·Ø§Ù†Ø© Ø§Ù„Ø±Ø­Ù… (mm)</label>
                          <input type="number" className={`w-full p-2 border rounded-lg ${Number(femaleData.endoThickness) > 0 && Number(femaleData.endoThickness) < 7 ? 'border-red-300 bg-red-50' : ''}`}
                            value={femaleData.endoThickness} onChange={e => setFemaleData({...femaleData, endoThickness: e.target.value})} />
                        </div>
                        <div>
                          <label className="block text-xs font-medium text-gray-700 mb-1">AFC Right</label>
                          <input type="number" className="w-full p-2 border rounded-lg"
                            value={femaleData.afcR} onChange={e => setFemaleData({...femaleData, afcR: e.target.value})} />
                        </div>
                        <div>
                          <label className="block text-xs font-medium text-gray-700 mb-1">AFC Left</label>
                          <input type="number" className="w-full p-2 border rounded-lg"
                            value={femaleData.afcL} onChange={e => setFemaleData({...femaleData, afcL: e.target.value})} />
                        </div>
                      </div>

                      <div>
                        <h4 className="text-xs font-bold text-gray-500 mb-2 uppercase">Uterus Pathology (Ø§Ù„Ø±Ø­Ù…)</h4>
                        <div className="flex flex-wrap gap-2">
                          {['Fibroids', 'Polyps', 'Adenomyosis', 'Septum'].map(item => (
                            <button
                              key={item}
                              onClick={() => toggleCheckbox('uterusPathology', item)}
                              className={`px-3 py-1 text-xs rounded-full border transition-colors ${femaleData.uterusPathology.includes(item) ? 'bg-pink-600 text-white border-pink-600' : 'bg-gray-50 text-gray-600 border-gray-200'}`}
                            >
                              {item}
                            </button>
                          ))}
                        </div>
                      </div>

                      <div>
                        <h4 className="text-xs font-bold text-gray-500 mb-2 uppercase">Ovary Pathology (Ø§Ù„Ù…Ø¨ÙŠØ¶)</h4>
                        <div className="flex flex-wrap gap-2">
                          {['Simple Cyst', 'Endometrioma', 'Dermoid', 'PCO Pattern'].map(item => (
                            <button
                              key={item}
                              onClick={() => toggleCheckbox('ovaryPathology', item)}
                              className={`px-3 py-1 text-xs rounded-full border transition-colors ${femaleData.ovaryPathology.includes(item) ? 'bg-pink-600 text-white border-pink-600' : 'bg-gray-50 text-gray-600 border-gray-200'}`}
                            >
                              {item}
                            </button>
                          ))}
                        </div>
                      </div>
                    </div>
                  )}

                  {/* TAB 3: SCOPES & TUBES */}
                  {activeFemaleTab === 'scope' && (
                    <div className="space-y-6">
                      
                      <div className="bg-gray-50 p-3 rounded-lg border border-gray-200">
                        <label className="block text-xs font-bold text-gray-700 mb-2">Tubal Patency (HSG/HyCoSy)</label>
                        <select 
                          className="w-full p-2 border rounded-lg mb-3"
                          value={femaleData.tubalStatus}
                          onChange={e => setFemaleData({...femaleData, tubalStatus: e.target.value})}
                        >
                          <option value="Patent">Patent Bilaterally (Ø³Ù„ÙŠÙ…Ø©)</option>
                          <option value="Right Blocked">Right Blocked (Ø§Ù†Ø³Ø¯Ø§Ø¯ ÙŠÙ…ÙŠÙ†)</option>
                          <option value="Left Blocked">Left Blocked (Ø§Ù†Ø³Ø¯Ø§Ø¯ ÙŠØ³Ø§Ø±)</option>
                          <option value="Bilateral Block">Bilateral Block (Ø§Ù†Ø³Ø¯Ø§Ø¯ ÙƒÙ„ÙŠ)</option>
                        </select>
                        
                        <label className="flex items-center gap-3 p-3 bg-white border border-red-100 rounded-lg cursor-pointer hover:bg-red-50 transition-colors">
                          <input 
                            type="checkbox" 
                            checked={femaleData.hydrosalpinx} 
                            onChange={e => setFemaleData({...femaleData, hydrosalpinx: e.target.checked})} 
                            className="w-5 h-5 text-red-600 rounded focus:ring-red-500" 
                          />
                          <div>
                            <span className="font-bold text-red-800 block text-sm">Hydrosalpinx Detected</span>
                            <span className="text-xs text-red-600">Ø§Ø±ØªØ´Ø§Ø­ Ø¨Ù‚Ù†Ø§Ø© ÙØ§Ù„ÙˆØ¨ (Must remove before IVF)</span>
                          </div>
                        </label>
                      </div>

                      <div>
                        <h4 className="text-xs font-bold text-gray-500 mb-2">Hysteroscopy Findings</h4>
                        <div className="flex flex-wrap gap-2">
                          {['Normal Cavity', 'Adhesions', 'Polypectomy', 'Septum Resection'].map(item => (
                            <button
                              key={item}
                              onClick={() => toggleCheckbox('hysteroscopy', item)}
                              className={`px-3 py-1 text-xs rounded-full border transition-colors ${femaleData.hysteroscopy.includes(item) ? 'bg-purple-600 text-white border-purple-600' : 'bg-gray-50 text-gray-600 border-gray-200'}`}
                            >
                              {item}
                            </button>
                          ))}
                        </div>
                      </div>

                      <div>
                        <h4 className="text-xs font-bold text-gray-500 mb-2">Laparoscopy Findings</h4>
                        <div className="flex flex-wrap gap-2">
                          {['Normal', 'Endometriosis I-II', 'Endometriosis III-IV', 'Adhesions'].map(item => (
                            <button
                              key={item}
                              onClick={() => toggleCheckbox('laparoscopy', item)}
                              className={`px-3 py-1 text-xs rounded-full border transition-colors ${femaleData.laparoscopy.includes(item) ? 'bg-purple-600 text-white border-purple-600' : 'bg-gray-50 text-gray-600 border-gray-200'}`}
                            >
                              {item}
                            </button>
                          ))}
                        </div>
                      </div>

                    </div>
                  )}

                </div>
                
                {/* Summary / Diagnosis Box */}
                <div className="bg-pink-50 p-4 border-t border-pink-100 min-h-[100px]">
                  <h4 className="text-xs font-bold text-pink-800 uppercase mb-2 flex items-center gap-2">
                    <Info className="w-4 h-4" /> Diagnosis & Findings
                  </h4>
                  {femaleFindings.length > 0 ? (
                    <ul className="list-disc list-inside space-y-1">
                      {femaleFindings.map((finding, i) => (
                        <li key={i} className="text-sm text-pink-900 font-medium">
                          {finding}
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <p className="text-xs text-pink-400 italic">Enter data to generate diagnosis...</p>
                  )}
                </div>
              </div>
            </div>

            {/* RIGHT COLUMN: Smart Rx (4 cols on desktop, 2 cols on md, 1 col on mobile) */}
            <div className="md:col-span-1 lg:col-span-4 bg-white p-3 md:p-5 rounded-2xl shadow-sm border border-gray-100 flex flex-col">
              <h3 className="text-sm md:text-base font-bold text-gray-800 mb-4 flex items-center gap-2">
                <FileText className="w-4 h-4 text-teal-600" /> Smart Prescription
              </h3>
              
              <div className="space-y-3 mb-4">
                <div>
                  <label className="text-xs font-medium text-gray-600">Category</label>
                  <select 
                    className="w-full p-2 border rounded-lg mt-1 text-sm"
                    value={drugCategory}
                    onChange={e => { setDrugCategory(e.target.value); setSelectedDrug(''); }}
                  >
                    <option value="">Select Category</option>
                    {Object.keys(EGYPTIAN_DRUGS).map(cat => <option key={cat} value={cat}>{cat}</option>)}
                  </select>
                </div>
                
                <div>
                  <label className="text-xs font-medium text-gray-600">Medication</label>
                  <select 
                    className="w-full p-2 border rounded-lg mt-1 text-sm"
                    value={selectedDrug}
                    onChange={e => setSelectedDrug(e.target.value)}
                    disabled={!drugCategory}
                  >
                    <option value="">Select Drug</option>
                    {drugCategory && Object.keys((EGYPTIAN_DRUGS as any)[drugCategory]).map(d => (
                      <option key={d} value={d}>{d}</option>
                    ))}
                  </select>
                </div>

                <button 
                  onClick={handleAddDrug}
                  disabled={!selectedDrug}
                  className="w-full bg-teal-600 text-white py-2 rounded-lg font-bold hover:bg-teal-700 disabled:bg-gray-300 transition-colors flex items-center justify-center gap-2 text-sm"
                >
                  <Plus className="w-4 h-4" /> Add
                </button>
              </div>

              <div className="flex-1 border border-gray-100 rounded-lg p-3 bg-gray-50 overflow-y-auto max-h-[300px]">
                {rxItems.length === 0 ? (
                  <p className="text-center text-gray-400 text-xs mt-10">No items added</p>
                ) : (
                  <ul className="space-y-2">
                    {rxItems.map((item, idx) => (
                      <li key={idx} className="bg-white p-2 rounded shadow-sm flex justify-between items-start">
                        <div>
                          <div className="font-bold text-gray-800 text-sm">{item.drug}</div>
                          <div className="text-xs text-teal-600 font-mono mt-0.5">{item.dose}</div>
                        </div>
                        <button onClick={() => removeDrug(idx)} className="text-red-400 hover:text-red-600">
                          <Trash2 className="w-3 h-3" />
                        </button>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
              
              <div className="mt-4 pt-3 border-t border-gray-100">
                 <button 
                  onClick={handlePrint}
                  disabled={rxItems.length === 0}
                  className="w-full bg-gray-800 text-white py-2.5 rounded-xl font-bold hover:bg-gray-900 transition-colors flex items-center justify-center gap-2 text-sm"
                >
                  <Printer className="w-4 h-4" /> Print (A4)
                </button>
              </div>
            </div>
          </div>

          {/* PRINT VIEW - Hidden until print */}
          <div className="print-only w-full bg-white p-8" style={{ direction: 'rtl' }}>
            <div className="border-b-2 border-teal-700 pb-6 mb-8">
              <div className="flex flex-row-reverse justify-between items-end mb-4">
                <div className="text-right">
                  <h1 className="text-3xl font-bold text-teal-800">Ù…Ø±ÙƒØ² Ù†ÙŠÙ„ Ù„Ù„Ø¹Ù‚Ù…</h1>
                  <p className="text-gray-600 mt-2 text-sm">Nile IVF Center</p>
                </div>
                <div className="text-left text-sm text-gray-600">
                  <p>Ø§Ù„ØªØ§Ø±ÙŠØ®: {new Date().toLocaleDateString('ar-EG')}</p>
                  <p>Ø§Ø³Ù… Ø§Ù„Ù…Ø±ÙŠØ¶Ø©: <strong>{selectedPatient?.name}</strong></p>
                </div>
              </div>
            </div>

            <div className="mb-8">
              <h2 className="text-center text-2xl font-bold text-gray-800 mb-6">Ø§Ù„Ø±ÙˆØ´ØªØ© Ø§Ù„Ø·Ø¨ÙŠØ©</h2>
              <h3 className="text-4xl font-serif text-teal-700 text-center mb-8">R/</h3>
              
              <div className="space-y-4">
                {rxItems.map((item, idx) => (
                  <div key={idx} className="border-b border-gray-300 pb-3 flex flex-row-reverse justify-between items-start">
                    <div className="text-right flex-1">
                      <div className="font-bold text-lg text-gray-800">{item.drug}</div>
                      <div className="text-sm text-teal-700 font-medium mt-1">{item.dose}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="border-t border-gray-300 pt-6 mt-12 text-center text-xs text-gray-500">
              <p>Nile IVF Center - Cairo, Egypt</p>
              <p className="mt-1">+20 123 456 7890</p>
            </div>
          </div>
        </>
      )}
    </div>
  );
};

export default ClinicalStation;
</file>

<file path="pages/components/obstetrics/PregnancyHeader.tsx">
import React from 'react';
import { Calendar, AlertCircle, CheckCircle, Baby } from 'lucide-react';
import { Pregnancy } from '../../../types';
import { calculateGestationalAge, getDueActions } from '../../../services/obstetricsService';
import toast from 'react-hot-toast';

interface PregnancyHeaderProps {
  pregnancy: Pregnancy;
}

const PregnancyHeader: React.FC<PregnancyHeaderProps> = ({ pregnancy }) => {
  const lmpDate = pregnancy.lmp_date;
  const ga = lmpDate ? calculateGestationalAge(lmpDate) : { weeks: 0, days: 0 };
  const dueActions = getDueActions(ga.weeks);

  const progressPercentage = ((ga.weeks * 7 + ga.days) / 280) * 100;

  // Determine pregnancy status based on gestational age
  const getPregnancyStatus = (weeks: number) => {
    if (weeks < 37) {
      return {
        status: 'Pre-term',
        color: 'blue',
        arabicText: 'Ø­Ù…Ù„ Ù…Ø¨ÙƒØ±',
        bgColor: 'bg-blue-100',
        textColor: 'text-blue-800',
        borderColor: 'border-blue-200'
      };
    } else if (weeks >= 37 && weeks < 40) {
      return {
        status: 'Full Term',
        color: 'green',
        arabicText: 'ÙØªØ±Ø© ÙˆÙ„Ø§Ø¯Ø© Ø·Ø¨ÙŠØ¹ÙŠØ©',
        bgColor: 'bg-green-100',
        textColor: 'text-green-800',
        borderColor: 'border-green-200'
      };
    } else if (weeks >= 40 && weeks < 42) {
      return {
        status: 'Late Term / Overdue',
        color: 'orange',
        arabicText: 'ØªØ®Ø·Øª Ø§Ù„Ù…ÙˆØ¹Ø¯',
        bgColor: 'bg-orange-100',
        textColor: 'text-orange-800',
        borderColor: 'border-orange-200'
      };
    } else {
      return {
        status: 'Post Term',
        color: 'red',
        arabicText: 'Ø­Ù…Ù„ Ù…ØªØ£Ø®Ø± Ø¹Ù† Ø§Ù„Ù…ÙˆØ¹Ø¯ - Ø®Ø·Ø±',
        bgColor: 'bg-red-100',
        textColor: 'text-red-800',
        borderColor: 'border-red-200'
      };
    }
  };

  const pregnancyStatus = getPregnancyStatus(ga.weeks);
  const isOverdue = ga.weeks >= 40;

  const handleDeliveryCheck = () => {
    toast.success('ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¹Ù† Ø§Ù„ÙˆÙ„Ø§Ø¯Ø© - ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙ„Ø§Ø¯Ø© ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…');
    // TODO: Navigate to delivery outcome form or archive the pregnancy
  };

  return (
    <div className="bg-gradient-to-r from-teal-50 to-cyan-50 rounded-lg p-6 mb-6 border border-teal-200">
      {/* Status Badge */}
      <div className="flex justify-between items-start mb-4">
        <div></div>
        <div className={`px-4 py-2 rounded-full text-sm font-bold ${pregnancyStatus.bgColor} ${pregnancyStatus.textColor} border ${pregnancyStatus.borderColor} font-[Tajawal]`}>
          {pregnancyStatus.arabicText}
        </div>
      </div>

      <div className="grid md:grid-cols-3 gap-6">
        <div>
          <h2 className="text-sm text-gray-600 font-semibold mb-2 font-[Tajawal]">
            Ø§Ù„Ø­Ù…Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ
          </h2>
          <p className="text-4xl font-bold text-teal-700 font-[Tajawal]">
            {ga.weeks}
            <span className="text-xl text-gray-500 ml-2">Ø£Ø³Ø¨ÙˆØ¹</span>
            <span className="text-lg text-gray-400 ml-1">+ {ga.days}</span>
          </p>
          <p className="text-xs text-gray-500 mt-2 font-[Tajawal]">
            Ø¢Ø®Ø± Ø¯ÙˆØ±Ø©: {lmpDate ? new Date(lmpDate).toLocaleDateString('ar-EG') : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}
          </p>
        </div>

        <div>
          <h3 className="text-sm text-gray-600 font-semibold mb-3 font-[Tajawal]">
            ØªÙ‚Ø¯Ù… Ø§Ù„Ø­Ù…Ù„
          </h3>
          <div className="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
            <div
              className={`h-full rounded-full transition-all duration-500 ${
                isOverdue
                  ? 'bg-gradient-to-r from-red-500 to-red-600'
                  : 'bg-gradient-to-r from-teal-500 to-cyan-500'
              }`}
              style={{ width: `${Math.min(progressPercentage, 100)}%` }}
            ></div>
          </div>
          <p className="text-xs text-gray-600 mt-2 font-[Tajawal]">
            {progressPercentage.toFixed(0)}% Ù…Ù† 40 Ø£Ø³Ø¨ÙˆØ¹
            {isOverdue && (
              <span className="text-red-600 font-bold ml-2">
                (Ù…ØªØ£Ø®Ø± Ø¹Ù† Ø§Ù„Ù…ÙˆØ¹Ø¯)
              </span>
            )}
          </p>
        </div>

        <div>
          <h3 className="text-sm text-gray-600 font-semibold mb-2 font-[Tajawal]">
            ØªØ§Ø±ÙŠØ® Ø§Ù„ÙˆÙ„Ø§Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹
          </h3>
          <p className="text-xl font-bold text-teal-700 font-[Tajawal]">
            {pregnancy.edd_date
              ? new Date(pregnancy.edd_date).toLocaleDateString('ar-EG')
              : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}
          </p>
          <p className="text-xs text-gray-500 mt-2 font-[Tajawal]">
            {ga.weeks < 40 && `Ø¨Ø§Ù‚ÙŠ ${40 - ga.weeks} Ø£Ø³Ø§Ø¨ÙŠØ¹`}
            {ga.weeks >= 40 && 'â° Ø§Ù„ÙˆÙ„Ø§Ø¯Ø© Ù…ØªÙˆÙ‚Ø¹Ø©!'}
          </p>
        </div>
      </div>

      {dueActions.length > 0 && (
        <div className="mt-6 pt-6 border-t border-teal-200">
          <h3 className="text-sm font-semibold text-teal-900 mb-3 flex items-center gap-2 font-[Tajawal]">
            <AlertCircle size={18} className="text-orange-500" />
            Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù…Ø³ØªØ­Ù‚Ø©
          </h3>
          <div className="grid md:grid-cols-2 gap-2">
            {dueActions.map((action, idx) => (
              <div
                key={idx}
                className="flex items-center gap-2 bg-white px-3 py-2 rounded-lg border border-orange-200"
              >
                <AlertCircle size={16} className="text-orange-500 flex-shrink-0" />
                <span className="text-sm text-gray-700 font-[Tajawal]">{action}</span>
              </div>
            ))}
          </div>
        </div>
      )}

      {pregnancy.risk_level === 'high' && (
        <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg">
          <div className="flex items-start gap-3">
            <AlertCircle className="text-red-600 flex-shrink-0 mt-0.5" size={18} />
            <div className="font-[Tajawal]">
              <p className="font-semibold text-red-900">âš ï¸ Ø­Ù…Ù„ Ø¹Ø§Ù„ÙŠ Ø§Ù„Ø®Ø·ÙˆØ±Ø©</p>
              <p className="text-sm text-red-700 mt-1">
                Ø§Ù„Ø±Ù‚Ø§Ø¨Ø© Ø§Ù„Ù…ØªÙ‚Ø§Ø±Ø¨Ø© ÙˆØ§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ù…ØªØ®ØµØµØ© Ù…Ø·Ù„ÙˆØ¨Ø©
              </p>
              {pregnancy.aspirin_prescribed && (
                <p className="text-sm text-red-600 mt-1">
                  âœ“ Aspirin 150mg Ù…ÙˆØµÙˆÙ Ù„Ù„ÙˆÙ‚Ø§ÙŠØ© Ù…Ù† ØªØ³Ù…Ù… Ø§Ù„Ø­Ù…Ù„
                </p>
              )}
            </div>
          </div>
        </div>
      )}

      {pregnancy.risk_level === 'low' && (
        <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg flex items-center gap-3">
          <CheckCircle className="text-green-600" size={20} />
          <p className="text-sm text-green-800 font-[Tajawal] font-semibold">
            âœ“ Ø­Ù…Ù„ Ù…Ù†Ø®ÙØ¶ Ø§Ù„Ø®Ø·ÙˆØ±Ø© - Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø±ÙˆØªÙŠÙ†ÙŠØ© Ø§Ù„Ù…Ø¹ØªØ§Ø¯Ø©
          </p>
        </div>
      )}

      {/* Did She Deliver? Prompt for overdue pregnancies */}
      {isOverdue && (
        <div className="mt-6 p-4 bg-red-50 border-2 border-red-300 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Baby className="text-red-600" size={24} />
              <div>
                <h4 className="text-lg font-bold text-red-900 font-[Tajawal]">
                  ğŸ‘¶ Ù‡Ù„ ØªÙ…Øª Ø§Ù„ÙˆÙ„Ø§Ø¯Ø©ØŸ
                </h4>
                <p className="text-sm text-red-700 font-[Tajawal]">
                  ØªØ³Ø¬ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙ„Ø§Ø¯Ø© ÙˆØ¥Ù†Ù‡Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø­Ù…Ù„
                </p>
              </div>
            </div>
            <button
              onClick={handleDeliveryCheck}
              className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-semibold transition-colors duration-200 font-[Tajawal] flex items-center gap-2"
            >
              <Baby size={16} />
              ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ÙˆÙ„Ø§Ø¯Ø©
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default PregnancyHeader;
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="POWERSYNC_SCHEMA_SETUP.sql">
-- ============================================================================
-- COMPREHENSIVE POWERSYNC SCHEMA SETUP
-- ============================================================================
-- Run this in Supabase SQL Editor to set up complete schema for PowerSync sync
-- Includes all tables, indexes, RLS policies, and publication configuration
-- ============================================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ============================================================================
-- 1. DOCTORS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS doctors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE,
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  specialization TEXT,
  phone TEXT,
  doctor_image TEXT,
  clinic_name TEXT,
  clinic_address TEXT,
  clinic_phone TEXT,
  clinic_image TEXT,
  clinic_latitude TEXT,
  clinic_longitude TEXT,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_doctors_user_id ON doctors(user_id);
CREATE INDEX IF NOT EXISTS idx_doctors_email ON doctors(email);

ALTER TABLE doctors ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read their own profile" ON doctors;
CREATE POLICY "Doctors can read their own profile" ON doctors
  FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Doctors can update their own profile" ON doctors;
CREATE POLICY "Doctors can update their own profile" ON doctors
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

COMMENT ON TABLE doctors IS 'Medical doctors with clinic information';

-- ============================================================================
-- 2. PATIENTS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS patients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  doctor_id UUID NOT NULL REFERENCES doctors(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  age INTEGER,
  phone TEXT NOT NULL,
  husband_name TEXT,
  history TEXT,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_patients_doctor_id ON patients(doctor_id);
CREATE INDEX IF NOT EXISTS idx_patients_phone ON patients(phone);
CREATE INDEX IF NOT EXISTS idx_patients_created_at ON patients(created_at DESC);

ALTER TABLE patients ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read their patients" ON patients;
CREATE POLICY "Doctors can read their patients" ON patients
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

DROP POLICY IF EXISTS "Doctors can insert patients" ON patients;
CREATE POLICY "Doctors can insert patients" ON patients
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

DROP POLICY IF EXISTS "Doctors can update patients" ON patients;
CREATE POLICY "Doctors can update patients" ON patients
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

COMMENT ON TABLE patients IS 'Patient records managed by doctors';

-- ============================================================================
-- 3. VISITS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS visits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  department TEXT CHECK (department IN ('GYNA', 'OBS', 'IVF_STIM', 'IVF_LAB')),
  diagnosis TEXT,
  prescription TEXT,
  notes TEXT,
  clinical_data JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_visits_patient_id ON visits(patient_id);
CREATE INDEX IF NOT EXISTS idx_visits_date ON visits(date DESC);
CREATE INDEX IF NOT EXISTS idx_visits_department ON visits(department);

ALTER TABLE visits ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read patient visits" ON visits;
CREATE POLICY "Doctors can read patient visits" ON visits
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can insert visits" ON visits;
CREATE POLICY "Doctors can insert visits" ON visits
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can update visits" ON visits;
CREATE POLICY "Doctors can update visits" ON visits
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

COMMENT ON TABLE visits IS 'Patient visits across departments';

-- ============================================================================
-- 4. IVF CYCLES TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS ivf_cycles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  doctor_id UUID NOT NULL REFERENCES doctors(id) ON DELETE CASCADE,
  protocol TEXT NOT NULL CHECK (protocol IN ('Long', 'Antagonist', 'Flare-up', 'Mini-IVF')),
  status TEXT NOT NULL DEFAULT 'Active' CHECK (status IN ('Active', 'Completed', 'Cancelled')),
  start_date DATE NOT NULL,
  assessment_data JSONB DEFAULT '{}',
  lab_data JSONB DEFAULT '{}',
  transfer_data JSONB DEFAULT '{}',
  outcome_data JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_ivf_cycles_patient_id ON ivf_cycles(patient_id);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_doctor_id ON ivf_cycles(doctor_id);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_status ON ivf_cycles(status);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_start_date ON ivf_cycles(start_date DESC);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_assessment_data ON ivf_cycles USING GIN (assessment_data);
CREATE INDEX IF NOT EXISTS idx_ivf_cycles_lab_data ON ivf_cycles USING GIN (lab_data);

ALTER TABLE ivf_cycles ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read their IVF cycles" ON ivf_cycles;
CREATE POLICY "Doctors can read their IVF cycles" ON ivf_cycles
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

DROP POLICY IF EXISTS "Doctors can insert IVF cycles" ON ivf_cycles;
CREATE POLICY "Doctors can insert IVF cycles" ON ivf_cycles
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

DROP POLICY IF EXISTS "Doctors can update IVF cycles" ON ivf_cycles;
CREATE POLICY "Doctors can update IVF cycles" ON ivf_cycles
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

COMMENT ON TABLE ivf_cycles IS 'IVF cycles with assessment, lab, transfer, and outcome data';
COMMENT ON COLUMN ivf_cycles.assessment_data IS 'JSONB: couple profile, male/female factor, tubal-uterine assessments';
COMMENT ON COLUMN ivf_cycles.lab_data IS 'JSONB: OPU data, embryo counts, grading';
COMMENT ON COLUMN ivf_cycles.transfer_data IS 'JSONB: transfer details and luteal support';
COMMENT ON COLUMN ivf_cycles.outcome_data IS 'JSONB: beta-HCG and pregnancy outcomes';

-- ============================================================================
-- 5. STIMULATION LOGS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS stimulation_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cycle_id UUID NOT NULL REFERENCES ivf_cycles(id) ON DELETE CASCADE,
  cycle_day INTEGER NOT NULL,
  date DATE NOT NULL,
  fsh TEXT DEFAULT '',
  hmg TEXT DEFAULT '',
  e2 TEXT DEFAULT '',
  lh TEXT DEFAULT '',
  rt_follicles TEXT DEFAULT '',
  lt_follicles TEXT DEFAULT '',
  endometrium_thickness TEXT DEFAULT '',
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_stimulation_logs_cycle_id ON stimulation_logs(cycle_id);
CREATE INDEX IF NOT EXISTS idx_stimulation_logs_date ON stimulation_logs(date);
CREATE INDEX IF NOT EXISTS idx_stimulation_logs_cycle_day ON stimulation_logs(cycle_day);

ALTER TABLE stimulation_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read stimulation logs" ON stimulation_logs;
CREATE POLICY "Doctors can read stimulation logs" ON stimulation_logs
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND cycle_id IN (
      SELECT id FROM ivf_cycles
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can insert stimulation logs" ON stimulation_logs;
CREATE POLICY "Doctors can insert stimulation logs" ON stimulation_logs
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND cycle_id IN (
      SELECT id FROM ivf_cycles
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can update stimulation logs" ON stimulation_logs;
CREATE POLICY "Doctors can update stimulation logs" ON stimulation_logs
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND cycle_id IN (
      SELECT id FROM ivf_cycles
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND cycle_id IN (
      SELECT id FROM ivf_cycles
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

COMMENT ON TABLE stimulation_logs IS 'Daily hormone and ultrasound data during stimulation phase';

-- ============================================================================
-- 6. PREGNANCIES TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS pregnancies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  doctor_id UUID NOT NULL REFERENCES doctors(id) ON DELETE CASCADE,
  lmp_date DATE,
  edd_date DATE,
  edd_by_scan DATE,
  risk_level TEXT DEFAULT 'low' CHECK (risk_level IN ('low', 'moderate', 'high')),
  risk_factors JSONB DEFAULT '[]',
  aspirin_prescribed BOOLEAN DEFAULT false,
  thromboprophylaxis_needed BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_pregnancies_patient_id ON pregnancies(patient_id);
CREATE INDEX IF NOT EXISTS idx_pregnancies_doctor_id ON pregnancies(doctor_id);
CREATE INDEX IF NOT EXISTS idx_pregnancies_lmp_date ON pregnancies(lmp_date);

ALTER TABLE pregnancies ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read pregnancies" ON pregnancies;
CREATE POLICY "Doctors can read pregnancies" ON pregnancies
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

DROP POLICY IF EXISTS "Doctors can insert pregnancies" ON pregnancies;
CREATE POLICY "Doctors can insert pregnancies" ON pregnancies
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

DROP POLICY IF EXISTS "Doctors can update pregnancies" ON pregnancies;
CREATE POLICY "Doctors can update pregnancies" ON pregnancies
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
  );

COMMENT ON TABLE pregnancies IS 'Pregnancy records with risk assessment';

-- ============================================================================
-- 7. ANTENATAL VISITS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS antenatal_visits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pregnancy_id UUID NOT NULL REFERENCES pregnancies(id) ON DELETE CASCADE,
  visit_date DATE NOT NULL,
  gestational_age_weeks INTEGER,
  gestational_age_days INTEGER,
  weight_kg REAL,
  systolic_bp INTEGER,
  diastolic_bp INTEGER,
  urine_albuminuria TEXT,
  urine_glycosuria TEXT,
  fetal_heart_sound BOOLEAN,
  fundal_height_cm REAL,
  edema BOOLEAN,
  edema_grade TEXT,
  notes TEXT,
  next_visit_date DATE,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_antenatal_visits_pregnancy_id ON antenatal_visits(pregnancy_id);
CREATE INDEX IF NOT EXISTS idx_antenatal_visits_visit_date ON antenatal_visits(visit_date DESC);

ALTER TABLE antenatal_visits ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read antenatal visits" ON antenatal_visits;
CREATE POLICY "Doctors can read antenatal visits" ON antenatal_visits
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can insert antenatal visits" ON antenatal_visits;
CREATE POLICY "Doctors can insert antenatal visits" ON antenatal_visits
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can update antenatal visits" ON antenatal_visits;
CREATE POLICY "Doctors can update antenatal visits" ON antenatal_visits
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

COMMENT ON TABLE antenatal_visits IS 'Regular antenatal care visits';

-- ============================================================================
-- 8. BIOMETRY SCANS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS biometry_scans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pregnancy_id UUID NOT NULL REFERENCES pregnancies(id) ON DELETE CASCADE,
  scan_date DATE NOT NULL,
  gestational_age_weeks INTEGER,
  gestational_age_days INTEGER,
  efw_grams INTEGER,
  percentile INTEGER,
  bpd_mm REAL,
  hc_mm REAL,
  ac_mm REAL,
  fl_mm REAL,
  notes TEXT,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_biometry_scans_pregnancy_id ON biometry_scans(pregnancy_id);
CREATE INDEX IF NOT EXISTS idx_biometry_scans_scan_date ON biometry_scans(scan_date DESC);

ALTER TABLE biometry_scans ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read biometry scans" ON biometry_scans;
CREATE POLICY "Doctors can read biometry scans" ON biometry_scans
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can insert biometry scans" ON biometry_scans;
CREATE POLICY "Doctors can insert biometry scans" ON biometry_scans
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can update biometry scans" ON biometry_scans;
CREATE POLICY "Doctors can update biometry scans" ON biometry_scans
  FOR UPDATE
  USING (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  )
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND pregnancy_id IN (
      SELECT id FROM pregnancies
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

COMMENT ON TABLE biometry_scans IS 'Fetal biometry measurements during pregnancy';

-- ============================================================================
-- 9. PATIENT FILES TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS patient_files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  file_url TEXT NOT NULL,
  file_type TEXT,
  file_name TEXT,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_patient_files_patient_id ON patient_files(patient_id);

ALTER TABLE patient_files ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Doctors can read patient files" ON patient_files;
CREATE POLICY "Doctors can read patient files" ON patient_files
  FOR SELECT
  USING (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

DROP POLICY IF EXISTS "Doctors can insert patient files" ON patient_files;
CREATE POLICY "Doctors can insert patient files" ON patient_files
  FOR INSERT
  WITH CHECK (
    auth.uid() IS NOT NULL
    AND patient_id IN (
      SELECT id FROM patients
      WHERE doctor_id = (SELECT id FROM doctors WHERE user_id = auth.uid() LIMIT 1)
    )
  );

COMMENT ON TABLE patient_files IS 'Patient document files and records';

-- ============================================================================
-- 10. APP SETTINGS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS app_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_name TEXT,
  logo_url TEXT,
  primary_color TEXT DEFAULT '#1f2937',
  secondary_color TEXT DEFAULT '#3b82f6',
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

ALTER TABLE app_settings ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public can read app settings" ON app_settings;
CREATE POLICY "Public can read app settings" ON app_settings
  FOR SELECT
  USING (true);

COMMENT ON TABLE app_settings IS 'Global application settings and branding';

-- ============================================================================
-- POWERSYNC PUBLICATION
-- ============================================================================
-- Handle publication setup with proper error handling
DO $$
DECLARE
    pub_exists boolean;
    pub_all_tables boolean;
BEGIN
    -- Check if publication exists
    SELECT EXISTS(SELECT 1 FROM pg_publication WHERE pubname = 'powersync') INTO pub_exists;
    
    -- If it exists, check if it's FOR ALL TABLES
    IF pub_exists THEN
        SELECT puballtables INTO pub_all_tables 
        FROM pg_publication 
        WHERE pubname = 'powersync';
        
        IF pub_all_tables THEN
            DROP PUBLICATION powersync CASCADE;
            RAISE NOTICE 'Dropped FOR ALL TABLES publication';
        END IF;
    END IF;
    
    -- Now create the publication (fresh)
    BEGIN
        CREATE PUBLICATION powersync;
        RAISE NOTICE 'Created new publication: powersync';
    EXCEPTION WHEN duplicate_object THEN
        RAISE NOTICE 'Publication powersync already exists';
    END;
END $$;

-- Add tables to publication one by one
DO $$
DECLARE
    tables text[] := ARRAY['doctors', 'patients', 'visits', 'ivf_cycles', 'stimulation_logs', 
                           'pregnancies', 'antenatal_visits', 'biometry_scans', 'patient_files', 'app_settings'];
    t text;
BEGIN
    FOREACH t IN ARRAY tables LOOP
        BEGIN
            EXECUTE 'ALTER PUBLICATION powersync ADD TABLE ' || t;
            RAISE NOTICE 'Added table: %', t;
        EXCEPTION WHEN duplicate_object THEN
            RAISE NOTICE 'Table % already in publication', t;
        END;
    END LOOP;
END $$;

-- Verify publication
SELECT tablename FROM pg_publication_tables WHERE pubname = 'powersync' ORDER BY tablename;

-- ============================================================================
-- FINAL VERIFICATION
-- ============================================================================
SELECT 
    tablename,
    rowsecurity
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN (
    'doctors', 'patients', 'visits', 'ivf_cycles', 'stimulation_logs',
    'pregnancies', 'antenatal_visits', 'biometry_scans', 'patient_files', 'app_settings'
)
ORDER BY tablename;
</file>

<file path="POWERSYNC_SETUP_GUIDE.md">
# PowerSync & Database Schema Restructuring Guide

## Overview
This guide documents the restructuring of the database schema and PowerSync integration for the Nile IVF Center application.

## Changes Made

### 1. **AppSchema.ts** - Fixed and Expanded Schema Definition
**File**: `src/powersync/AppSchema.ts`

#### Changes:
- âœ… Added missing `endometrium_thickness` column to `stimulation_logs`
- âœ… Added missing columns to `antenatal_visits` (urine tests, fetal heart, edema, etc.)
- âœ… Added `gestational_age_weeks` and `gestational_age_days` to `biometry_scans`
- âœ… Added complete `doctors` table definition with all clinic information columns
- âœ… Corrected column types (using `column.real` instead of text for numeric values)

### 2. **ivfService.ts** - Enhanced Error Handling & Resilience
**File**: `services/ivfService.ts`

#### Changes:
- âœ… Added `executeWithRetry` function with exponential backoff
- âœ… Wrapped all database operations in try-catch blocks
- âœ… Added input validation before database operations
- âœ… Added detailed error logging in Arabic and English
- âœ… Improved error messages for user feedback
- âœ… Parallel data fetching for `getCycles()` using `Promise.all()`
- âœ… Added retry mechanism with 3 attempts and configurable delay

#### Benefits:
- Automatic retry on transient failures
- Better error messages for debugging
- Offline resilience through local PowerSync storage
- Improved user experience with detailed feedback

### 3. **SupabaseConnector.ts** - Upload with Retry & Conflict Resolution
**File**: `src/powersync/SupabaseConnector.ts`

#### Changes:
- âœ… Added per-operation retry logic (3 attempts)
- âœ… Implemented intelligent retry detection (connection errors only)
- âœ… Added conflict resolution with `onConflict: 'id'` for upserts
- âœ… Improved error tracking and reporting
- âœ… Exponential backoff between retry attempts
- âœ… Detailed logging for each operation

#### Features:
- **Retry Logic**: Automatically retries on connection failures
- **Conflict Handling**: Uses upsert with ID conflict resolution
- **Error Tracking**: Detailed failure tracking with table and error information
- **Graceful Degradation**: Continues syncing other records even if some fail

### 4. **Comprehensive Database Schema (POWERSYNC_SCHEMA_SETUP.sql)**
**File**: `POWERSYNC_SCHEMA_SETUP.sql`

This is the master SQL file containing:

#### Tables (10 total):
1. **doctors** - Medical staff profiles with clinic information
2. **patients** - Patient records
3. **visits** - Clinical visits across departments
4. **ivf_cycles** - IVF cycle management with JSONB data
5. **stimulation_logs** - Daily hormone and ultrasound tracking
6. **pregnancies** - Pregnancy records with risk assessment
7. **antenatal_visits** - Prenatal care visits
8. **biometry_scans** - Fetal ultrasound measurements
9. **patient_files** - Document storage
10. **app_settings** - Application configuration

#### Features:
- âœ… Proper indexes for performance (on foreign keys, dates, and JSONB columns)
- âœ… Row Level Security (RLS) policies for all tables
- âœ… Cascade deletes for referential integrity
- âœ… Check constraints for valid values
- âœ… JSONB columns for flexible data storage
- âœ… Timestamps on all tables for audit trails
- âœ… Proper comments documenting each table

#### RLS Security Model:
```
auth.users (Supabase Auth)
  â””â”€â”€ doctors (user_id)
      â”œâ”€â”€ patients (doctor_id)
      â”‚   â”œâ”€â”€ visits
      â”‚   â””â”€â”€ patient_files
      â”œâ”€â”€ ivf_cycles (doctor_id)
      â”‚   â””â”€â”€ stimulation_logs
      â”œâ”€â”€ pregnancies (doctor_id)
      â”‚   â”œâ”€â”€ antenatal_visits
      â”‚   â””â”€â”€ biometry_scans
      â””â”€â”€ app_settings (public)
```

### 5. **PowerSync Sync Rules Configuration (SyncRules.ts)**
**File**: `src/powersync/SyncRules.ts`

#### Features:
- âœ… SQL rules for data sync filtering
- âœ… Offline-first strategy configuration
- âœ… Conflict resolution strategies
- âœ… Sync configuration options

#### Sync Rules:
Each table has a rule defining what data a doctor can sync:
```
doctors:      Only own profile
patients:     Only assigned patients
visits:       Only visits for own patients
ivf_cycles:   Only own IVF cycles
etc...
```

---

## How to Apply Changes

### Step 1: Update Supabase Database Schema
1. Go to **Supabase Dashboard â†’ SQL Editor**
2. Click **Create Query**
3. Copy the entire content from `POWERSYNC_SCHEMA_SETUP.sql`
4. Paste into the SQL editor
5. Click **Run**
6. Verify all tables are created and RLS is enabled

### Step 2: Configure PowerSync Sync Rules
1. Go to **PowerSync Dashboard â†’ Settings â†’ Sync Rules**
2. Copy the YAML rules from `src/powersync/SyncRules.ts` (the `SYNC_RULES` constant)
3. Paste into the sync rules editor
4. Click **Save**
5. Verify the rules are applied

### Step 3: Deploy Updated Application Code
1. All TypeScript files have been updated automatically:
   - `src/powersync/AppSchema.ts` - Enhanced schema
   - `services/ivfService.ts` - Better error handling
   - `src/powersync/SupabaseConnector.ts` - Retry logic
   - `src/powersync/SyncRules.ts` - New configuration

2. Build and deploy:
```bash
npm run build
npm run preview  # Test locally
# Deploy to production
```

### Step 4: Test the Integration
1. Clear browser cache and local storage
2. Log in to the application
3. Try creating a patient and IVF cycle
4. Go offline (DevTools â†’ Network â†’ Offline)
5. Make changes while offline
6. Go back online and verify sync

---

## Configuration Reference

### ivfService.ts - Retry Configuration
```typescript
const MAX_RETRIES = 3;        // Number of retry attempts
const RETRY_DELAY = 1000;     // Initial delay in ms
// Delay = RETRY_DELAY * attempt_number
```

### SupabaseConnector.ts - Upload Configuration
```typescript
const UPLOAD_RETRIES = 3;     // Retry attempts per operation
const RETRY_DELAY = 1000;     // Initial delay in ms
```

### Offline-First Strategy (from SyncRules.ts)
```typescript
{
  useLocalFirst: true,        // Use local data immediately
  syncWhenOnline: true,       // Sync changes when connection restored
  queueOfflineChanges: true,  // Queue changes made while offline
  persistQueue: true,         // Save queue to disk
  maxOfflineQueue: 1000       // Max pending changes before warning
}
```

---

## Key Features

### 1. **Error Resilience**
- Automatic retry with exponential backoff
- Graceful fallback to offline mode
- Detailed error messages for debugging

### 2. **Data Consistency**
- RLS policies prevent unauthorized access
- Cascade deletes maintain referential integrity
- Check constraints enforce valid values
- JSONB for flexible structured data

### 3. **Performance**
- Optimized indexes on all foreign keys and date fields
- GIN indexes for JSONB queries
- Batch operations for efficiency
- Parallel data fetching

### 4. **Security**
- Row-level security on all tables
- Doctor isolation - can only access own data
- Patient isolation - visible only to their doctor
- Audit timestamps on all records

### 5. **Offline Support**
- Local SQLite database with PowerSync
- Automatic queue of offline changes
- Smart conflict resolution
- Manual sync triggering

---

## Troubleshooting

### Schema Not Updated?
```sql
-- Check if tables exist
SELECT tablename FROM pg_tables 
WHERE schemaname = 'public' 
ORDER BY tablename;

-- Check RLS status
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public';
```

### PowerSync Not Syncing?
1. Check browser console for errors
2. Verify PowerSync connection in DevTools > Network
3. Check credentials in `.env` file
4. Verify sync rules in PowerSync Dashboard

### Offline Changes Not Syncing?
1. Check if device is online
2. Check browser DevTools > Application > IndexedDB > powersync
3. Manually trigger sync: `await powerSyncDb.waitForSync()`

### Conflicts on Sync?
The system uses **remote-wins** strategy by default:
- Remote (server) version overwrites local
- Except for JSONB fields where merge strategy applies
- Can be customized in `SyncRules.ts`

---

## Database Statistics

- **Tables**: 10
- **Indexes**: 20+ for optimal performance
- **RLS Policies**: 30+ policies for security
- **JSONB Fields**: 4 for flexible data storage
- **Relationships**: Properly structured with referential integrity

---

## Next Steps

1. âœ… Run `POWERSYNC_SCHEMA_SETUP.sql` in Supabase
2. âœ… Configure sync rules in PowerSync Dashboard
3. âœ… Deploy updated application code
4. âœ… Test offline functionality
5. âœ… Monitor error logs and adjust retry settings if needed

For questions or issues, check the detailed comments in each file.
</file>

<file path="public/manifest.json">
{
  "name": "Nile IVF Center",
  "short_name": "Nile IVF",
  "description": "Comprehensive IVF and Obstetrics Management System",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#00838f",
  "orientation": "portrait",
  "scope": "/",
  "icons": [
    {
      "src": "/pwa-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/pwa-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "categories": ["medical", "health", "productivity"],
  "lang": "ar-EG",
  "dir": "ltr"
}
</file>

<file path="public/powersync.worker.js">
var sdk_web;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@journeyapps/wa-sqlite/src/sqlite-api.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@journeyapps/wa-sqlite/src/sqlite-api.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Factory: () => (/* binding */ Factory),
/* harmony export */   SQLITE_ABORT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ABORT),
/* harmony export */   SQLITE_ACCESS_EXISTS: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ACCESS_EXISTS),
/* harmony export */   SQLITE_ACCESS_READ: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ACCESS_READ),
/* harmony export */   SQLITE_ACCESS_READWRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ACCESS_READWRITE),
/* harmony export */   SQLITE_ALTER_TABLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ALTER_TABLE),
/* harmony export */   SQLITE_ANALYZE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ANALYZE),
/* harmony export */   SQLITE_ATTACH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ATTACH),
/* harmony export */   SQLITE_AUTH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_AUTH),
/* harmony export */   SQLITE_BLOB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_BLOB),
/* harmony export */   SQLITE_BUSY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_BUSY),
/* harmony export */   SQLITE_CANTOPEN: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CANTOPEN),
/* harmony export */   SQLITE_CONSTRAINT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT),
/* harmony export */   SQLITE_CONSTRAINT_CHECK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_CHECK),
/* harmony export */   SQLITE_CONSTRAINT_COMMITHOOK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_COMMITHOOK),
/* harmony export */   SQLITE_CONSTRAINT_FOREIGNKEY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_FOREIGNKEY),
/* harmony export */   SQLITE_CONSTRAINT_FUNCTION: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_FUNCTION),
/* harmony export */   SQLITE_CONSTRAINT_NOTNULL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_NOTNULL),
/* harmony export */   SQLITE_CONSTRAINT_PINNED: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_PINNED),
/* harmony export */   SQLITE_CONSTRAINT_PRIMARYKEY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_PRIMARYKEY),
/* harmony export */   SQLITE_CONSTRAINT_ROWID: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_ROWID),
/* harmony export */   SQLITE_CONSTRAINT_TRIGGER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_TRIGGER),
/* harmony export */   SQLITE_CONSTRAINT_UNIQUE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_UNIQUE),
/* harmony export */   SQLITE_CONSTRAINT_VTAB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CONSTRAINT_VTAB),
/* harmony export */   SQLITE_COPY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_COPY),
/* harmony export */   SQLITE_CORRUPT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CORRUPT),
/* harmony export */   SQLITE_CREATE_INDEX: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_INDEX),
/* harmony export */   SQLITE_CREATE_TABLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_TABLE),
/* harmony export */   SQLITE_CREATE_TEMP_INDEX: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_TEMP_INDEX),
/* harmony export */   SQLITE_CREATE_TEMP_TABLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_TEMP_TABLE),
/* harmony export */   SQLITE_CREATE_TEMP_TRIGGER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_TEMP_TRIGGER),
/* harmony export */   SQLITE_CREATE_TEMP_VIEW: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_TEMP_VIEW),
/* harmony export */   SQLITE_CREATE_TRIGGER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_TRIGGER),
/* harmony export */   SQLITE_CREATE_VIEW: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_VIEW),
/* harmony export */   SQLITE_CREATE_VTABLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_CREATE_VTABLE),
/* harmony export */   SQLITE_DELETE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DELETE),
/* harmony export */   SQLITE_DENY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DENY),
/* harmony export */   SQLITE_DETACH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DETACH),
/* harmony export */   SQLITE_DETERMINISTIC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DETERMINISTIC),
/* harmony export */   SQLITE_DIRECTONLY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DIRECTONLY),
/* harmony export */   SQLITE_DONE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DONE),
/* harmony export */   SQLITE_DROP_INDEX: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_INDEX),
/* harmony export */   SQLITE_DROP_TABLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_TABLE),
/* harmony export */   SQLITE_DROP_TEMP_INDEX: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_TEMP_INDEX),
/* harmony export */   SQLITE_DROP_TEMP_TABLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_TEMP_TABLE),
/* harmony export */   SQLITE_DROP_TEMP_TRIGGER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_TEMP_TRIGGER),
/* harmony export */   SQLITE_DROP_TEMP_VIEW: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_TEMP_VIEW),
/* harmony export */   SQLITE_DROP_TRIGGER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_TRIGGER),
/* harmony export */   SQLITE_DROP_VIEW: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_VIEW),
/* harmony export */   SQLITE_DROP_VTABLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DROP_VTABLE),
/* harmony export */   SQLITE_EMPTY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_EMPTY),
/* harmony export */   SQLITE_ERROR: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ERROR),
/* harmony export */   SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_BEGIN_ATOMIC_WRITE),
/* harmony export */   SQLITE_FCNTL_BUSYHANDLER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_BUSYHANDLER),
/* harmony export */   SQLITE_FCNTL_CHUNK_SIZE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_CHUNK_SIZE),
/* harmony export */   SQLITE_FCNTL_CKPT_DONE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_CKPT_DONE),
/* harmony export */   SQLITE_FCNTL_CKPT_START: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_CKPT_START),
/* harmony export */   SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_COMMIT_ATOMIC_WRITE),
/* harmony export */   SQLITE_FCNTL_COMMIT_PHASETWO: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_COMMIT_PHASETWO),
/* harmony export */   SQLITE_FCNTL_DATA_VERSION: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_DATA_VERSION),
/* harmony export */   SQLITE_FCNTL_FILE_POINTER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_FILE_POINTER),
/* harmony export */   SQLITE_FCNTL_GET_LOCKPROXYFILE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_GET_LOCKPROXYFILE),
/* harmony export */   SQLITE_FCNTL_HAS_MOVED: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_HAS_MOVED),
/* harmony export */   SQLITE_FCNTL_JOURNAL_POINTER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_JOURNAL_POINTER),
/* harmony export */   SQLITE_FCNTL_LAST_ERRNO: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_LAST_ERRNO),
/* harmony export */   SQLITE_FCNTL_LOCKSTATE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_LOCKSTATE),
/* harmony export */   SQLITE_FCNTL_LOCK_TIMEOUT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_LOCK_TIMEOUT),
/* harmony export */   SQLITE_FCNTL_MMAP_SIZE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_MMAP_SIZE),
/* harmony export */   SQLITE_FCNTL_OVERWRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_OVERWRITE),
/* harmony export */   SQLITE_FCNTL_PDB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_PDB),
/* harmony export */   SQLITE_FCNTL_PERSIST_WAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_PERSIST_WAL),
/* harmony export */   SQLITE_FCNTL_POWERSAFE_OVERWRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_POWERSAFE_OVERWRITE),
/* harmony export */   SQLITE_FCNTL_PRAGMA: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_PRAGMA),
/* harmony export */   SQLITE_FCNTL_RBU: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_RBU),
/* harmony export */   SQLITE_FCNTL_RESERVE_BYTES: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_RESERVE_BYTES),
/* harmony export */   SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE),
/* harmony export */   SQLITE_FCNTL_SET_LOCKPROXYFILE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_SET_LOCKPROXYFILE),
/* harmony export */   SQLITE_FCNTL_SIZE_HINT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_SIZE_HINT),
/* harmony export */   SQLITE_FCNTL_SIZE_LIMIT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_SIZE_LIMIT),
/* harmony export */   SQLITE_FCNTL_SYNC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_SYNC),
/* harmony export */   SQLITE_FCNTL_SYNC_OMITTED: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_SYNC_OMITTED),
/* harmony export */   SQLITE_FCNTL_TEMPFILENAME: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_TEMPFILENAME),
/* harmony export */   SQLITE_FCNTL_TRACE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_TRACE),
/* harmony export */   SQLITE_FCNTL_VFSNAME: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_VFSNAME),
/* harmony export */   SQLITE_FCNTL_VFS_POINTER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_VFS_POINTER),
/* harmony export */   SQLITE_FCNTL_WAL_BLOCK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_WAL_BLOCK),
/* harmony export */   SQLITE_FCNTL_WIN32_AV_RETRY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_WIN32_AV_RETRY),
/* harmony export */   SQLITE_FCNTL_WIN32_GET_HANDLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_WIN32_GET_HANDLE),
/* harmony export */   SQLITE_FCNTL_WIN32_SET_HANDLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_WIN32_SET_HANDLE),
/* harmony export */   SQLITE_FCNTL_ZIPVFS: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FCNTL_ZIPVFS),
/* harmony export */   SQLITE_FLOAT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FLOAT),
/* harmony export */   SQLITE_FORMAT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FORMAT),
/* harmony export */   SQLITE_FULL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FULL),
/* harmony export */   SQLITE_FUNCTION: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FUNCTION),
/* harmony export */   SQLITE_IGNORE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IGNORE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_EQ: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_EQ),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_FUNCTION: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_FUNCTION),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_GE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_GE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_GLOB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_GLOB),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_GT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_GT),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_IS: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_IS),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_ISNOT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_ISNOT),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_ISNOTNULL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_ISNOTNULL),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_ISNULL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_ISNULL),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_LE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_LE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_LIKE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_LIKE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_LT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_LT),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_MATCH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_MATCH),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_NE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_NE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_REGEXP: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_CONSTRAINT_REGEXP),
/* harmony export */   SQLITE_INDEX_SCAN_UNIQUE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INDEX_SCAN_UNIQUE),
/* harmony export */   SQLITE_INNOCUOUS: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INNOCUOUS),
/* harmony export */   SQLITE_INSERT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INSERT),
/* harmony export */   SQLITE_INTEGER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INTEGER),
/* harmony export */   SQLITE_INTERNAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INTERNAL),
/* harmony export */   SQLITE_INTERRUPT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INTERRUPT),
/* harmony export */   SQLITE_IOCAP_ATOMIC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC),
/* harmony export */   SQLITE_IOCAP_ATOMIC16K: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC16K),
/* harmony export */   SQLITE_IOCAP_ATOMIC1K: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC1K),
/* harmony export */   SQLITE_IOCAP_ATOMIC2K: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC2K),
/* harmony export */   SQLITE_IOCAP_ATOMIC32K: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC32K),
/* harmony export */   SQLITE_IOCAP_ATOMIC4K: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC4K),
/* harmony export */   SQLITE_IOCAP_ATOMIC512: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC512),
/* harmony export */   SQLITE_IOCAP_ATOMIC64K: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC64K),
/* harmony export */   SQLITE_IOCAP_ATOMIC8K: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_ATOMIC8K),
/* harmony export */   SQLITE_IOCAP_BATCH_ATOMIC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_BATCH_ATOMIC),
/* harmony export */   SQLITE_IOCAP_IMMUTABLE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_IMMUTABLE),
/* harmony export */   SQLITE_IOCAP_POWERSAFE_OVERWRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_POWERSAFE_OVERWRITE),
/* harmony export */   SQLITE_IOCAP_SAFE_APPEND: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_SAFE_APPEND),
/* harmony export */   SQLITE_IOCAP_SEQUENTIAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_SEQUENTIAL),
/* harmony export */   SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN),
/* harmony export */   SQLITE_IOERR: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR),
/* harmony export */   SQLITE_IOERR_ACCESS: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_ACCESS),
/* harmony export */   SQLITE_IOERR_BEGIN_ATOMIC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_BEGIN_ATOMIC),
/* harmony export */   SQLITE_IOERR_CHECKRESERVEDLOCK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_CHECKRESERVEDLOCK),
/* harmony export */   SQLITE_IOERR_CLOSE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_CLOSE),
/* harmony export */   SQLITE_IOERR_COMMIT_ATOMIC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_COMMIT_ATOMIC),
/* harmony export */   SQLITE_IOERR_DATA: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_DATA),
/* harmony export */   SQLITE_IOERR_DELETE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_DELETE),
/* harmony export */   SQLITE_IOERR_DELETE_NOENT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_DELETE_NOENT),
/* harmony export */   SQLITE_IOERR_DIR_FSYNC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_DIR_FSYNC),
/* harmony export */   SQLITE_IOERR_FSTAT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_FSTAT),
/* harmony export */   SQLITE_IOERR_FSYNC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_FSYNC),
/* harmony export */   SQLITE_IOERR_GETTEMPPATH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_GETTEMPPATH),
/* harmony export */   SQLITE_IOERR_LOCK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_LOCK),
/* harmony export */   SQLITE_IOERR_NOMEM: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_NOMEM),
/* harmony export */   SQLITE_IOERR_RDLOCK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_RDLOCK),
/* harmony export */   SQLITE_IOERR_READ: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_READ),
/* harmony export */   SQLITE_IOERR_ROLLBACK_ATOMIC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_ROLLBACK_ATOMIC),
/* harmony export */   SQLITE_IOERR_SEEK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_SEEK),
/* harmony export */   SQLITE_IOERR_SHORT_READ: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_SHORT_READ),
/* harmony export */   SQLITE_IOERR_TRUNCATE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_TRUNCATE),
/* harmony export */   SQLITE_IOERR_UNLOCK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_UNLOCK),
/* harmony export */   SQLITE_IOERR_VNODE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_VNODE),
/* harmony export */   SQLITE_IOERR_WRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_IOERR_WRITE),
/* harmony export */   SQLITE_LIMIT_ATTACHED: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_ATTACHED),
/* harmony export */   SQLITE_LIMIT_COLUMN: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_COLUMN),
/* harmony export */   SQLITE_LIMIT_COMPOUND_SELECT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_COMPOUND_SELECT),
/* harmony export */   SQLITE_LIMIT_EXPR_DEPTH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_EXPR_DEPTH),
/* harmony export */   SQLITE_LIMIT_FUNCTION_ARG: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_FUNCTION_ARG),
/* harmony export */   SQLITE_LIMIT_LENGTH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_LENGTH),
/* harmony export */   SQLITE_LIMIT_LIKE_PATTERN_LENGTH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_LIKE_PATTERN_LENGTH),
/* harmony export */   SQLITE_LIMIT_SQL_LENGTH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_SQL_LENGTH),
/* harmony export */   SQLITE_LIMIT_TRIGGER_DEPTH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_TRIGGER_DEPTH),
/* harmony export */   SQLITE_LIMIT_VARIABLE_NUMBER: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_VARIABLE_NUMBER),
/* harmony export */   SQLITE_LIMIT_VDBE_OP: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_VDBE_OP),
/* harmony export */   SQLITE_LIMIT_WORKER_THREADS: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LIMIT_WORKER_THREADS),
/* harmony export */   SQLITE_LOCKED: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LOCKED),
/* harmony export */   SQLITE_LOCK_EXCLUSIVE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LOCK_EXCLUSIVE),
/* harmony export */   SQLITE_LOCK_NONE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LOCK_NONE),
/* harmony export */   SQLITE_LOCK_PENDING: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LOCK_PENDING),
/* harmony export */   SQLITE_LOCK_RESERVED: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LOCK_RESERVED),
/* harmony export */   SQLITE_LOCK_SHARED: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_LOCK_SHARED),
/* harmony export */   SQLITE_MISMATCH: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_MISMATCH),
/* harmony export */   SQLITE_MISUSE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_MISUSE),
/* harmony export */   SQLITE_NOLFS: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NOLFS),
/* harmony export */   SQLITE_NOMEM: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NOMEM),
/* harmony export */   SQLITE_NOTADB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NOTADB),
/* harmony export */   SQLITE_NOTFOUND: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NOTFOUND),
/* harmony export */   SQLITE_NOTICE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NOTICE),
/* harmony export */   SQLITE_NULL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NULL),
/* harmony export */   SQLITE_OK: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OK),
/* harmony export */   SQLITE_OPEN_AUTOPROXY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_AUTOPROXY),
/* harmony export */   SQLITE_OPEN_CREATE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_CREATE),
/* harmony export */   SQLITE_OPEN_DELETEONCLOSE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_DELETEONCLOSE),
/* harmony export */   SQLITE_OPEN_EXCLUSIVE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_EXCLUSIVE),
/* harmony export */   SQLITE_OPEN_FULLMUTEX: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_FULLMUTEX),
/* harmony export */   SQLITE_OPEN_MAIN_DB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_MAIN_DB),
/* harmony export */   SQLITE_OPEN_MAIN_JOURNAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_MAIN_JOURNAL),
/* harmony export */   SQLITE_OPEN_MEMORY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_MEMORY),
/* harmony export */   SQLITE_OPEN_NOFOLLOW: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_NOFOLLOW),
/* harmony export */   SQLITE_OPEN_NOMUTEX: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_NOMUTEX),
/* harmony export */   SQLITE_OPEN_PRIVATECACHE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_PRIVATECACHE),
/* harmony export */   SQLITE_OPEN_READONLY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_READONLY),
/* harmony export */   SQLITE_OPEN_READWRITE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_READWRITE),
/* harmony export */   SQLITE_OPEN_SHAREDCACHE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_SHAREDCACHE),
/* harmony export */   SQLITE_OPEN_SUBJOURNAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_SUBJOURNAL),
/* harmony export */   SQLITE_OPEN_SUPER_JOURNAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_SUPER_JOURNAL),
/* harmony export */   SQLITE_OPEN_TEMP_DB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_TEMP_DB),
/* harmony export */   SQLITE_OPEN_TEMP_JOURNAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_TEMP_JOURNAL),
/* harmony export */   SQLITE_OPEN_TRANSIENT_DB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_TRANSIENT_DB),
/* harmony export */   SQLITE_OPEN_URI: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_URI),
/* harmony export */   SQLITE_OPEN_WAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_WAL),
/* harmony export */   SQLITE_PERM: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_PERM),
/* harmony export */   SQLITE_PRAGMA: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_PRAGMA),
/* harmony export */   SQLITE_PREPARE_NORMALIZED: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_PREPARE_NORMALIZED),
/* harmony export */   SQLITE_PREPARE_NO_VTAB: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_PREPARE_NO_VTAB),
/* harmony export */   SQLITE_PREPARE_PERSISTENT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_PREPARE_PERSISTENT),
/* harmony export */   SQLITE_PROTOCOL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_PROTOCOL),
/* harmony export */   SQLITE_RANGE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_RANGE),
/* harmony export */   SQLITE_READ: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_READ),
/* harmony export */   SQLITE_READONLY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_READONLY),
/* harmony export */   SQLITE_RECURSIVE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_RECURSIVE),
/* harmony export */   SQLITE_REINDEX: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_REINDEX),
/* harmony export */   SQLITE_ROW: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ROW),
/* harmony export */   SQLITE_SAVEPOINT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_SAVEPOINT),
/* harmony export */   SQLITE_SCHEMA: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_SCHEMA),
/* harmony export */   SQLITE_SELECT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_SELECT),
/* harmony export */   SQLITE_STATIC: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_STATIC),
/* harmony export */   SQLITE_SUBTYPE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_SUBTYPE),
/* harmony export */   SQLITE_SYNC_DATAONLY: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_SYNC_DATAONLY),
/* harmony export */   SQLITE_SYNC_FULL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_SYNC_FULL),
/* harmony export */   SQLITE_SYNC_NORMAL: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_SYNC_NORMAL),
/* harmony export */   SQLITE_TEXT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_TEXT),
/* harmony export */   SQLITE_TOOBIG: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_TOOBIG),
/* harmony export */   SQLITE_TRANSACTION: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_TRANSACTION),
/* harmony export */   SQLITE_TRANSIENT: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_TRANSIENT),
/* harmony export */   SQLITE_UPDATE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_UPDATE),
/* harmony export */   SQLITE_UTF16: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_UTF16),
/* harmony export */   SQLITE_UTF16BE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_UTF16BE),
/* harmony export */   SQLITE_UTF16LE: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_UTF16LE),
/* harmony export */   SQLITE_UTF8: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_UTF8),
/* harmony export */   SQLITE_WARNING: () => (/* reexport safe */ _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_WARNING),
/* harmony export */   SQLiteError: () => (/* binding */ SQLiteError)
/* harmony export */ });
/* harmony import */ var _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sqlite-constants.js */ "../../node_modules/@journeyapps/wa-sqlite/src/sqlite-constants.js");
// Copyright 2021 Roy T. Hashimoto. All Rights Reserved.




/**
 * Need to have a serializer for bigint
 * https://github.com/GoogleChromeLabs/jsbi/issues/30
 */
if (typeof BigInt.prototype['toJSON'] == 'undefined') {
  BigInt.prototype['toJSON'] = function() {
    return this.toString();
  };
}

const MAX_INT64 = 0x7fffffffffffffffn;
const MIN_INT64 = -0x8000000000000000n;

const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;

class SQLiteError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}

const async = true;


/**
 * Builds a Javascript API from the Emscripten module. This API is still
 * low-level and closely corresponds to the C API exported by the module,
 * but differs in some specifics like throwing exceptions on errors.
 * @param {*} Module SQLite Emscripten module
 * @returns {SQLiteAPI}
 */
function Factory(Module) {
  /** @type {SQLiteAPI} */ const sqlite3 = {};

  Module.retryOps = [];
  const sqliteFreeAddress = Module._getSqliteFree();

  // Allocate some space for 32-bit returned values.
  const tmp = Module._malloc(8);
  const tmpPtr = [tmp, tmp + 4];

  const textEncoder = new TextEncoder();
  // Convert a JS string to a C string. sqlite3_malloc is used to allocate
  // memory (use sqlite3_free to deallocate).
  function createUTF8(s) {
    if (typeof s !== 'string') return 0;
    const utf8 = textEncoder.encode(s);
    const zts = Module._sqlite3_malloc(utf8.byteLength + 1);
    Module.HEAPU8.set(utf8, zts);
    Module.HEAPU8[zts + utf8.byteLength] = 0;
    return zts;
  }

  /**
   * Concatenate 32-bit numbers into a 64-bit (signed) BigInt.
   * @param {number} lo32
   * @param {number} hi32
   * @returns {bigint}
   */
  function cvt32x2ToBigInt(lo32, hi32) {
    return (BigInt(hi32) << 32n) | (BigInt(lo32) & 0xffffffffn);
  }

  // /**
  //  * Setup table change update callback
  //  */
  // var onTableChangedFunctionPointer = Module.addFunction(onTableUpdate);
  // var passFnPointer = Module.cwrap('passFnPointer', 'undefined', ['number']);
  // passFnPointer(onTableChangedFunctionPointer);
  /**
   * Concatenate 32-bit numbers and return as number or BigInt, depending
   * on the value.
   * @param {number} lo32
   * @param {number} hi32
   * @returns {number|bigint}
   */
  const cvt32x2AsSafe = (function() {
    const hiMax = BigInt(Number.MAX_SAFE_INTEGER) >> 32n;
    const hiMin = BigInt(Number.MIN_SAFE_INTEGER) >> 32n;

    return function(lo32, hi32) {
      if (hi32 > hiMax || hi32 < hiMin) {
        // Can't be expressed as a Number so use BigInt.
        return cvt32x2ToBigInt(lo32, hi32);
      } else {
        // Combine the upper and lower 32-bit numbers. The complication is
        // that lo32 is a signed integer which makes manipulating its bits
        // a little tricky - the sign bit gets handled separately.
        return hi32 * 0x100000000 + (lo32 & 0x7fffffff) - (lo32 & 0x80000000);
      }
    };
  })();

  const databases = new Set();
  function verifyDatabase(db) {
    if (!databases.has(db)) {
      throw new SQLiteError('not a database', _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_MISUSE);
    }
  }

  const mapStmtToDB = new Map();
  function verifyStatement(stmt) {
    if (!mapStmtToDB.has(stmt)) {
      throw new SQLiteError('not a statement', _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_MISUSE);
    }
  }

  sqlite3.bind_collection = function(stmt, bindings) {
    verifyStatement(stmt);
    const isArray = Array.isArray(bindings);
    const nBindings = sqlite3.bind_parameter_count(stmt);
    for (let i = 1; i <= nBindings; ++i) {
      const key = isArray ? i - 1 : sqlite3.bind_parameter_name(stmt, i);
      const value = bindings[key];
      if (value !== undefined) {
        sqlite3.bind(stmt, i, value);
      }
    }
    return _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OK;
  };

  sqlite3.bind = function(stmt, i, value) {
    verifyStatement(stmt);
    switch (typeof value) {
      case 'number':
        if (value === (value | 0)) {
          return sqlite3.bind_int(stmt, i, value);
        } else {
          return sqlite3.bind_double(stmt, i, value);
        }
      case 'string':
        return sqlite3.bind_text(stmt, i, value);
      case "boolean":
        return sqlite3.bind_int(stmt, i, value ? 1 : 0);
      default:
        if (value instanceof Uint8Array || Array.isArray(value)) {
          return sqlite3.bind_blob(stmt, i, value);
        } else if (value === null) {
          return sqlite3.bind_null(stmt, i);
        } else if (typeof value === 'bigint') {
          return sqlite3.bind_int64(stmt, i, value);
        } else if (value === undefined) {
          // Existing binding (or NULL) will be used.
          return _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NOTICE;
        } else {
          console.warn('unknown binding converted to null', value);
          return sqlite3.bind_null(stmt, i);
        }
    }
  };

  sqlite3.bind_blob = (function() {
    const fname = 'sqlite3_bind_blob';
    const f = Module.cwrap(fname, ...decl('nnnnn:n'));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      // @ts-ignore
      const byteLength = value.byteLength ?? value.length;
      const ptr = Module._sqlite3_malloc(byteLength);
      Module.HEAPU8.subarray(ptr).set(value);
      const result = f(stmt, i, ptr, byteLength, sqliteFreeAddress);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  })();

  sqlite3.bind_parameter_count = (function() {
    const fname = 'sqlite3_bind_parameter_count';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  })();

  sqlite3.bind_double = (function() {
    const fname = 'sqlite3_bind_double';
    const f = Module.cwrap(fname, ...decl('nnn:n'));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      const result = f(stmt, i, value);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  })();

  sqlite3.bind_int = (function() {
    const fname = 'sqlite3_bind_int';
    const f = Module.cwrap(fname, ...decl('nnn:n'));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      if (value > 0x7fffffff || value < -0x80000000) return _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_RANGE;

      const result = f(stmt, i, value);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  })();

  sqlite3.bind_int64 = (function() {
    const fname = 'sqlite3_bind_int64';
    const f = Module.cwrap(fname, ...decl('nnnn:n'));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      if (value > MAX_INT64 || value < MIN_INT64) return _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_RANGE;

      const lo32 = value & 0xffffffffn;
      const hi32 = value >> 32n;
      const result = f(stmt, i, Number(lo32), Number(hi32));
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  })();

  sqlite3.bind_null = (function() {
    const fname = 'sqlite3_bind_null';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(stmt, i) {
      verifyStatement(stmt);
      const result = f(stmt, i);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  })();

  sqlite3.bind_parameter_name = (function() {
    const fname = 'sqlite3_bind_parameter_name';
    const f = Module.cwrap(fname, ...decl('n:s'));
    return function(stmt, i) {
      verifyStatement(stmt);
      const result = f(stmt, i);
      return result;
    };
  })();

  sqlite3.bind_text = (function() {
    const fname = 'sqlite3_bind_text';
    const f = Module.cwrap(fname, ...decl('nnnnn:n'));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      const ptr = createUTF8(value);
      const result = f(stmt, i, ptr, -1, sqliteFreeAddress);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  })();

  sqlite3.changes = (function() {
    const fname = 'sqlite3_changes';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(db) {
      verifyDatabase(db);
      const result = f(db);
      return result;
    };
  })();

  sqlite3.clear_bindings = (function() {
    const fname = 'sqlite3_clear_bindings';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  })();

  sqlite3.last_insert_id = (function() {
    const fname = 'sqlite3_last_insert_rowid';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(db) {
      verifyDatabase(db);
      const result = f(db);
      // trace(fname, result);
      return result;
    };
  })();
  
  sqlite3.close = (function() {
    const fname = 'sqlite3_close';
    const f = Module.cwrap(fname, ...decl('n:n'), { async });
    return async function(db) {
      verifyDatabase(db);
      const result = await f(db);
      databases.delete(db);
      return check(fname, result, db);
    };
  })();

  sqlite3.column = function(stmt, iCol) {
    verifyStatement(stmt);
    const type = sqlite3.column_type(stmt, iCol);
    switch (type) {
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_BLOB:
        return sqlite3.column_blob(stmt, iCol);
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FLOAT:
        return sqlite3.column_double(stmt, iCol);
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INTEGER:
        const lo32 = sqlite3.column_int(stmt, iCol);
        const hi32 = Module.getTempRet0();
        return cvt32x2AsSafe(lo32, hi32);
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NULL:
        return null;
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_TEXT:
        return sqlite3.column_text(stmt, iCol);
      default:
        throw new SQLiteError('unknown type', type);
    }
  };

  sqlite3.column_blob = (function() {
    const fname = 'sqlite3_column_blob';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const nBytes = sqlite3.column_bytes(stmt, iCol);
      const address = f(stmt, iCol);
      const result = Module.HEAPU8.subarray(address, address + nBytes);
      return result;
    };
  })();

  sqlite3.column_bytes = (function() {
    const fname = 'sqlite3_column_bytes';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();

  sqlite3.column_count = (function() {
    const fname = 'sqlite3_column_count';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  })();

  sqlite3.column_double = (function() {
    const fname = 'sqlite3_column_double';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();

  sqlite3.column_int = (function() {
    // Retrieve int64 but use only the lower 32 bits. The upper 32-bits are
    // accessible with Module.getTempRet0().
    const fname = 'sqlite3_column_int64';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();

  sqlite3.column_int64 = (function() {
    const fname = 'sqlite3_column_int64';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const lo32 = f(stmt, iCol);
      const hi32 = Module.getTempRet0();
      const result = cvt32x2ToBigInt(lo32, hi32);
      return result;
    };
  })();

  sqlite3.column_name = (function() {
    const fname = 'sqlite3_column_name';
    const f = Module.cwrap(fname, ...decl('nn:s'));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();

  sqlite3.column_names = function(stmt) {
    const columns = [];
    const nColumns = sqlite3.column_count(stmt);
    for (let i = 0; i < nColumns; ++i) {
      columns.push(sqlite3.column_name(stmt, i));
    }
    return columns;
  };

  sqlite3.column_text = (function() {
    const fname = 'sqlite3_column_text';
    const f = Module.cwrap(fname, ...decl('nn:s'));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();

  sqlite3.column_type = (function() {
    const fname = 'sqlite3_column_type';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();

  sqlite3.create_function = function(db, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
    verifyDatabase(db);
    
    // Convert SQLite callback arguments to JavaScript-friendly arguments.
    function adapt(f) {
      return f instanceof AsyncFunction ?
        (async (ctx, n, values) => f(ctx, Module.HEAP32.subarray(values / 4, values / 4 + n))) :
        ((ctx, n, values) => f(ctx, Module.HEAP32.subarray(values / 4, values / 4 + n)));
    }

    const result = Module.create_function(
      db,
      zFunctionName,
      nArg,
      eTextRep,
      pApp,
      xFunc && adapt(xFunc),
      xStep && adapt(xStep),
      xFinal);
    return check('sqlite3_create_function', result, db);
  };

  sqlite3.data_count = (function() {
    const fname = 'sqlite3_data_count';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  })();

  sqlite3.exec = async function(db, sql, callback) {
    for await (const stmt of sqlite3.statements(db, sql)) {
      let columns;
      while ((await sqlite3.step(stmt)) === _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ROW) {
        if (callback) {
          columns = columns ?? sqlite3.column_names(stmt);
          const row = sqlite3.row(stmt);
          await callback(row, columns);
        }
      }
    }
    return _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OK;
  };

  sqlite3.finalize = (function() {
    const fname = 'sqlite3_finalize';
    const f = Module.cwrap(fname, ...decl('n:n'), { async });
    return async function(stmt) {
      const result = await f(stmt);
      mapStmtToDB.delete(stmt)

      // Don't throw on error here. Typically the error has already been
      // thrown and finalize() is part of the cleanup.
      return result;
    };
  })();

  sqlite3.get_autocommit = (function() {
    const fname = 'sqlite3_get_autocommit';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(db) {
      const result = f(db);
      return result;
    };
  })();

  sqlite3.libversion = (function() {
    const fname = 'sqlite3_libversion';
    const f = Module.cwrap(fname, ...decl(':s'));
    return function() {
      const result = f();
      return result;
    };
  })();

  sqlite3.libversion_number = (function() {
    const fname = 'sqlite3_libversion_number';
    const f = Module.cwrap(fname, ...decl(':n'));
    return function() {
      const result = f();
      return result;
    };
  })();

  sqlite3.limit = (function() {
    const fname = 'sqlite3_limit';
    const f = Module.cwrap(fname, ...decl('nnn:n'));
    return function(db, id, newVal) {
      const result = f(db, id, newVal);
      return result;
    };
  })();

  sqlite3.open_v2 = (function() {
    const fname = 'sqlite3_open_v2';
    const f = Module.cwrap(fname, ...decl('snnn:n'), { async });
    return async function(zFilename, flags, zVfs) {
      flags = flags || _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_CREATE | _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OPEN_READWRITE;
      zVfs = createUTF8(zVfs);
      try {
        // Allow retry operations.
        const rc = await retry(() => f(zFilename, tmpPtr[0], flags, zVfs));

        const db = Module.getValue(tmpPtr[0], '*');
        databases.add(db);

        Module.ccall('RegisterExtensionFunctions', 'number', ['number'], [db]);
        check(fname, rc);
        return db;
      } finally {
        Module._sqlite3_free(zVfs);
      }
    };
  })();

  sqlite3.progress_handler = function(db, nProgressOps, handler, userData) {
    verifyDatabase(db);
    Module.progress_handler(db, nProgressOps, handler, userData);
  };;

  sqlite3.reset = (function() {
    const fname = 'sqlite3_reset';
    const f = Module.cwrap(fname, ...decl('n:n'), { async });
    return async function(stmt) {
      verifyStatement(stmt);
      const result = await f(stmt);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  })();

  sqlite3.result = function(context, value) {
    switch (typeof value) {
      case 'number':
        if (value === (value | 0)) {
          sqlite3.result_int(context, value);
        } else {
          sqlite3.result_double(context, value);
        }
        break;
      case 'string':
        sqlite3.result_text(context, value);
        break;
      default:
        if (value instanceof Uint8Array || Array.isArray(value)) {
          sqlite3.result_blob(context, value);
        } else if (value === null) {
          sqlite3.result_null(context);
        } else if (typeof value === 'bigint') {
          return sqlite3.result_int64(context, value);
        } else {
          console.warn('unknown result converted to null', value);
          sqlite3.result_null(context);
        }
        break;
    }
  };

  sqlite3.result_blob = (function() {
    const fname = 'sqlite3_result_blob';
    const f = Module.cwrap(fname, ...decl('nnnn:n'));
    return function(context, value) {
      // @ts-ignore
      const byteLength = value.byteLength ?? value.length;
      const ptr = Module._sqlite3_malloc(byteLength);
      Module.HEAPU8.subarray(ptr).set(value);
      f(context, ptr, byteLength, sqliteFreeAddress); // void return
    };
  })();

  sqlite3.result_double = (function() {
    const fname = 'sqlite3_result_double';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(context, value) {
      f(context, value); // void return
    };
  })();

  sqlite3.result_int = (function() {
    const fname = 'sqlite3_result_int';
    const f = Module.cwrap(fname, ...decl('nn:n'));
    return function(context, value) {
      f(context, value); // void return
    };
  })();

  sqlite3.result_int64 = (function() {
    const fname = 'sqlite3_result_int64';
    const f = Module.cwrap(fname, ...decl('nnn:n'));
    return function(context, value) {
      if (value > MAX_INT64 || value < MIN_INT64) return _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_RANGE;

      const lo32 = value & 0xffffffffn;
      const hi32 = value >> 32n;
      f(context, Number(lo32), Number(hi32)); // void return
    };
  })();

  sqlite3.result_null = (function() {
    const fname = 'sqlite3_result_null';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(context) {
      f(context); // void return
    };
  })();

  sqlite3.result_text = (function() {
    const fname = 'sqlite3_result_text';
    const f = Module.cwrap(fname, ...decl('nnnn:n'));
    return function(context, value) {
      const ptr = createUTF8(value);
      f(context, ptr, -1, sqliteFreeAddress); // void return
    };
  })();

  sqlite3.row = function(stmt) {
    const row = [];
    const nColumns = sqlite3.data_count(stmt);
    for (let i = 0; i < nColumns; ++i) {
      const value = sqlite3.column(stmt, i);

      // Copy blob if aliasing volatile WebAssembly memory. This avoids an
      // unnecessary copy if users monkey patch column_blob to copy.
      // @ts-ignore
      row.push(value?.buffer === Module.HEAPU8.buffer ? value.slice() : value);
    }
    return row;
  };

  sqlite3.set_authorizer = function(db, xAuth, pApp) {
    verifyDatabase(db);

    // Convert SQLite callback arguments to JavaScript-friendly arguments.
    function cvtArgs(_, iAction, p3, p4, p5, p6) {
      return [
        _,
        iAction,
        Module.UTF8ToString(p3),
        Module.UTF8ToString(p4),
        Module.UTF8ToString(p5),
        Module.UTF8ToString(p6)
      ];
    };
    function adapt(f) {
      return f instanceof AsyncFunction ?
        (async (_, iAction, p3, p4, p5, p6) => f(...cvtArgs(_, iAction, p3, p4, p5, p6))) :
        ((_, iAction, p3, p4, p5, p6) => f(...cvtArgs(_, iAction, p3, p4, p5, p6)));
    }

    const result = Module.set_authorizer(db, adapt(xAuth), pApp);
    return check('sqlite3_set_authorizer', result, db);
  };

  sqlite3.sql = (function() {
    const fname = 'sqlite3_sql';
    const f = Module.cwrap(fname, ...decl('n:s'));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  })();

  sqlite3.statements = function(db, sql, options = {}) {
    const prepare = Module.cwrap(
      'sqlite3_prepare_v3',
      'number',
      ['number', 'number', 'number', 'number', 'number', 'number'],
      { async: true });

    return (async function*() {
      const onFinally = [];
      try {
        // Encode SQL string to UTF-8.
        const utf8 = textEncoder.encode(sql);

        // Copy encoded string to WebAssembly memory. The SQLite docs say
        // zero-termination is a minor optimization so add room for that.
        // Also add space for the statement handle and SQL tail pointer.
        const allocSize = utf8.byteLength - (utf8.byteLength % 4) + 12;
        const pzHead = Module._sqlite3_malloc(allocSize);
        const pzEnd = pzHead + utf8.byteLength + 1;
        onFinally.push(() => Module._sqlite3_free(pzHead));
        Module.HEAPU8.set(utf8, pzHead);
        Module.HEAPU8[pzEnd - 1] = 0;
  
        // Use extra space for the statement handle and SQL tail pointer.
        const pStmt = pzHead + allocSize - 8;
        const pzTail = pzHead + allocSize - 4;

        // Ensure that statement handles are not leaked.
        let stmt;
        function maybeFinalize() {
          if (stmt && !options.unscoped) {
            sqlite3.finalize(stmt);
          }
          stmt = 0;
        }
        onFinally.push(maybeFinalize);
        
        // Loop over statements.
        Module.setValue(pzTail, pzHead, '*');
        do {
          // Reclaim resources for the previous iteration.
          maybeFinalize();

          // Call sqlite3_prepare_v3() for the next statement.
          // Allow retry operations.
          const zTail = Module.getValue(pzTail, '*');
          const rc = await retry(() => {
            return prepare(
              db,
              zTail,
              pzEnd - pzTail,
              options.flags || 0,
              pStmt,
              pzTail);
          });

          if (rc !== _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OK) {
            check('sqlite3_prepare_v3', rc, db);
          }
          
          stmt = Module.getValue(pStmt, '*');
          if (stmt) {
            mapStmtToDB.set(stmt, db);
            yield stmt;
          }
        } while (stmt);
      } finally {
        while (onFinally.length) {
          onFinally.pop()();
        }
      }
    })();
  };

  sqlite3.step = (function() {
    const fname = 'sqlite3_step';
    const f = Module.cwrap(fname, ...decl('n:n'), { async });
    return async function(stmt) {
      verifyStatement(stmt);

      // Allow retry operations.
      const rc = await retry(() => f(stmt));

      return check(fname, rc, mapStmtToDB.get(stmt), [_sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ROW, _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DONE]);
    };
  })();

  sqlite3.commit_hook = function(db, xCommitHook) {
    verifyDatabase(db);
    Module.commit_hook(db, xCommitHook);
  };

  sqlite3.update_hook = function(db, xUpdateHook) {
    verifyDatabase(db);

    // Convert SQLite callback arguments to JavaScript-friendly arguments.
    function cvtArgs(iUpdateType, dbName, tblName, lo32, hi32) {
      return [
        iUpdateType,
        Module.UTF8ToString(dbName),
        Module.UTF8ToString(tblName),
		cvt32x2ToBigInt(lo32, hi32)
      ];
    };
    function adapt(f) {
      return f instanceof AsyncFunction ?
        (async (iUpdateType, dbName, tblName, lo32, hi32) => f(...cvtArgs(iUpdateType, dbName, tblName, lo32, hi32))) :
        ((iUpdateType, dbName, tblName, lo32, hi32) => f(...cvtArgs(iUpdateType, dbName, tblName, lo32, hi32)));
    }

    Module.update_hook(db, adapt(xUpdateHook));
  };;

  sqlite3.value = function(pValue) {
    const type = sqlite3.value_type(pValue);
    switch (type) {
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_BLOB:
        return sqlite3.value_blob(pValue);
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_FLOAT:
        return sqlite3.value_double(pValue);
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_INTEGER:
        const lo32 = sqlite3.value_int(pValue);
        const hi32 = Module.getTempRet0();
        return cvt32x2AsSafe(lo32, hi32);
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_NULL:
        return null;
      case _sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_TEXT:
        return sqlite3.value_text(pValue);
      default:
        throw new SQLiteError('unknown type', type);
    }
  };

  sqlite3.value_blob = (function() {
    const fname = 'sqlite3_value_blob';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(pValue) {
      const nBytes = sqlite3.value_bytes(pValue);
      const address = f(pValue);
      const result = Module.HEAPU8.subarray(address, address + nBytes);
      return result;
    };
  })();

  sqlite3.value_bytes = (function() {
    const fname = 'sqlite3_value_bytes';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();

  sqlite3.value_double = (function() {
    const fname = 'sqlite3_value_double';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();

  sqlite3.value_int = (function() {
    const fname = 'sqlite3_value_int64';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();

  sqlite3.value_int64 = (function() {
    const fname = 'sqlite3_value_int64';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(pValue) {
      const lo32 = f(pValue);
      const hi32 = Module.getTempRet0();
      const result = cvt32x2ToBigInt(lo32, hi32);
      return result;
    };
  })();

  sqlite3.value_text = (function() {
    const fname = 'sqlite3_value_text';
    const f = Module.cwrap(fname, ...decl('n:s'));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();

  sqlite3.value_type = (function() {
    const fname = 'sqlite3_value_type';
    const f = Module.cwrap(fname, ...decl('n:n'));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();

  sqlite3.vfs_register = function(vfs, makeDefault) {
    const result = Module.vfs_register(vfs, makeDefault);
    return check('sqlite3_vfs_register', result);
  };

  function check(fname, result, db = null, allowed = [_sqlite_constants_js__WEBPACK_IMPORTED_MODULE_0__.SQLITE_OK]) {
    if (allowed.includes(result)) return result;
    const message = db ? Module.ccall('sqlite3_errmsg', 'string', ['number'], [db]) : fname;
    throw new SQLiteError(message, result);
  }

  // This function is used to automatically retry failed calls that
  // have pending retry operations that should allow the retry to
  // succeed.
  async function retry(f) {
    let rc;
    do {
      // Wait for all pending retry operations to complete. This is
      // normally empty on the first loop iteration.
      if (Module.retryOps.length) {
        await Promise.all(Module.retryOps);
        Module.retryOps = [];
      }
      
      rc = await f();

      // Retry on failure with new pending retry operations.
    } while (rc && Module.retryOps.length);
    return rc;
  }

  return sqlite3;
}

// Helper function to use a more compact signature specification.
function decl(s) {
  const result = [];
  const m = s.match(/([ns@]*):([nsv@])/);
  switch (m[2]) {
    case 'n':
      result.push('number');
      break;
    case 's':
      result.push('string');
      break;
    case 'v':
      result.push(null);
      break;
  }

  const args = [];
  for (let c of m[1]) {
    switch (c) {
      case 'n':
        args.push('number');
        break;
      case 's':
        args.push('string');
        break;
    }
  }
  result.push(args);
  return result;
}


/***/ }),

/***/ "../../node_modules/@journeyapps/wa-sqlite/src/sqlite-constants.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@journeyapps/wa-sqlite/src/sqlite-constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SQLITE_ABORT: () => (/* binding */ SQLITE_ABORT),
/* harmony export */   SQLITE_ACCESS_EXISTS: () => (/* binding */ SQLITE_ACCESS_EXISTS),
/* harmony export */   SQLITE_ACCESS_READ: () => (/* binding */ SQLITE_ACCESS_READ),
/* harmony export */   SQLITE_ACCESS_READWRITE: () => (/* binding */ SQLITE_ACCESS_READWRITE),
/* harmony export */   SQLITE_ALTER_TABLE: () => (/* binding */ SQLITE_ALTER_TABLE),
/* harmony export */   SQLITE_ANALYZE: () => (/* binding */ SQLITE_ANALYZE),
/* harmony export */   SQLITE_ATTACH: () => (/* binding */ SQLITE_ATTACH),
/* harmony export */   SQLITE_AUTH: () => (/* binding */ SQLITE_AUTH),
/* harmony export */   SQLITE_BLOB: () => (/* binding */ SQLITE_BLOB),
/* harmony export */   SQLITE_BUSY: () => (/* binding */ SQLITE_BUSY),
/* harmony export */   SQLITE_CANTOPEN: () => (/* binding */ SQLITE_CANTOPEN),
/* harmony export */   SQLITE_CONSTRAINT: () => (/* binding */ SQLITE_CONSTRAINT),
/* harmony export */   SQLITE_CONSTRAINT_CHECK: () => (/* binding */ SQLITE_CONSTRAINT_CHECK),
/* harmony export */   SQLITE_CONSTRAINT_COMMITHOOK: () => (/* binding */ SQLITE_CONSTRAINT_COMMITHOOK),
/* harmony export */   SQLITE_CONSTRAINT_FOREIGNKEY: () => (/* binding */ SQLITE_CONSTRAINT_FOREIGNKEY),
/* harmony export */   SQLITE_CONSTRAINT_FUNCTION: () => (/* binding */ SQLITE_CONSTRAINT_FUNCTION),
/* harmony export */   SQLITE_CONSTRAINT_NOTNULL: () => (/* binding */ SQLITE_CONSTRAINT_NOTNULL),
/* harmony export */   SQLITE_CONSTRAINT_PINNED: () => (/* binding */ SQLITE_CONSTRAINT_PINNED),
/* harmony export */   SQLITE_CONSTRAINT_PRIMARYKEY: () => (/* binding */ SQLITE_CONSTRAINT_PRIMARYKEY),
/* harmony export */   SQLITE_CONSTRAINT_ROWID: () => (/* binding */ SQLITE_CONSTRAINT_ROWID),
/* harmony export */   SQLITE_CONSTRAINT_TRIGGER: () => (/* binding */ SQLITE_CONSTRAINT_TRIGGER),
/* harmony export */   SQLITE_CONSTRAINT_UNIQUE: () => (/* binding */ SQLITE_CONSTRAINT_UNIQUE),
/* harmony export */   SQLITE_CONSTRAINT_VTAB: () => (/* binding */ SQLITE_CONSTRAINT_VTAB),
/* harmony export */   SQLITE_COPY: () => (/* binding */ SQLITE_COPY),
/* harmony export */   SQLITE_CORRUPT: () => (/* binding */ SQLITE_CORRUPT),
/* harmony export */   SQLITE_CREATE_INDEX: () => (/* binding */ SQLITE_CREATE_INDEX),
/* harmony export */   SQLITE_CREATE_TABLE: () => (/* binding */ SQLITE_CREATE_TABLE),
/* harmony export */   SQLITE_CREATE_TEMP_INDEX: () => (/* binding */ SQLITE_CREATE_TEMP_INDEX),
/* harmony export */   SQLITE_CREATE_TEMP_TABLE: () => (/* binding */ SQLITE_CREATE_TEMP_TABLE),
/* harmony export */   SQLITE_CREATE_TEMP_TRIGGER: () => (/* binding */ SQLITE_CREATE_TEMP_TRIGGER),
/* harmony export */   SQLITE_CREATE_TEMP_VIEW: () => (/* binding */ SQLITE_CREATE_TEMP_VIEW),
/* harmony export */   SQLITE_CREATE_TRIGGER: () => (/* binding */ SQLITE_CREATE_TRIGGER),
/* harmony export */   SQLITE_CREATE_VIEW: () => (/* binding */ SQLITE_CREATE_VIEW),
/* harmony export */   SQLITE_CREATE_VTABLE: () => (/* binding */ SQLITE_CREATE_VTABLE),
/* harmony export */   SQLITE_DELETE: () => (/* binding */ SQLITE_DELETE),
/* harmony export */   SQLITE_DENY: () => (/* binding */ SQLITE_DENY),
/* harmony export */   SQLITE_DETACH: () => (/* binding */ SQLITE_DETACH),
/* harmony export */   SQLITE_DETERMINISTIC: () => (/* binding */ SQLITE_DETERMINISTIC),
/* harmony export */   SQLITE_DIRECTONLY: () => (/* binding */ SQLITE_DIRECTONLY),
/* harmony export */   SQLITE_DONE: () => (/* binding */ SQLITE_DONE),
/* harmony export */   SQLITE_DROP_INDEX: () => (/* binding */ SQLITE_DROP_INDEX),
/* harmony export */   SQLITE_DROP_TABLE: () => (/* binding */ SQLITE_DROP_TABLE),
/* harmony export */   SQLITE_DROP_TEMP_INDEX: () => (/* binding */ SQLITE_DROP_TEMP_INDEX),
/* harmony export */   SQLITE_DROP_TEMP_TABLE: () => (/* binding */ SQLITE_DROP_TEMP_TABLE),
/* harmony export */   SQLITE_DROP_TEMP_TRIGGER: () => (/* binding */ SQLITE_DROP_TEMP_TRIGGER),
/* harmony export */   SQLITE_DROP_TEMP_VIEW: () => (/* binding */ SQLITE_DROP_TEMP_VIEW),
/* harmony export */   SQLITE_DROP_TRIGGER: () => (/* binding */ SQLITE_DROP_TRIGGER),
/* harmony export */   SQLITE_DROP_VIEW: () => (/* binding */ SQLITE_DROP_VIEW),
/* harmony export */   SQLITE_DROP_VTABLE: () => (/* binding */ SQLITE_DROP_VTABLE),
/* harmony export */   SQLITE_EMPTY: () => (/* binding */ SQLITE_EMPTY),
/* harmony export */   SQLITE_ERROR: () => (/* binding */ SQLITE_ERROR),
/* harmony export */   SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: () => (/* binding */ SQLITE_FCNTL_BEGIN_ATOMIC_WRITE),
/* harmony export */   SQLITE_FCNTL_BUSYHANDLER: () => (/* binding */ SQLITE_FCNTL_BUSYHANDLER),
/* harmony export */   SQLITE_FCNTL_CHUNK_SIZE: () => (/* binding */ SQLITE_FCNTL_CHUNK_SIZE),
/* harmony export */   SQLITE_FCNTL_CKPT_DONE: () => (/* binding */ SQLITE_FCNTL_CKPT_DONE),
/* harmony export */   SQLITE_FCNTL_CKPT_START: () => (/* binding */ SQLITE_FCNTL_CKPT_START),
/* harmony export */   SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: () => (/* binding */ SQLITE_FCNTL_COMMIT_ATOMIC_WRITE),
/* harmony export */   SQLITE_FCNTL_COMMIT_PHASETWO: () => (/* binding */ SQLITE_FCNTL_COMMIT_PHASETWO),
/* harmony export */   SQLITE_FCNTL_DATA_VERSION: () => (/* binding */ SQLITE_FCNTL_DATA_VERSION),
/* harmony export */   SQLITE_FCNTL_FILE_POINTER: () => (/* binding */ SQLITE_FCNTL_FILE_POINTER),
/* harmony export */   SQLITE_FCNTL_GET_LOCKPROXYFILE: () => (/* binding */ SQLITE_FCNTL_GET_LOCKPROXYFILE),
/* harmony export */   SQLITE_FCNTL_HAS_MOVED: () => (/* binding */ SQLITE_FCNTL_HAS_MOVED),
/* harmony export */   SQLITE_FCNTL_JOURNAL_POINTER: () => (/* binding */ SQLITE_FCNTL_JOURNAL_POINTER),
/* harmony export */   SQLITE_FCNTL_LAST_ERRNO: () => (/* binding */ SQLITE_FCNTL_LAST_ERRNO),
/* harmony export */   SQLITE_FCNTL_LOCKSTATE: () => (/* binding */ SQLITE_FCNTL_LOCKSTATE),
/* harmony export */   SQLITE_FCNTL_LOCK_TIMEOUT: () => (/* binding */ SQLITE_FCNTL_LOCK_TIMEOUT),
/* harmony export */   SQLITE_FCNTL_MMAP_SIZE: () => (/* binding */ SQLITE_FCNTL_MMAP_SIZE),
/* harmony export */   SQLITE_FCNTL_OVERWRITE: () => (/* binding */ SQLITE_FCNTL_OVERWRITE),
/* harmony export */   SQLITE_FCNTL_PDB: () => (/* binding */ SQLITE_FCNTL_PDB),
/* harmony export */   SQLITE_FCNTL_PERSIST_WAL: () => (/* binding */ SQLITE_FCNTL_PERSIST_WAL),
/* harmony export */   SQLITE_FCNTL_POWERSAFE_OVERWRITE: () => (/* binding */ SQLITE_FCNTL_POWERSAFE_OVERWRITE),
/* harmony export */   SQLITE_FCNTL_PRAGMA: () => (/* binding */ SQLITE_FCNTL_PRAGMA),
/* harmony export */   SQLITE_FCNTL_RBU: () => (/* binding */ SQLITE_FCNTL_RBU),
/* harmony export */   SQLITE_FCNTL_RESERVE_BYTES: () => (/* binding */ SQLITE_FCNTL_RESERVE_BYTES),
/* harmony export */   SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: () => (/* binding */ SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE),
/* harmony export */   SQLITE_FCNTL_SET_LOCKPROXYFILE: () => (/* binding */ SQLITE_FCNTL_SET_LOCKPROXYFILE),
/* harmony export */   SQLITE_FCNTL_SIZE_HINT: () => (/* binding */ SQLITE_FCNTL_SIZE_HINT),
/* harmony export */   SQLITE_FCNTL_SIZE_LIMIT: () => (/* binding */ SQLITE_FCNTL_SIZE_LIMIT),
/* harmony export */   SQLITE_FCNTL_SYNC: () => (/* binding */ SQLITE_FCNTL_SYNC),
/* harmony export */   SQLITE_FCNTL_SYNC_OMITTED: () => (/* binding */ SQLITE_FCNTL_SYNC_OMITTED),
/* harmony export */   SQLITE_FCNTL_TEMPFILENAME: () => (/* binding */ SQLITE_FCNTL_TEMPFILENAME),
/* harmony export */   SQLITE_FCNTL_TRACE: () => (/* binding */ SQLITE_FCNTL_TRACE),
/* harmony export */   SQLITE_FCNTL_VFSNAME: () => (/* binding */ SQLITE_FCNTL_VFSNAME),
/* harmony export */   SQLITE_FCNTL_VFS_POINTER: () => (/* binding */ SQLITE_FCNTL_VFS_POINTER),
/* harmony export */   SQLITE_FCNTL_WAL_BLOCK: () => (/* binding */ SQLITE_FCNTL_WAL_BLOCK),
/* harmony export */   SQLITE_FCNTL_WIN32_AV_RETRY: () => (/* binding */ SQLITE_FCNTL_WIN32_AV_RETRY),
/* harmony export */   SQLITE_FCNTL_WIN32_GET_HANDLE: () => (/* binding */ SQLITE_FCNTL_WIN32_GET_HANDLE),
/* harmony export */   SQLITE_FCNTL_WIN32_SET_HANDLE: () => (/* binding */ SQLITE_FCNTL_WIN32_SET_HANDLE),
/* harmony export */   SQLITE_FCNTL_ZIPVFS: () => (/* binding */ SQLITE_FCNTL_ZIPVFS),
/* harmony export */   SQLITE_FLOAT: () => (/* binding */ SQLITE_FLOAT),
/* harmony export */   SQLITE_FORMAT: () => (/* binding */ SQLITE_FORMAT),
/* harmony export */   SQLITE_FULL: () => (/* binding */ SQLITE_FULL),
/* harmony export */   SQLITE_FUNCTION: () => (/* binding */ SQLITE_FUNCTION),
/* harmony export */   SQLITE_IGNORE: () => (/* binding */ SQLITE_IGNORE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_EQ: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_EQ),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_FUNCTION: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_FUNCTION),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_GE: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_GE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_GLOB: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_GLOB),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_GT: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_GT),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_IS: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_IS),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_ISNOT: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_ISNOT),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_ISNOTNULL: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_ISNOTNULL),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_ISNULL: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_ISNULL),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_LE: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_LE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_LIKE: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_LIKE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_LT: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_LT),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_MATCH: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_MATCH),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_NE: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_NE),
/* harmony export */   SQLITE_INDEX_CONSTRAINT_REGEXP: () => (/* binding */ SQLITE_INDEX_CONSTRAINT_REGEXP),
/* harmony export */   SQLITE_INDEX_SCAN_UNIQUE: () => (/* binding */ SQLITE_INDEX_SCAN_UNIQUE),
/* harmony export */   SQLITE_INNOCUOUS: () => (/* binding */ SQLITE_INNOCUOUS),
/* harmony export */   SQLITE_INSERT: () => (/* binding */ SQLITE_INSERT),
/* harmony export */   SQLITE_INTEGER: () => (/* binding */ SQLITE_INTEGER),
/* harmony export */   SQLITE_INTERNAL: () => (/* binding */ SQLITE_INTERNAL),
/* harmony export */   SQLITE_INTERRUPT: () => (/* binding */ SQLITE_INTERRUPT),
/* harmony export */   SQLITE_IOCAP_ATOMIC: () => (/* binding */ SQLITE_IOCAP_ATOMIC),
/* harmony export */   SQLITE_IOCAP_ATOMIC16K: () => (/* binding */ SQLITE_IOCAP_ATOMIC16K),
/* harmony export */   SQLITE_IOCAP_ATOMIC1K: () => (/* binding */ SQLITE_IOCAP_ATOMIC1K),
/* harmony export */   SQLITE_IOCAP_ATOMIC2K: () => (/* binding */ SQLITE_IOCAP_ATOMIC2K),
/* harmony export */   SQLITE_IOCAP_ATOMIC32K: () => (/* binding */ SQLITE_IOCAP_ATOMIC32K),
/* harmony export */   SQLITE_IOCAP_ATOMIC4K: () => (/* binding */ SQLITE_IOCAP_ATOMIC4K),
/* harmony export */   SQLITE_IOCAP_ATOMIC512: () => (/* binding */ SQLITE_IOCAP_ATOMIC512),
/* harmony export */   SQLITE_IOCAP_ATOMIC64K: () => (/* binding */ SQLITE_IOCAP_ATOMIC64K),
/* harmony export */   SQLITE_IOCAP_ATOMIC8K: () => (/* binding */ SQLITE_IOCAP_ATOMIC8K),
/* harmony export */   SQLITE_IOCAP_BATCH_ATOMIC: () => (/* binding */ SQLITE_IOCAP_BATCH_ATOMIC),
/* harmony export */   SQLITE_IOCAP_IMMUTABLE: () => (/* binding */ SQLITE_IOCAP_IMMUTABLE),
/* harmony export */   SQLITE_IOCAP_POWERSAFE_OVERWRITE: () => (/* binding */ SQLITE_IOCAP_POWERSAFE_OVERWRITE),
/* harmony export */   SQLITE_IOCAP_SAFE_APPEND: () => (/* binding */ SQLITE_IOCAP_SAFE_APPEND),
/* harmony export */   SQLITE_IOCAP_SEQUENTIAL: () => (/* binding */ SQLITE_IOCAP_SEQUENTIAL),
/* harmony export */   SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: () => (/* binding */ SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN),
/* harmony export */   SQLITE_IOERR: () => (/* binding */ SQLITE_IOERR),
/* harmony export */   SQLITE_IOERR_ACCESS: () => (/* binding */ SQLITE_IOERR_ACCESS),
/* harmony export */   SQLITE_IOERR_BEGIN_ATOMIC: () => (/* binding */ SQLITE_IOERR_BEGIN_ATOMIC),
/* harmony export */   SQLITE_IOERR_CHECKRESERVEDLOCK: () => (/* binding */ SQLITE_IOERR_CHECKRESERVEDLOCK),
/* harmony export */   SQLITE_IOERR_CLOSE: () => (/* binding */ SQLITE_IOERR_CLOSE),
/* harmony export */   SQLITE_IOERR_COMMIT_ATOMIC: () => (/* binding */ SQLITE_IOERR_COMMIT_ATOMIC),
/* harmony export */   SQLITE_IOERR_DATA: () => (/* binding */ SQLITE_IOERR_DATA),
/* harmony export */   SQLITE_IOERR_DELETE: () => (/* binding */ SQLITE_IOERR_DELETE),
/* harmony export */   SQLITE_IOERR_DELETE_NOENT: () => (/* binding */ SQLITE_IOERR_DELETE_NOENT),
/* harmony export */   SQLITE_IOERR_DIR_FSYNC: () => (/* binding */ SQLITE_IOERR_DIR_FSYNC),
/* harmony export */   SQLITE_IOERR_FSTAT: () => (/* binding */ SQLITE_IOERR_FSTAT),
/* harmony export */   SQLITE_IOERR_FSYNC: () => (/* binding */ SQLITE_IOERR_FSYNC),
/* harmony export */   SQLITE_IOERR_GETTEMPPATH: () => (/* binding */ SQLITE_IOERR_GETTEMPPATH),
/* harmony export */   SQLITE_IOERR_LOCK: () => (/* binding */ SQLITE_IOERR_LOCK),
/* harmony export */   SQLITE_IOERR_NOMEM: () => (/* binding */ SQLITE_IOERR_NOMEM),
/* harmony export */   SQLITE_IOERR_RDLOCK: () => (/* binding */ SQLITE_IOERR_RDLOCK),
/* harmony export */   SQLITE_IOERR_READ: () => (/* binding */ SQLITE_IOERR_READ),
/* harmony export */   SQLITE_IOERR_ROLLBACK_ATOMIC: () => (/* binding */ SQLITE_IOERR_ROLLBACK_ATOMIC),
/* harmony export */   SQLITE_IOERR_SEEK: () => (/* binding */ SQLITE_IOERR_SEEK),
/* harmony export */   SQLITE_IOERR_SHORT_READ: () => (/* binding */ SQLITE_IOERR_SHORT_READ),
/* harmony export */   SQLITE_IOERR_TRUNCATE: () => (/* binding */ SQLITE_IOERR_TRUNCATE),
/* harmony export */   SQLITE_IOERR_UNLOCK: () => (/* binding */ SQLITE_IOERR_UNLOCK),
/* harmony export */   SQLITE_IOERR_VNODE: () => (/* binding */ SQLITE_IOERR_VNODE),
/* harmony export */   SQLITE_IOERR_WRITE: () => (/* binding */ SQLITE_IOERR_WRITE),
/* harmony export */   SQLITE_LIMIT_ATTACHED: () => (/* binding */ SQLITE_LIMIT_ATTACHED),
/* harmony export */   SQLITE_LIMIT_COLUMN: () => (/* binding */ SQLITE_LIMIT_COLUMN),
/* harmony export */   SQLITE_LIMIT_COMPOUND_SELECT: () => (/* binding */ SQLITE_LIMIT_COMPOUND_SELECT),
/* harmony export */   SQLITE_LIMIT_EXPR_DEPTH: () => (/* binding */ SQLITE_LIMIT_EXPR_DEPTH),
/* harmony export */   SQLITE_LIMIT_FUNCTION_ARG: () => (/* binding */ SQLITE_LIMIT_FUNCTION_ARG),
/* harmony export */   SQLITE_LIMIT_LENGTH: () => (/* binding */ SQLITE_LIMIT_LENGTH),
/* harmony export */   SQLITE_LIMIT_LIKE_PATTERN_LENGTH: () => (/* binding */ SQLITE_LIMIT_LIKE_PATTERN_LENGTH),
/* harmony export */   SQLITE_LIMIT_SQL_LENGTH: () => (/* binding */ SQLITE_LIMIT_SQL_LENGTH),
/* harmony export */   SQLITE_LIMIT_TRIGGER_DEPTH: () => (/* binding */ SQLITE_LIMIT_TRIGGER_DEPTH),
/* harmony export */   SQLITE_LIMIT_VARIABLE_NUMBER: () => (/* binding */ SQLITE_LIMIT_VARIABLE_NUMBER),
/* harmony export */   SQLITE_LIMIT_VDBE_OP: () => (/* binding */ SQLITE_LIMIT_VDBE_OP),
/* harmony export */   SQLITE_LIMIT_WORKER_THREADS: () => (/* binding */ SQLITE_LIMIT_WORKER_THREADS),
/* harmony export */   SQLITE_LOCKED: () => (/* binding */ SQLITE_LOCKED),
/* harmony export */   SQLITE_LOCK_EXCLUSIVE: () => (/* binding */ SQLITE_LOCK_EXCLUSIVE),
/* harmony export */   SQLITE_LOCK_NONE: () => (/* binding */ SQLITE_LOCK_NONE),
/* harmony export */   SQLITE_LOCK_PENDING: () => (/* binding */ SQLITE_LOCK_PENDING),
/* harmony export */   SQLITE_LOCK_RESERVED: () => (/* binding */ SQLITE_LOCK_RESERVED),
/* harmony export */   SQLITE_LOCK_SHARED: () => (/* binding */ SQLITE_LOCK_SHARED),
/* harmony export */   SQLITE_MISMATCH: () => (/* binding */ SQLITE_MISMATCH),
/* harmony export */   SQLITE_MISUSE: () => (/* binding */ SQLITE_MISUSE),
/* harmony export */   SQLITE_NOLFS: () => (/* binding */ SQLITE_NOLFS),
/* harmony export */   SQLITE_NOMEM: () => (/* binding */ SQLITE_NOMEM),
/* harmony export */   SQLITE_NOTADB: () => (/* binding */ SQLITE_NOTADB),
/* harmony export */   SQLITE_NOTFOUND: () => (/* binding */ SQLITE_NOTFOUND),
/* harmony export */   SQLITE_NOTICE: () => (/* binding */ SQLITE_NOTICE),
/* harmony export */   SQLITE_NULL: () => (/* binding */ SQLITE_NULL),
/* harmony export */   SQLITE_OK: () => (/* binding */ SQLITE_OK),
/* harmony export */   SQLITE_OPEN_AUTOPROXY: () => (/* binding */ SQLITE_OPEN_AUTOPROXY),
/* harmony export */   SQLITE_OPEN_CREATE: () => (/* binding */ SQLITE_OPEN_CREATE),
/* harmony export */   SQLITE_OPEN_DELETEONCLOSE: () => (/* binding */ SQLITE_OPEN_DELETEONCLOSE),
/* harmony export */   SQLITE_OPEN_EXCLUSIVE: () => (/* binding */ SQLITE_OPEN_EXCLUSIVE),
/* harmony export */   SQLITE_OPEN_FULLMUTEX: () => (/* binding */ SQLITE_OPEN_FULLMUTEX),
/* harmony export */   SQLITE_OPEN_MAIN_DB: () => (/* binding */ SQLITE_OPEN_MAIN_DB),
/* harmony export */   SQLITE_OPEN_MAIN_JOURNAL: () => (/* binding */ SQLITE_OPEN_MAIN_JOURNAL),
/* harmony export */   SQLITE_OPEN_MEMORY: () => (/* binding */ SQLITE_OPEN_MEMORY),
/* harmony export */   SQLITE_OPEN_NOFOLLOW: () => (/* binding */ SQLITE_OPEN_NOFOLLOW),
/* harmony export */   SQLITE_OPEN_NOMUTEX: () => (/* binding */ SQLITE_OPEN_NOMUTEX),
/* harmony export */   SQLITE_OPEN_PRIVATECACHE: () => (/* binding */ SQLITE_OPEN_PRIVATECACHE),
/* harmony export */   SQLITE_OPEN_READONLY: () => (/* binding */ SQLITE_OPEN_READONLY),
/* harmony export */   SQLITE_OPEN_READWRITE: () => (/* binding */ SQLITE_OPEN_READWRITE),
/* harmony export */   SQLITE_OPEN_SHAREDCACHE: () => (/* binding */ SQLITE_OPEN_SHAREDCACHE),
/* harmony export */   SQLITE_OPEN_SUBJOURNAL: () => (/* binding */ SQLITE_OPEN_SUBJOURNAL),
/* harmony export */   SQLITE_OPEN_SUPER_JOURNAL: () => (/* binding */ SQLITE_OPEN_SUPER_JOURNAL),
/* harmony export */   SQLITE_OPEN_TEMP_DB: () => (/* binding */ SQLITE_OPEN_TEMP_DB),
/* harmony export */   SQLITE_OPEN_TEMP_JOURNAL: () => (/* binding */ SQLITE_OPEN_TEMP_JOURNAL),
/* harmony export */   SQLITE_OPEN_TRANSIENT_DB: () => (/* binding */ SQLITE_OPEN_TRANSIENT_DB),
/* harmony export */   SQLITE_OPEN_URI: () => (/* binding */ SQLITE_OPEN_URI),
/* harmony export */   SQLITE_OPEN_WAL: () => (/* binding */ SQLITE_OPEN_WAL),
/* harmony export */   SQLITE_PERM: () => (/* binding */ SQLITE_PERM),
/* harmony export */   SQLITE_PRAGMA: () => (/* binding */ SQLITE_PRAGMA),
/* harmony export */   SQLITE_PREPARE_NORMALIZED: () => (/* binding */ SQLITE_PREPARE_NORMALIZED),
/* harmony export */   SQLITE_PREPARE_NO_VTAB: () => (/* binding */ SQLITE_PREPARE_NO_VTAB),
/* harmony export */   SQLITE_PREPARE_PERSISTENT: () => (/* binding */ SQLITE_PREPARE_PERSISTENT),
/* harmony export */   SQLITE_PROTOCOL: () => (/* binding */ SQLITE_PROTOCOL),
/* harmony export */   SQLITE_RANGE: () => (/* binding */ SQLITE_RANGE),
/* harmony export */   SQLITE_READ: () => (/* binding */ SQLITE_READ),
/* harmony export */   SQLITE_READONLY: () => (/* binding */ SQLITE_READONLY),
/* harmony export */   SQLITE_RECURSIVE: () => (/* binding */ SQLITE_RECURSIVE),
/* harmony export */   SQLITE_REINDEX: () => (/* binding */ SQLITE_REINDEX),
/* harmony export */   SQLITE_ROW: () => (/* binding */ SQLITE_ROW),
/* harmony export */   SQLITE_SAVEPOINT: () => (/* binding */ SQLITE_SAVEPOINT),
/* harmony export */   SQLITE_SCHEMA: () => (/* binding */ SQLITE_SCHEMA),
/* harmony export */   SQLITE_SELECT: () => (/* binding */ SQLITE_SELECT),
/* harmony export */   SQLITE_STATIC: () => (/* binding */ SQLITE_STATIC),
/* harmony export */   SQLITE_SUBTYPE: () => (/* binding */ SQLITE_SUBTYPE),
/* harmony export */   SQLITE_SYNC_DATAONLY: () => (/* binding */ SQLITE_SYNC_DATAONLY),
/* harmony export */   SQLITE_SYNC_FULL: () => (/* binding */ SQLITE_SYNC_FULL),
/* harmony export */   SQLITE_SYNC_NORMAL: () => (/* binding */ SQLITE_SYNC_NORMAL),
/* harmony export */   SQLITE_TEXT: () => (/* binding */ SQLITE_TEXT),
/* harmony export */   SQLITE_TOOBIG: () => (/* binding */ SQLITE_TOOBIG),
/* harmony export */   SQLITE_TRANSACTION: () => (/* binding */ SQLITE_TRANSACTION),
/* harmony export */   SQLITE_TRANSIENT: () => (/* binding */ SQLITE_TRANSIENT),
/* harmony export */   SQLITE_UPDATE: () => (/* binding */ SQLITE_UPDATE),
/* harmony export */   SQLITE_UTF16: () => (/* binding */ SQLITE_UTF16),
/* harmony export */   SQLITE_UTF16BE: () => (/* binding */ SQLITE_UTF16BE),
/* harmony export */   SQLITE_UTF16LE: () => (/* binding */ SQLITE_UTF16LE),
/* harmony export */   SQLITE_UTF8: () => (/* binding */ SQLITE_UTF8),
/* harmony export */   SQLITE_WARNING: () => (/* binding */ SQLITE_WARNING)
/* harmony export */ });
// Primary result codes.
// https://www.sqlite.org/rescode.html
const SQLITE_OK = 0;
const SQLITE_ERROR = 1;
const SQLITE_INTERNAL = 2;
const SQLITE_PERM = 3;
const SQLITE_ABORT = 4;
const SQLITE_BUSY = 5;
const SQLITE_LOCKED = 6;
const SQLITE_NOMEM = 7;
const SQLITE_READONLY = 8;
const SQLITE_INTERRUPT = 9;
const SQLITE_IOERR = 10;
const SQLITE_CORRUPT = 11;
const SQLITE_NOTFOUND = 12;
const SQLITE_FULL = 13;
const SQLITE_CANTOPEN = 14;
const SQLITE_PROTOCOL = 15;
const SQLITE_EMPTY = 16;
const SQLITE_SCHEMA = 17;
const SQLITE_TOOBIG = 18;
const SQLITE_CONSTRAINT = 19;
const SQLITE_MISMATCH = 20;
const SQLITE_MISUSE = 21;
const SQLITE_NOLFS = 22;
const SQLITE_AUTH = 23;
const SQLITE_FORMAT = 24;
const SQLITE_RANGE = 25;
const SQLITE_NOTADB = 26;
const SQLITE_NOTICE = 27;
const SQLITE_WARNING = 28;
const SQLITE_ROW = 100;
const SQLITE_DONE = 101;

// Extended error codes.
const SQLITE_IOERR_ACCESS = 3338;
const SQLITE_IOERR_CHECKRESERVEDLOCK = 3594;
const SQLITE_IOERR_CLOSE = 4106;
const SQLITE_IOERR_DATA = 8202;
const SQLITE_IOERR_DELETE = 2570;
const SQLITE_IOERR_DELETE_NOENT = 5898;
const SQLITE_IOERR_DIR_FSYNC = 1290;
const SQLITE_IOERR_FSTAT = 1802;
const SQLITE_IOERR_FSYNC = 1034;
const SQLITE_IOERR_GETTEMPPATH = 6410;
const SQLITE_IOERR_LOCK = 3850;
const SQLITE_IOERR_NOMEM = 3082;
const SQLITE_IOERR_READ = 266;
const SQLITE_IOERR_RDLOCK = 2314;
const SQLITE_IOERR_SEEK = 5642;
const SQLITE_IOERR_SHORT_READ = 522;
const SQLITE_IOERR_TRUNCATE = 1546;
const SQLITE_IOERR_UNLOCK = 2058;
const SQLITE_IOERR_VNODE = 6922;
const SQLITE_IOERR_WRITE = 778;
const SQLITE_IOERR_BEGIN_ATOMIC = 7434;
const SQLITE_IOERR_COMMIT_ATOMIC = 7690;
const SQLITE_IOERR_ROLLBACK_ATOMIC = 7946;

// Other extended result codes.
const SQLITE_CONSTRAINT_CHECK = 275;
const SQLITE_CONSTRAINT_COMMITHOOK = 531;
const SQLITE_CONSTRAINT_FOREIGNKEY = 787;
const SQLITE_CONSTRAINT_FUNCTION = 1043;
const SQLITE_CONSTRAINT_NOTNULL = 1299;
const SQLITE_CONSTRAINT_PINNED = 2835;
const SQLITE_CONSTRAINT_PRIMARYKEY = 1555;
const SQLITE_CONSTRAINT_ROWID = 2579;
const SQLITE_CONSTRAINT_TRIGGER = 1811;
const SQLITE_CONSTRAINT_UNIQUE = 2067;
const SQLITE_CONSTRAINT_VTAB = 2323;

// Open flags.
// https://www.sqlite.org/c3ref/c_open_autoproxy.html
const SQLITE_OPEN_READONLY = 0x00000001;
const SQLITE_OPEN_READWRITE = 0x00000002;
const SQLITE_OPEN_CREATE = 0x00000004;
const SQLITE_OPEN_DELETEONCLOSE = 0x00000008;
const SQLITE_OPEN_EXCLUSIVE = 0x00000010;
const SQLITE_OPEN_AUTOPROXY = 0x00000020;
const SQLITE_OPEN_URI = 0x00000040;
const SQLITE_OPEN_MEMORY = 0x00000080;
const SQLITE_OPEN_MAIN_DB = 0x00000100;
const SQLITE_OPEN_TEMP_DB = 0x00000200;
const SQLITE_OPEN_TRANSIENT_DB = 0x00000400;
const SQLITE_OPEN_MAIN_JOURNAL = 0x00000800;
const SQLITE_OPEN_TEMP_JOURNAL = 0x00001000;
const SQLITE_OPEN_SUBJOURNAL = 0x00002000;
const SQLITE_OPEN_SUPER_JOURNAL = 0x00004000;
const SQLITE_OPEN_NOMUTEX = 0x00008000;
const SQLITE_OPEN_FULLMUTEX = 0x00010000;
const SQLITE_OPEN_SHAREDCACHE = 0x00020000;
const SQLITE_OPEN_PRIVATECACHE = 0x00040000;
const SQLITE_OPEN_WAL = 0x00080000;
const SQLITE_OPEN_NOFOLLOW = 0x01000000;

// Locking levels.
// https://www.sqlite.org/c3ref/c_lock_exclusive.html
const SQLITE_LOCK_NONE = 0;
const SQLITE_LOCK_SHARED = 1;
const SQLITE_LOCK_RESERVED = 2;
const SQLITE_LOCK_PENDING = 3;
const SQLITE_LOCK_EXCLUSIVE = 4;

// Device characteristics.
// https://www.sqlite.org/c3ref/c_iocap_atomic.html
const SQLITE_IOCAP_ATOMIC = 0x00000001;
const SQLITE_IOCAP_ATOMIC512 = 0x00000002;
const SQLITE_IOCAP_ATOMIC1K = 0x00000004;
const SQLITE_IOCAP_ATOMIC2K = 0x00000008;
const SQLITE_IOCAP_ATOMIC4K = 0x00000010;
const SQLITE_IOCAP_ATOMIC8K = 0x00000020;
const SQLITE_IOCAP_ATOMIC16K = 0x00000040;
const SQLITE_IOCAP_ATOMIC32K = 0x00000080;
const SQLITE_IOCAP_ATOMIC64K = 0x00000100;
const SQLITE_IOCAP_SAFE_APPEND = 0x00000200;
const SQLITE_IOCAP_SEQUENTIAL = 0x00000400;
const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN = 0x00000800;
const SQLITE_IOCAP_POWERSAFE_OVERWRITE = 0x00001000;
const SQLITE_IOCAP_IMMUTABLE = 0x00002000;
const SQLITE_IOCAP_BATCH_ATOMIC = 0x00004000;

// xAccess flags.
// https://www.sqlite.org/c3ref/c_access_exists.html
const SQLITE_ACCESS_EXISTS = 0;
const SQLITE_ACCESS_READWRITE = 1;
const SQLITE_ACCESS_READ = 2;

// File control opcodes
// https://www.sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlbeginatomicwrite
const SQLITE_FCNTL_LOCKSTATE = 1; 
const SQLITE_FCNTL_GET_LOCKPROXYFILE = 2; 
const SQLITE_FCNTL_SET_LOCKPROXYFILE = 3; 
const SQLITE_FCNTL_LAST_ERRNO = 4; 
const SQLITE_FCNTL_SIZE_HINT = 5; 
const SQLITE_FCNTL_CHUNK_SIZE = 6; 
const SQLITE_FCNTL_FILE_POINTER = 7; 
const SQLITE_FCNTL_SYNC_OMITTED = 8; 
const SQLITE_FCNTL_WIN32_AV_RETRY = 9; 
const SQLITE_FCNTL_PERSIST_WAL = 10; 
const SQLITE_FCNTL_OVERWRITE = 11; 
const SQLITE_FCNTL_VFSNAME = 12; 
const SQLITE_FCNTL_POWERSAFE_OVERWRITE = 13; 
const SQLITE_FCNTL_PRAGMA = 14; 
const SQLITE_FCNTL_BUSYHANDLER = 15; 
const SQLITE_FCNTL_TEMPFILENAME = 16; 
const SQLITE_FCNTL_MMAP_SIZE = 18; 
const SQLITE_FCNTL_TRACE = 19; 
const SQLITE_FCNTL_HAS_MOVED = 20; 
const SQLITE_FCNTL_SYNC = 21; 
const SQLITE_FCNTL_COMMIT_PHASETWO = 22; 
const SQLITE_FCNTL_WIN32_SET_HANDLE = 23; 
const SQLITE_FCNTL_WAL_BLOCK = 24; 
const SQLITE_FCNTL_ZIPVFS = 25; 
const SQLITE_FCNTL_RBU = 26; 
const SQLITE_FCNTL_VFS_POINTER = 27; 
const SQLITE_FCNTL_JOURNAL_POINTER = 28; 
const SQLITE_FCNTL_WIN32_GET_HANDLE = 29; 
const SQLITE_FCNTL_PDB = 30; 
const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE = 31; 
const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE = 32; 
const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE = 33; 
const SQLITE_FCNTL_LOCK_TIMEOUT = 34; 
const SQLITE_FCNTL_DATA_VERSION = 35; 
const SQLITE_FCNTL_SIZE_LIMIT = 36; 
const SQLITE_FCNTL_CKPT_DONE = 37; 
const SQLITE_FCNTL_RESERVE_BYTES = 38; 
const SQLITE_FCNTL_CKPT_START = 39;

// Fundamental datatypes.
// https://www.sqlite.org/c3ref/c_blob.html
const SQLITE_INTEGER = 1;
const SQLITE_FLOAT = 2;
const SQLITE_TEXT = 3;
const SQLITE_BLOB = 4;
const SQLITE_NULL = 5;

// Special destructor behavior.
// https://www.sqlite.org/c3ref/c_static.html
const SQLITE_STATIC = 0;
const SQLITE_TRANSIENT = -1;

// Text encodings.
// https://sqlite.org/c3ref/c_any.html
const SQLITE_UTF8 = 1;     /* IMP: R-37514-35566 */
const SQLITE_UTF16LE = 2;  /* IMP: R-03371-37637 */
const SQLITE_UTF16BE = 3;  /* IMP: R-51971-34154 */
const SQLITE_UTF16 = 4;    /* Use native byte order */

// Module constraint ops.
const SQLITE_INDEX_CONSTRAINT_EQ        = 2;
const SQLITE_INDEX_CONSTRAINT_GT        = 4;
const SQLITE_INDEX_CONSTRAINT_LE        = 8;
const SQLITE_INDEX_CONSTRAINT_LT        = 16;
const SQLITE_INDEX_CONSTRAINT_GE        = 32;
const SQLITE_INDEX_CONSTRAINT_MATCH     = 64;
const SQLITE_INDEX_CONSTRAINT_LIKE      = 65;
const SQLITE_INDEX_CONSTRAINT_GLOB      = 66;
const SQLITE_INDEX_CONSTRAINT_REGEXP    = 67;
const SQLITE_INDEX_CONSTRAINT_NE        = 68;
const SQLITE_INDEX_CONSTRAINT_ISNOT     = 69;
const SQLITE_INDEX_CONSTRAINT_ISNOTNULL = 70;
const SQLITE_INDEX_CONSTRAINT_ISNULL    = 71;
const SQLITE_INDEX_CONSTRAINT_IS        = 72;
const SQLITE_INDEX_CONSTRAINT_FUNCTION  = 150;
const SQLITE_INDEX_SCAN_UNIQUE          = 1;  /* Scan visits at most = 1 row */

// Function flags
const SQLITE_DETERMINISTIC = 0x000000800;
const SQLITE_DIRECTONLY    = 0x000080000;
const SQLITE_SUBTYPE       = 0x000100000;
const SQLITE_INNOCUOUS     = 0x000200000;

// Sync flags
const SQLITE_SYNC_NORMAL   = 0x00002;
const SQLITE_SYNC_FULL     = 0x00003;
const SQLITE_SYNC_DATAONLY = 0x00010;

// Authorizer action codes
const SQLITE_CREATE_INDEX        = 1;
const SQLITE_CREATE_TABLE        = 2;
const SQLITE_CREATE_TEMP_INDEX   = 3;
const SQLITE_CREATE_TEMP_TABLE   = 4;
const SQLITE_CREATE_TEMP_TRIGGER = 5;
const SQLITE_CREATE_TEMP_VIEW    = 6;
const SQLITE_CREATE_TRIGGER      = 7;
const SQLITE_CREATE_VIEW         = 8;
const SQLITE_DELETE              = 9;
const SQLITE_DROP_INDEX          = 10;
const SQLITE_DROP_TABLE          = 11;
const SQLITE_DROP_TEMP_INDEX     = 12;
const SQLITE_DROP_TEMP_TABLE     = 13;
const SQLITE_DROP_TEMP_TRIGGER   = 14;
const SQLITE_DROP_TEMP_VIEW      = 15;
const SQLITE_DROP_TRIGGER        = 16;
const SQLITE_DROP_VIEW           = 17;
const SQLITE_INSERT              = 18;
const SQLITE_PRAGMA              = 19;
const SQLITE_READ                = 20;
const SQLITE_SELECT              = 21;
const SQLITE_TRANSACTION         = 22;
const SQLITE_UPDATE              = 23;
const SQLITE_ATTACH              = 24;
const SQLITE_DETACH              = 25;
const SQLITE_ALTER_TABLE         = 26;
const SQLITE_REINDEX             = 27;
const SQLITE_ANALYZE             = 28;
const SQLITE_CREATE_VTABLE       = 29;
const SQLITE_DROP_VTABLE         = 30;
const SQLITE_FUNCTION            = 31;
const SQLITE_SAVEPOINT           = 32;
const SQLITE_COPY                = 0;
const SQLITE_RECURSIVE           = 33;

// Authorizer return codes
const SQLITE_DENY   = 1;
const SQLITE_IGNORE = 2;

// Limit categories
const SQLITE_LIMIT_LENGTH              = 0;
const SQLITE_LIMIT_SQL_LENGTH          = 1;
const SQLITE_LIMIT_COLUMN              = 2;
const SQLITE_LIMIT_EXPR_DEPTH          = 3;
const SQLITE_LIMIT_COMPOUND_SELECT     = 4;
const SQLITE_LIMIT_VDBE_OP             = 5;
const SQLITE_LIMIT_FUNCTION_ARG        = 6;
const SQLITE_LIMIT_ATTACHED            = 7;
const SQLITE_LIMIT_LIKE_PATTERN_LENGTH = 8;
const SQLITE_LIMIT_VARIABLE_NUMBER     = 9;
const SQLITE_LIMIT_TRIGGER_DEPTH       = 10;
const SQLITE_LIMIT_WORKER_THREADS      = 11;

const SQLITE_PREPARE_PERSISTENT = 0x01;
const SQLITE_PREPARE_NORMALIZED = 0x02;
const SQLITE_PREPARE_NO_VTAB = 0x04;

/***/ }),

/***/ "../../node_modules/async-mutex/index.mjs":
/*!************************************************!*\
  !*** ../../node_modules/async-mutex/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E_ALREADY_LOCKED: () => (/* binding */ E_ALREADY_LOCKED),
/* harmony export */   E_CANCELED: () => (/* binding */ E_CANCELED),
/* harmony export */   E_TIMEOUT: () => (/* binding */ E_TIMEOUT),
/* harmony export */   Mutex: () => (/* binding */ Mutex),
/* harmony export */   Semaphore: () => (/* binding */ Semaphore),
/* harmony export */   tryAcquire: () => (/* binding */ tryAcquire),
/* harmony export */   withTimeout: () => (/* binding */ withTimeout)
/* harmony export */ });
const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');
const E_ALREADY_LOCKED = new Error('mutex already locked');
const E_CANCELED = new Error('request for lock canceled');

var __awaiter$2 = ( false) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Semaphore {
    constructor(_value, _cancelError = E_CANCELED) {
        this._value = _value;
        this._cancelError = _cancelError;
        this._queue = [];
        this._weightedWaiters = [];
    }
    acquire(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        return new Promise((resolve, reject) => {
            const task = { resolve, reject, weight, priority };
            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
            if (i === -1 && weight <= this._value) {
                // Needs immediate dispatch, skip the queue
                this._dispatchItem(task);
            }
            else {
                this._queue.splice(i + 1, 0, task);
            }
        });
    }
    runExclusive(callback_1) {
        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
            const [value, release] = yield this.acquire(weight, priority);
            try {
                return yield callback(value);
            }
            finally {
                release();
            }
        });
    }
    waitForUnlock(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        if (this._couldLockImmediately(weight, priority)) {
            return Promise.resolve();
        }
        else {
            return new Promise((resolve) => {
                if (!this._weightedWaiters[weight - 1])
                    this._weightedWaiters[weight - 1] = [];
                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
            });
        }
    }
    isLocked() {
        return this._value <= 0;
    }
    getValue() {
        return this._value;
    }
    setValue(value) {
        this._value = value;
        this._dispatchQueue();
    }
    release(weight = 1) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        this._value += weight;
        this._dispatchQueue();
    }
    cancel() {
        this._queue.forEach((entry) => entry.reject(this._cancelError));
        this._queue = [];
    }
    _dispatchQueue() {
        this._drainUnlockWaiters();
        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
            this._dispatchItem(this._queue.shift());
            this._drainUnlockWaiters();
        }
    }
    _dispatchItem(item) {
        const previousValue = this._value;
        this._value -= item.weight;
        item.resolve([previousValue, this._newReleaser(item.weight)]);
    }
    _newReleaser(weight) {
        let called = false;
        return () => {
            if (called)
                return;
            called = true;
            this.release(weight);
        };
    }
    _drainUnlockWaiters() {
        if (this._queue.length === 0) {
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                waiters.forEach((waiter) => waiter.resolve());
                this._weightedWaiters[weight - 1] = [];
            }
        }
        else {
            const queuedPriority = this._queue[0].priority;
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
                (i === -1 ? waiters : waiters.splice(0, i))
                    .forEach((waiter => waiter.resolve()));
            }
        }
    }
    _couldLockImmediately(weight, priority) {
        return (this._queue.length === 0 || this._queue[0].priority < priority) &&
            weight <= this._value;
    }
}
function insertSorted(a, v) {
    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
    a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
    for (let i = a.length - 1; i >= 0; i--) {
        if (predicate(a[i])) {
            return i;
        }
    }
    return -1;
}

var __awaiter$1 = ( false) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Mutex {
    constructor(cancelError) {
        this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
            const [, releaser] = yield this._semaphore.acquire(1, priority);
            return releaser;
        });
    }
    runExclusive(callback, priority = 0) {
        return this._semaphore.runExclusive(() => callback(), 1, priority);
    }
    isLocked() {
        return this._semaphore.isLocked();
    }
    waitForUnlock(priority = 0) {
        return this._semaphore.waitForUnlock(1, priority);
    }
    release() {
        if (this._semaphore.isLocked())
            this._semaphore.release();
    }
    cancel() {
        return this._semaphore.cancel();
    }
}

var __awaiter = ( false) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {
    return {
        acquire: (weightOrPriority, priority) => {
            let weight;
            if (isSemaphore(sync)) {
                weight = weightOrPriority;
            }
            else {
                weight = undefined;
                priority = weightOrPriority;
            }
            if (weight !== undefined && weight <= 0) {
                throw new Error(`invalid weight ${weight}: must be positive`);
            }
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let isTimeout = false;
                const handle = setTimeout(() => {
                    isTimeout = true;
                    reject(timeoutError);
                }, timeout);
                try {
                    const ticket = yield (isSemaphore(sync)
                        ? sync.acquire(weight, priority)
                        : sync.acquire(priority));
                    if (isTimeout) {
                        const release = Array.isArray(ticket) ? ticket[1] : ticket;
                        release();
                    }
                    else {
                        clearTimeout(handle);
                        resolve(ticket);
                    }
                }
                catch (e) {
                    if (!isTimeout) {
                        clearTimeout(handle);
                        reject(e);
                    }
                }
            }));
        },
        runExclusive(callback, weight, priority) {
            return __awaiter(this, void 0, void 0, function* () {
                let release = () => undefined;
                try {
                    const ticket = yield this.acquire(weight, priority);
                    if (Array.isArray(ticket)) {
                        release = ticket[1];
                        return yield callback(ticket[0]);
                    }
                    else {
                        release = ticket;
                        return yield callback();
                    }
                }
                finally {
                    release();
                }
            });
        },
        release(weight) {
            sync.release(weight);
        },
        cancel() {
            return sync.cancel();
        },
        waitForUnlock: (weightOrPriority, priority) => {
            let weight;
            if (isSemaphore(sync)) {
                weight = weightOrPriority;
            }
            else {
                weight = undefined;
                priority = weightOrPriority;
            }
            if (weight !== undefined && weight <= 0) {
                throw new Error(`invalid weight ${weight}: must be positive`);
            }
            return new Promise((resolve, reject) => {
                const handle = setTimeout(() => reject(timeoutError), timeout);
                (isSemaphore(sync)
                    ? sync.waitForUnlock(weight, priority)
                    : sync.waitForUnlock(priority)).then(() => {
                    clearTimeout(handle);
                    resolve();
                });
            });
        },
        isLocked: () => sync.isLocked(),
        getValue: () => sync.getValue(),
        setValue: (value) => sync.setValue(value),
    };
}
function isSemaphore(sync) {
    return sync.getValue !== undefined;
}

// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types
function tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return withTimeout(sync, 0, alreadyAcquiredError);
}




/***/ }),

/***/ "../../node_modules/comlink/dist/esm/comlink.mjs":
/*!*******************************************************!*\
  !*** ../../node_modules/comlink/dist/esm/comlink.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),
/* harmony export */   expose: () => (/* binding */ expose),
/* harmony export */   finalizer: () => (/* binding */ finalizer),
/* harmony export */   proxy: () => (/* binding */ proxy),
/* harmony export */   proxyMarker: () => (/* binding */ proxyMarker),
/* harmony export */   releaseProxy: () => (/* binding */ releaseProxy),
/* harmony export */   transfer: () => (/* binding */ transfer),
/* harmony export */   transferHandlers: () => (/* binding */ transferHandlers),
/* harmony export */   windowEndpoint: () => (/* binding */ windowEndpoint),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const finalizer = Symbol("Comlink.finalizer");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";
/**
 * Internal transfer handle to handle objects marked to proxy.
 */
const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
        const { port1, port2 } = new MessageChannel();
        expose(obj, port1);
        return [port2, [port2]];
    },
    deserialize(port) {
        port.start();
        return wrap(port);
    },
};
/**
 * Internal transfer handler to handle thrown exceptions.
 */
const throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack,
                },
            };
        }
        else {
            serialized = { isError: false, value };
        }
        return [serialized, []];
    },
    deserialize(serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    },
};
/**
 * Allows customizing the serialization of certain values.
 */
const transferHandlers = new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler],
]);
function isAllowedOrigin(allowedOrigins, origin) {
    for (const allowedOrigin of allowedOrigins) {
        if (origin === allowedOrigin || allowedOrigin === "*") {
            return true;
        }
        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
            return true;
        }
    }
    return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
        if (!ev || !ev.data) {
            return;
        }
        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
            return;
        }
        const { id, type, path } = Object.assign({ path: [] }, ev.data);
        const argumentList = (ev.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);
            const rawValue = path.reduce((obj, prop) => obj[prop], obj);
            switch (type) {
                case "GET" /* MessageType.GET */:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case "SET" /* MessageType.SET */:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;
                case "APPLY" /* MessageType.APPLY */:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case "CONSTRUCT" /* MessageType.CONSTRUCT */:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case "ENDPOINT" /* MessageType.ENDPOINT */:
                    {
                        const { port1, port2 } = new MessageChannel();
                        expose(obj, port2);
                        returnValue = transfer(port1, [port1]);
                    }
                    break;
                case "RELEASE" /* MessageType.RELEASE */:
                    {
                        returnValue = undefined;
                    }
                    break;
                default:
                    return;
            }
        }
        catch (value) {
            returnValue = { value, [throwMarker]: 0 };
        }
        Promise.resolve(returnValue)
            .catch((value) => {
            return { value, [throwMarker]: 0 };
        })
            .then((returnValue) => {
            const [wireValue, transferables] = toWireValue(returnValue);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === "RELEASE" /* MessageType.RELEASE */) {
                // detach and deactive after sending release response above.
                ep.removeEventListener("message", callback);
                closeEndPoint(ep);
                if (finalizer in obj && typeof obj[finalizer] === "function") {
                    obj[finalizer]();
                }
            }
        })
            .catch((error) => {
            // Send Serialization Error To Caller
            const [wireValue, transferables] = toWireValue({
                value: new TypeError("Unserializable return value"),
                [throwMarker]: 0,
            });
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
        });
    });
    if (ep.start) {
        ep.start();
    }
}
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
        endpoint.close();
}
function wrap(ep, target) {
    const pendingListeners = new Map();
    ep.addEventListener("message", function handleMessage(ev) {
        const { data } = ev;
        if (!data || !data.id) {
            return;
        }
        const resolver = pendingListeners.get(data.id);
        if (!resolver) {
            return;
        }
        try {
            resolver(data);
        }
        finally {
            pendingListeners.delete(data.id);
        }
    });
    return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function releaseEndpoint(ep) {
    return requestResponseMessage(ep, new Map(), {
        type: "RELEASE" /* MessageType.RELEASE */,
    }).then(() => {
        closeEndPoint(ep);
    });
}
const proxyCounter = new WeakMap();
const proxyFinalizers = "FinalizationRegistry" in globalThis &&
    new FinalizationRegistry((ep) => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
            releaseEndpoint(ep);
        }
    });
function registerProxy(proxy, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
        proxyFinalizers.register(proxy, ep, proxy);
    }
}
function unregisterProxy(proxy) {
    if (proxyFinalizers) {
        proxyFinalizers.unregister(proxy);
    }
}
function createProxy(ep, pendingListeners, path = [], target = function () { }) {
    let isProxyReleased = false;
    const proxy = new Proxy(target, {
        get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return () => {
                    unregisterProxy(proxy);
                    releaseEndpoint(ep);
                    pendingListeners.clear();
                    isProxyReleased = true;
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return { then: () => proxy };
                }
                const r = requestResponseMessage(ep, pendingListeners, {
                    type: "GET" /* MessageType.GET */,
                    path: path.map((p) => p.toString()),
                }).then(fromWireValue);
                return r.then.bind(r);
            }
            return createProxy(ep, pendingListeners, [...path, prop]);
        },
        set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a
            // boolean. To show good will, we return true asynchronously Â¯\_(ãƒ„)_/Â¯
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, pendingListeners, {
                type: "SET" /* MessageType.SET */,
                path: [...path, prop].map((p) => p.toString()),
                value,
            }, transferables).then(fromWireValue);
        },
        apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep, pendingListeners, {
                    type: "ENDPOINT" /* MessageType.ENDPOINT */,
                }).then(fromWireValue);
            }
            // We just pretend that `bind()` didnâ€™t happen.
            if (last === "bind") {
                return createProxy(ep, pendingListeners, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, pendingListeners, {
                type: "APPLY" /* MessageType.APPLY */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
        construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, pendingListeners, {
                type: "CONSTRUCT" /* MessageType.CONSTRUCT */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
    });
    registerProxy(proxy, ep);
    return proxy;
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
}
function windowEndpoint(w, context = globalThis, targetOrigin = "*") {
    return {
        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
        addEventListener: context.addEventListener.bind(context),
        removeEventListener: context.removeEventListener.bind(context),
    };
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: "HANDLER" /* WireValueType.HANDLER */,
                    name,
                    value: serializedValue,
                },
                transferables,
            ];
        }
    }
    return [
        {
            type: "RAW" /* WireValueType.RAW */,
            value,
        },
        transferCache.get(value) || [],
    ];
}
function fromWireValue(value) {
    switch (value.type) {
        case "HANDLER" /* WireValueType.HANDLER */:
            return transferHandlers.get(value.name).deserialize(value.value);
        case "RAW" /* WireValueType.RAW */:
            return value.value;
    }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
    return new Promise((resolve) => {
        const id = generateUUID();
        pendingListeners.set(id, resolve);
        if (ep.start) {
            ep.start();
        }
        ep.postMessage(Object.assign({ id }, msg), transfers);
    });
}
function generateUUID() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
        .join("-");
}


//# sourceMappingURL=comlink.mjs.map


/***/ }),

/***/ "../common/dist/bundle.mjs":
/*!*********************************!*\
  !*** ../common/dist/bundle.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortOperation: () => (/* binding */ AbortOperation),
/* harmony export */   AbstractPowerSyncDatabase: () => (/* binding */ AbstractPowerSyncDatabase),
/* harmony export */   AbstractPowerSyncDatabaseOpenFactory: () => (/* binding */ AbstractPowerSyncDatabaseOpenFactory),
/* harmony export */   AbstractQueryProcessor: () => (/* binding */ AbstractQueryProcessor),
/* harmony export */   AbstractRemote: () => (/* binding */ AbstractRemote),
/* harmony export */   AbstractStreamingSyncImplementation: () => (/* binding */ AbstractStreamingSyncImplementation),
/* harmony export */   ArrayComparator: () => (/* binding */ ArrayComparator),
/* harmony export */   BaseObserver: () => (/* binding */ BaseObserver),
/* harmony export */   Column: () => (/* binding */ Column),
/* harmony export */   ColumnType: () => (/* binding */ ColumnType),
/* harmony export */   ConnectionManager: () => (/* binding */ ConnectionManager),
/* harmony export */   ControlledExecutor: () => (/* binding */ ControlledExecutor),
/* harmony export */   CrudBatch: () => (/* binding */ CrudBatch),
/* harmony export */   CrudEntry: () => (/* binding */ CrudEntry),
/* harmony export */   CrudTransaction: () => (/* binding */ CrudTransaction),
/* harmony export */   DEFAULT_CRUD_BATCH_LIMIT: () => (/* binding */ DEFAULT_CRUD_BATCH_LIMIT),
/* harmony export */   DEFAULT_CRUD_UPLOAD_THROTTLE_MS: () => (/* binding */ DEFAULT_CRUD_UPLOAD_THROTTLE_MS),
/* harmony export */   DEFAULT_INDEX_COLUMN_OPTIONS: () => (/* binding */ DEFAULT_INDEX_COLUMN_OPTIONS),
/* harmony export */   DEFAULT_INDEX_OPTIONS: () => (/* binding */ DEFAULT_INDEX_OPTIONS),
/* harmony export */   DEFAULT_LOCK_TIMEOUT_MS: () => (/* binding */ DEFAULT_LOCK_TIMEOUT_MS),
/* harmony export */   DEFAULT_POWERSYNC_CLOSE_OPTIONS: () => (/* binding */ DEFAULT_POWERSYNC_CLOSE_OPTIONS),
/* harmony export */   DEFAULT_POWERSYNC_DB_OPTIONS: () => (/* binding */ DEFAULT_POWERSYNC_DB_OPTIONS),
/* harmony export */   DEFAULT_PRESSURE_LIMITS: () => (/* binding */ DEFAULT_PRESSURE_LIMITS),
/* harmony export */   DEFAULT_REMOTE_LOGGER: () => (/* binding */ DEFAULT_REMOTE_LOGGER),
/* harmony export */   DEFAULT_REMOTE_OPTIONS: () => (/* binding */ DEFAULT_REMOTE_OPTIONS),
/* harmony export */   DEFAULT_RETRY_DELAY_MS: () => (/* binding */ DEFAULT_RETRY_DELAY_MS),
/* harmony export */   DEFAULT_ROW_COMPARATOR: () => (/* binding */ DEFAULT_ROW_COMPARATOR),
/* harmony export */   DEFAULT_STREAMING_SYNC_OPTIONS: () => (/* binding */ DEFAULT_STREAMING_SYNC_OPTIONS),
/* harmony export */   DEFAULT_STREAM_CONNECTION_OPTIONS: () => (/* binding */ DEFAULT_STREAM_CONNECTION_OPTIONS),
/* harmony export */   DEFAULT_SYNC_CLIENT_IMPLEMENTATION: () => (/* binding */ DEFAULT_SYNC_CLIENT_IMPLEMENTATION),
/* harmony export */   DEFAULT_TABLE_OPTIONS: () => (/* binding */ DEFAULT_TABLE_OPTIONS),
/* harmony export */   DEFAULT_WATCH_QUERY_OPTIONS: () => (/* binding */ DEFAULT_WATCH_QUERY_OPTIONS),
/* harmony export */   DEFAULT_WATCH_THROTTLE_MS: () => (/* binding */ DEFAULT_WATCH_THROTTLE_MS),
/* harmony export */   DataStream: () => (/* binding */ DataStream),
/* harmony export */   DiffTriggerOperation: () => (/* binding */ DiffTriggerOperation),
/* harmony export */   DifferentialQueryProcessor: () => (/* binding */ DifferentialQueryProcessor),
/* harmony export */   EMPTY_DIFFERENTIAL: () => (/* binding */ EMPTY_DIFFERENTIAL),
/* harmony export */   FalsyComparator: () => (/* binding */ FalsyComparator),
/* harmony export */   FetchImplementationProvider: () => (/* binding */ FetchImplementationProvider),
/* harmony export */   FetchStrategy: () => (/* binding */ FetchStrategy),
/* harmony export */   GetAllQuery: () => (/* binding */ GetAllQuery),
/* harmony export */   Index: () => (/* binding */ Index),
/* harmony export */   IndexedColumn: () => (/* binding */ IndexedColumn),
/* harmony export */   InvalidSQLCharacters: () => (/* binding */ InvalidSQLCharacters),
/* harmony export */   LockType: () => (/* binding */ LockType),
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   MAX_AMOUNT_OF_COLUMNS: () => (/* binding */ MAX_AMOUNT_OF_COLUMNS),
/* harmony export */   MAX_OP_ID: () => (/* binding */ MAX_OP_ID),
/* harmony export */   OnChangeQueryProcessor: () => (/* binding */ OnChangeQueryProcessor),
/* harmony export */   OpType: () => (/* binding */ OpType),
/* harmony export */   OpTypeEnum: () => (/* binding */ OpTypeEnum),
/* harmony export */   OplogEntry: () => (/* binding */ OplogEntry),
/* harmony export */   PSInternalTable: () => (/* binding */ PSInternalTable),
/* harmony export */   PowerSyncControlCommand: () => (/* binding */ PowerSyncControlCommand),
/* harmony export */   RowUpdateType: () => (/* binding */ RowUpdateType),
/* harmony export */   Schema: () => (/* binding */ Schema),
/* harmony export */   SqliteBucketStorage: () => (/* binding */ SqliteBucketStorage),
/* harmony export */   SyncClientImplementation: () => (/* binding */ SyncClientImplementation),
/* harmony export */   SyncDataBatch: () => (/* binding */ SyncDataBatch),
/* harmony export */   SyncDataBucket: () => (/* binding */ SyncDataBucket),
/* harmony export */   SyncProgress: () => (/* binding */ SyncProgress),
/* harmony export */   SyncStatus: () => (/* binding */ SyncStatus),
/* harmony export */   SyncStreamConnectionMethod: () => (/* binding */ SyncStreamConnectionMethod),
/* harmony export */   Table: () => (/* binding */ Table),
/* harmony export */   TableV2: () => (/* binding */ TableV2),
/* harmony export */   UpdateType: () => (/* binding */ UpdateType),
/* harmony export */   UploadQueueStats: () => (/* binding */ UploadQueueStats),
/* harmony export */   WatchedQueryListenerEvent: () => (/* binding */ WatchedQueryListenerEvent),
/* harmony export */   column: () => (/* binding */ column),
/* harmony export */   compilableQueryWatch: () => (/* binding */ compilableQueryWatch),
/* harmony export */   createBaseLogger: () => (/* binding */ createBaseLogger),
/* harmony export */   createLogger: () => (/* binding */ createLogger),
/* harmony export */   extractTableUpdates: () => (/* binding */ extractTableUpdates),
/* harmony export */   isBatchedUpdateNotification: () => (/* binding */ isBatchedUpdateNotification),
/* harmony export */   isContinueCheckpointRequest: () => (/* binding */ isContinueCheckpointRequest),
/* harmony export */   isDBAdapter: () => (/* binding */ isDBAdapter),
/* harmony export */   isPowerSyncDatabaseOptionsWithSettings: () => (/* binding */ isPowerSyncDatabaseOptionsWithSettings),
/* harmony export */   isSQLOpenFactory: () => (/* binding */ isSQLOpenFactory),
/* harmony export */   isSQLOpenOptions: () => (/* binding */ isSQLOpenOptions),
/* harmony export */   isStreamingKeepalive: () => (/* binding */ isStreamingKeepalive),
/* harmony export */   isStreamingSyncCheckpoint: () => (/* binding */ isStreamingSyncCheckpoint),
/* harmony export */   isStreamingSyncCheckpointComplete: () => (/* binding */ isStreamingSyncCheckpointComplete),
/* harmony export */   isStreamingSyncCheckpointDiff: () => (/* binding */ isStreamingSyncCheckpointDiff),
/* harmony export */   isStreamingSyncCheckpointPartiallyComplete: () => (/* binding */ isStreamingSyncCheckpointPartiallyComplete),
/* harmony export */   isStreamingSyncData: () => (/* binding */ isStreamingSyncData),
/* harmony export */   isSyncNewCheckpointRequest: () => (/* binding */ isSyncNewCheckpointRequest),
/* harmony export */   parseQuery: () => (/* binding */ parseQuery),
/* harmony export */   runOnSchemaChange: () => (/* binding */ runOnSchemaChange),
/* harmony export */   sanitizeSQL: () => (/* binding */ sanitizeSQL),
/* harmony export */   sanitizeUUID: () => (/* binding */ sanitizeUUID)
/* harmony export */ });
/* harmony import */ var async_mutex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! async-mutex */ "../../node_modules/async-mutex/index.mjs");


function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var dom = {};

var eventIterator = {};

var hasRequiredEventIterator;

function requireEventIterator () {
	if (hasRequiredEventIterator) return eventIterator;
	hasRequiredEventIterator = 1;
	Object.defineProperty(eventIterator, "__esModule", { value: true });
	class EventQueue {
	    constructor() {
	        this.pullQueue = [];
	        this.pushQueue = [];
	        this.eventHandlers = {};
	        this.isPaused = false;
	        this.isStopped = false;
	    }
	    push(value) {
	        if (this.isStopped)
	            return;
	        const resolution = { value, done: false };
	        if (this.pullQueue.length) {
	            const placeholder = this.pullQueue.shift();
	            if (placeholder)
	                placeholder.resolve(resolution);
	        }
	        else {
	            this.pushQueue.push(Promise.resolve(resolution));
	            if (this.highWaterMark !== undefined &&
	                this.pushQueue.length >= this.highWaterMark &&
	                !this.isPaused) {
	                this.isPaused = true;
	                if (this.eventHandlers.highWater) {
	                    this.eventHandlers.highWater();
	                }
	                else if (console) {
	                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
	                }
	            }
	        }
	    }
	    stop() {
	        if (this.isStopped)
	            return;
	        this.isStopped = true;
	        this.remove();
	        for (const placeholder of this.pullQueue) {
	            placeholder.resolve({ value: undefined, done: true });
	        }
	        this.pullQueue.length = 0;
	    }
	    fail(error) {
	        if (this.isStopped)
	            return;
	        this.isStopped = true;
	        this.remove();
	        if (this.pullQueue.length) {
	            for (const placeholder of this.pullQueue) {
	                placeholder.reject(error);
	            }
	            this.pullQueue.length = 0;
	        }
	        else {
	            const rejection = Promise.reject(error);
	            /* Attach error handler to avoid leaking an unhandled promise rejection. */
	            rejection.catch(() => { });
	            this.pushQueue.push(rejection);
	        }
	    }
	    remove() {
	        Promise.resolve().then(() => {
	            if (this.removeCallback)
	                this.removeCallback();
	        });
	    }
	    [Symbol.asyncIterator]() {
	        return {
	            next: (value) => {
	                const result = this.pushQueue.shift();
	                if (result) {
	                    if (this.lowWaterMark !== undefined &&
	                        this.pushQueue.length <= this.lowWaterMark &&
	                        this.isPaused) {
	                        this.isPaused = false;
	                        if (this.eventHandlers.lowWater) {
	                            this.eventHandlers.lowWater();
	                        }
	                    }
	                    return result;
	                }
	                else if (this.isStopped) {
	                    return Promise.resolve({ value: undefined, done: true });
	                }
	                else {
	                    return new Promise((resolve, reject) => {
	                        this.pullQueue.push({ resolve, reject });
	                    });
	                }
	            },
	            return: () => {
	                this.isStopped = true;
	                this.pushQueue.length = 0;
	                this.remove();
	                return Promise.resolve({ value: undefined, done: true });
	            },
	        };
	    }
	}
	class EventIterator {
	    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
	        const queue = new EventQueue();
	        queue.highWaterMark = highWaterMark;
	        queue.lowWaterMark = lowWaterMark;
	        queue.removeCallback =
	            listen({
	                push: value => queue.push(value),
	                stop: () => queue.stop(),
	                fail: error => queue.fail(error),
	                on: (event, fn) => {
	                    queue.eventHandlers[event] = fn;
	                },
	            }) || (() => { });
	        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
	        Object.freeze(this);
	    }
	}
	eventIterator.EventIterator = EventIterator;
	eventIterator.default = EventIterator;
	return eventIterator;
}

var hasRequiredDom;

function requireDom () {
	if (hasRequiredDom) return dom;
	hasRequiredDom = 1;
	Object.defineProperty(dom, "__esModule", { value: true });
	const event_iterator_1 = requireEventIterator();
	dom.EventIterator = event_iterator_1.EventIterator;
	function subscribe(event, options, evOptions) {
	    return new event_iterator_1.EventIterator(({ push }) => {
	        this.addEventListener(event, push, options);
	        return () => this.removeEventListener(event, push, options);
	    }, evOptions);
	}
	dom.subscribe = subscribe;
	dom.default = event_iterator_1.EventIterator;
	return dom;
}

var domExports = requireDom();

var logger$1 = {exports: {}};

/*!
 * js-logger - http://github.com/jonnyreeves/js-logger
 * Jonny Reeves, http://jonnyreeves.co.uk/
 * js-logger may be freely distributed under the MIT license.
 */
var logger = logger$1.exports;

var hasRequiredLogger;

function requireLogger () {
	if (hasRequiredLogger) return logger$1.exports;
	hasRequiredLogger = 1;
	(function (module) {
		(function (global) {

			// Top level module for the global, static logger instance.
			var Logger = { };

			// For those that are at home that are keeping score.
			Logger.VERSION = "1.6.1";

			// Function which handles all incoming log messages.
			var logHandler;

			// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.
			var contextualLoggersByNameMap = {};

			// Polyfill for ES5's Function.bind.
			var bind = function(scope, func) {
				return function() {
					return func.apply(scope, arguments);
				};
			};

			// Super exciting object merger-matron 9000 adding another 100 bytes to your download.
			var merge = function () {
				var args = arguments, target = args[0], key, i;
				for (i = 1; i < args.length; i++) {
					for (key in args[i]) {
						if (!(key in target) && args[i].hasOwnProperty(key)) {
							target[key] = args[i][key];
						}
					}
				}
				return target;
			};

			// Helper to define a logging level object; helps with optimisation.
			var defineLogLevel = function(value, name) {
				return { value: value, name: name };
			};

			// Predefined logging levels.
			Logger.TRACE = defineLogLevel(1, 'TRACE');
			Logger.DEBUG = defineLogLevel(2, 'DEBUG');
			Logger.INFO = defineLogLevel(3, 'INFO');
			Logger.TIME = defineLogLevel(4, 'TIME');
			Logger.WARN = defineLogLevel(5, 'WARN');
			Logger.ERROR = defineLogLevel(8, 'ERROR');
			Logger.OFF = defineLogLevel(99, 'OFF');

			// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently
			// of each other.
			var ContextualLogger = function(defaultContext) {
				this.context = defaultContext;
				this.setLevel(defaultContext.filterLevel);
				this.log = this.info;  // Convenience alias.
			};

			ContextualLogger.prototype = {
				// Changes the current logging level for the logging instance.
				setLevel: function (newLevel) {
					// Ensure the supplied Level object looks valid.
					if (newLevel && "value" in newLevel) {
						this.context.filterLevel = newLevel;
					}
				},
				
				// Gets the current logging level for the logging instance
				getLevel: function () {
					return this.context.filterLevel;
				},

				// Is the logger configured to output messages at the supplied level?
				enabledFor: function (lvl) {
					var filterLevel = this.context.filterLevel;
					return lvl.value >= filterLevel.value;
				},

				trace: function () {
					this.invoke(Logger.TRACE, arguments);
				},

				debug: function () {
					this.invoke(Logger.DEBUG, arguments);
				},

				info: function () {
					this.invoke(Logger.INFO, arguments);
				},

				warn: function () {
					this.invoke(Logger.WARN, arguments);
				},

				error: function () {
					this.invoke(Logger.ERROR, arguments);
				},

				time: function (label) {
					if (typeof label === 'string' && label.length > 0) {
						this.invoke(Logger.TIME, [ label, 'start' ]);
					}
				},

				timeEnd: function (label) {
					if (typeof label === 'string' && label.length > 0) {
						this.invoke(Logger.TIME, [ label, 'end' ]);
					}
				},

				// Invokes the logger callback if it's not being filtered.
				invoke: function (level, msgArgs) {
					if (logHandler && this.enabledFor(level)) {
						logHandler(msgArgs, merge({ level: level }, this.context));
					}
				}
			};

			// Protected instance which all calls to the to level `Logger` module will be routed through.
			var globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });

			// Configure the global Logger instance.
			(function() {
				// Shortcut for optimisers.
				var L = Logger;

				L.enabledFor = bind(globalLogger, globalLogger.enabledFor);
				L.trace = bind(globalLogger, globalLogger.trace);
				L.debug = bind(globalLogger, globalLogger.debug);
				L.time = bind(globalLogger, globalLogger.time);
				L.timeEnd = bind(globalLogger, globalLogger.timeEnd);
				L.info = bind(globalLogger, globalLogger.info);
				L.warn = bind(globalLogger, globalLogger.warn);
				L.error = bind(globalLogger, globalLogger.error);

				// Don't forget the convenience alias!
				L.log = L.info;
			}());

			// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments
			// object with the supplied log messages and the second being a context object which contains a hash of stateful
			// parameters which the logging function can consume.
			Logger.setHandler = function (func) {
				logHandler = func;
			};

			// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.
			// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).
			Logger.setLevel = function(level) {
				// Set the globalLogger's level.
				globalLogger.setLevel(level);

				// Apply this level to all registered contextual loggers.
				for (var key in contextualLoggersByNameMap) {
					if (contextualLoggersByNameMap.hasOwnProperty(key)) {
						contextualLoggersByNameMap[key].setLevel(level);
					}
				}
			};

			// Gets the global logging filter level
			Logger.getLevel = function() {
				return globalLogger.getLevel();
			};

			// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,
			// default context and log handler.
			Logger.get = function (name) {
				// All logger instances are cached so they can be configured ahead of use.
				return contextualLoggersByNameMap[name] ||
					(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));
			};

			// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will
			// write to the window's console object (if present); the optional options object can be used to customise the
			// formatter used to format each log message.
			Logger.createDefaultHandler = function (options) {
				options = options || {};

				options.formatter = options.formatter || function defaultMessageFormatter(messages, context) {
					// Prepend the logger's name to the log message for easy identification.
					if (context.name) {
						messages.unshift("[" + context.name + "]");
					}
				};

				// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments
				// that don't offer a native console method.
				var timerStartTimeByLabelMap = {};

				// Support for IE8+ (and other, slightly more sane environments)
				var invokeConsoleMethod = function (hdlr, messages) {
					Function.prototype.apply.call(hdlr, console, messages);
				};

				// Check for the presence of a logger.
				if (typeof console === "undefined") {
					return function () { /* no console */ };
				}

				return function(messages, context) {
					// Convert arguments object to Array.
					messages = Array.prototype.slice.call(messages);

					var hdlr = console.log;
					var timerLabel;

					if (context.level === Logger.TIME) {
						timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];

						if (messages[1] === 'start') {
							if (console.time) {
								console.time(timerLabel);
							}
							else {
								timerStartTimeByLabelMap[timerLabel] = new Date().getTime();
							}
						}
						else {
							if (console.timeEnd) {
								console.timeEnd(timerLabel);
							}
							else {
								invokeConsoleMethod(hdlr, [ timerLabel + ': ' +
									(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);
							}
						}
					}
					else {
						// Delegate through to custom warn/error loggers if present on the console.
						if (context.level === Logger.WARN && console.warn) {
							hdlr = console.warn;
						} else if (context.level === Logger.ERROR && console.error) {
							hdlr = console.error;
						} else if (context.level === Logger.INFO && console.info) {
							hdlr = console.info;
						} else if (context.level === Logger.DEBUG && console.debug) {
							hdlr = console.debug;
						} else if (context.level === Logger.TRACE && console.trace) {
							hdlr = console.trace;
						}

						options.formatter(messages, context);
						invokeConsoleMethod(hdlr, messages);
					}
				};
			};

			// Configure and example a Default implementation which writes to the `window.console` (if present).  The
			// `options` hash can be used to configure the default logLevel and provide a custom message formatter.
			Logger.useDefaults = function(options) {
				Logger.setLevel(options && options.defaultLevel || Logger.DEBUG);
				Logger.setHandler(Logger.createDefaultHandler(options));
			};

			// Createa an alias to useDefaults to avoid reaking a react-hooks rule.
			Logger.setDefaults = Logger.useDefaults;

			// Export to popular environments boilerplate.
			if (module.exports) {
				module.exports = Logger;
			}
			else {
				Logger._prevLogger = global.Logger;

				Logger.noConflict = function () {
					global.Logger = Logger._prevLogger;
					return Logger;
				};

				global.Logger = Logger;
			}
		}(logger)); 
	} (logger$1));
	return logger$1.exports;
}

var loggerExports = requireLogger();
var Logger = /*@__PURE__*/getDefaultExportFromCjs(loggerExports);

/**
 * Set of generic interfaces to allow PowerSync compatibility with
 * different SQLite DB implementations.
 */
/**
 * Update table operation numbers from SQLite
 */
var RowUpdateType;
(function (RowUpdateType) {
    RowUpdateType[RowUpdateType["SQLITE_INSERT"] = 18] = "SQLITE_INSERT";
    RowUpdateType[RowUpdateType["SQLITE_DELETE"] = 9] = "SQLITE_DELETE";
    RowUpdateType[RowUpdateType["SQLITE_UPDATE"] = 23] = "SQLITE_UPDATE";
})(RowUpdateType || (RowUpdateType = {}));
function isBatchedUpdateNotification(update) {
    return 'tables' in update;
}
function extractTableUpdates(update) {
    return isBatchedUpdateNotification(update) ? update.tables : [update.table];
}

/**
 * @internal The priority used by the core extension to indicate that a full sync was completed.
 */
const FULL_SYNC_PRIORITY = 2147483647;
/**
 * Provides realtime progress on how PowerSync is downloading rows.
 *
 * The progress until the next complete sync is available through the fields on {@link ProgressWithOperations},
 * which this class implements.
 * Additionally, the {@link SyncProgress.untilPriority} method can be used to otbain progress towards
 * a specific priority (instead of the progress for the entire download).
 *
 * The reported progress always reflects the status towards the end of a sync iteration (after
 * which a consistent snapshot of all buckets is available locally).
 *
 * In rare cases (in particular, when a [compacting](https://docs.powersync.com/usage/lifecycle-maintenance/compacting-buckets)
 * operation takes place between syncs), it's possible for the returned numbers to be slightly
 * inaccurate. For this reason, {@link SyncProgress} should be seen as an approximation of progress.
 * The information returned is good enough to build progress bars, but not exact enough to track
 * individual download counts.
 *
 * Also note that data is downloaded in bulk, which means that individual counters are unlikely
 * to be updated one-by-one.
 */
class SyncProgress {
    internal;
    totalOperations;
    downloadedOperations;
    downloadedFraction;
    constructor(internal) {
        this.internal = internal;
        const untilCompletion = this.untilPriority(FULL_SYNC_PRIORITY);
        this.totalOperations = untilCompletion.totalOperations;
        this.downloadedOperations = untilCompletion.downloadedOperations;
        this.downloadedFraction = untilCompletion.downloadedFraction;
    }
    /**
     * Returns download progress towards all data up until the specified priority being received.
     *
     * The returned {@link ProgressWithOperations} tracks the target amount of operations that need
     * to be downloaded in total and how many of them have already been received.
     */
    untilPriority(priority) {
        let total = 0;
        let downloaded = 0;
        for (const progress of Object.values(this.internal)) {
            // Include higher-priority buckets, which are represented by lower numbers.
            if (progress.priority <= priority) {
                downloaded += progress.since_last;
                total += progress.target_count - progress.at_last;
            }
        }
        let progress = total == 0 ? 0.0 : downloaded / total;
        return {
            totalOperations: total,
            downloadedOperations: downloaded,
            downloadedFraction: progress
        };
    }
}

class SyncStatus {
    options;
    constructor(options) {
        this.options = options;
    }
    /**
     * Returns the used sync client implementation (either the one implemented in JavaScript or the newer Rust-based
     * implementation).
     *
     * This information is only available after a connection has been requested.
     */
    get clientImplementation() {
        return this.options.clientImplementation;
    }
    /**
     * Indicates if the client is currently connected to the PowerSync service.
     *
     * @returns {boolean} True if connected, false otherwise. Defaults to false if not specified.
     */
    get connected() {
        return this.options.connected ?? false;
    }
    /**
     * Indicates if the client is in the process of establishing a connection to the PowerSync service.
     *
     * @returns {boolean} True if connecting, false otherwise. Defaults to false if not specified.
     */
    get connecting() {
        return this.options.connecting ?? false;
    }
    /**
     * Time that a last sync has fully completed, if any.
     * This timestamp is reset to null after a restart of the PowerSync service.
     *
     * @returns {Date | undefined} The timestamp of the last successful sync, or undefined if no sync has completed.
     */
    get lastSyncedAt() {
        return this.options.lastSyncedAt;
    }
    /**
     * Indicates whether there has been at least one full sync completed since initialization.
     *
     * @returns {boolean | undefined} True if at least one sync has completed, false if no sync has completed,
     * or undefined when the state is still being loaded from the database.
     */
    get hasSynced() {
        return this.options.hasSynced;
    }
    /**
     * Provides the current data flow status regarding uploads and downloads.
     *
     * @returns {SyncDataFlowStatus} An object containing:
     * - downloading: True if actively downloading changes (only when connected is also true)
     * - uploading: True if actively uploading changes
     * Defaults to {downloading: false, uploading: false} if not specified.
     */
    get dataFlowStatus() {
        return (this.options.dataFlow ?? {
            /**
             * true if actively downloading changes.
             * This is only true when {@link connected} is also true.
             */
            downloading: false,
            /**
             * true if uploading changes.
             */
            uploading: false
        });
    }
    /**
     * All sync streams currently being tracked in teh database.
     *
     * This returns null when the database is currently being opened and we don't have reliable information about all
     * included streams yet.
     *
     * @experimental Sync streams are currently in alpha.
     */
    get syncStreams() {
        return this.options.dataFlow?.internalStreamSubscriptions?.map((core) => new SyncStreamStatusView(this, core));
    }
    /**
     * If the `stream` appears in {@link syncStreams}, returns the current status for that stream.
     *
     * @experimental Sync streams are currently in alpha.
     */
    forStream(stream) {
        const asJson = JSON.stringify(stream.parameters);
        const raw = this.options.dataFlow?.internalStreamSubscriptions?.find((r) => r.name == stream.name && asJson == JSON.stringify(r.parameters));
        return raw && new SyncStreamStatusView(this, raw);
    }
    /**
     * Provides sync status information for all bucket priorities, sorted by priority (highest first).
     *
     * @returns {SyncPriorityStatus[]} An array of status entries for different sync priority levels,
     * sorted with highest priorities (lower numbers) first.
     */
    get priorityStatusEntries() {
        return (this.options.priorityStatusEntries ?? []).slice().sort(SyncStatus.comparePriorities);
    }
    /**
     * A realtime progress report on how many operations have been downloaded and
     * how many are necessary in total to complete the next sync iteration.
     *
     * This field is only set when {@link SyncDataFlowStatus#downloading} is also true.
     */
    get downloadProgress() {
        const internalProgress = this.options.dataFlow?.downloadProgress;
        if (internalProgress == null) {
            return null;
        }
        return new SyncProgress(internalProgress);
    }
    /**
     * Reports the sync status (a pair of {@link SyncStatus#hasSynced} and {@link SyncStatus#lastSyncedAt} fields)
     * for a specific bucket priority level.
     *
     * When buckets with different priorities are declared, PowerSync may choose to synchronize higher-priority
     * buckets first. When a consistent view over all buckets for all priorities up until the given priority is
     * reached, PowerSync makes data from those buckets available before lower-priority buckets have finished
     * syncing.
     *
     * This method returns the status for the requested priority or the next higher priority level that has
     * status information available. This is because when PowerSync makes data for a given priority available,
     * all buckets in higher-priorities are guaranteed to be consistent with that checkpoint.
     *
     * For example, if PowerSync just finished synchronizing buckets in priority level 3, calling this method
     * with a priority of 1 may return information for priority level 3.
     *
     * @param {number} priority The bucket priority for which the status should be reported
     * @returns {SyncPriorityStatus} Status information for the requested priority level or the next higher level with available status
     */
    statusForPriority(priority) {
        // priorityStatusEntries are sorted by ascending priorities (so higher numbers to lower numbers).
        for (const known of this.priorityStatusEntries) {
            // We look for the first entry that doesn't have a higher priority.
            if (known.priority >= priority) {
                return known;
            }
        }
        // If we have a complete sync, that necessarily includes all priorities.
        return {
            priority,
            lastSyncedAt: this.lastSyncedAt,
            hasSynced: this.hasSynced
        };
    }
    /**
     * Compares this SyncStatus instance with another to determine if they are equal.
     * Equality is determined by comparing the serialized JSON representation of both instances.
     *
     * @param {SyncStatus} status The SyncStatus instance to compare against
     * @returns {boolean} True if the instances are considered equal, false otherwise
     */
    isEqual(status) {
        /**
         * By default Error object are serialized to an empty object.
         * This replaces Errors with more useful information before serialization.
         */
        const replacer = (_, value) => {
            if (value instanceof Error) {
                return {
                    name: value.name,
                    message: value.message,
                    stack: value.stack
                };
            }
            return value;
        };
        return JSON.stringify(this.options, replacer) == JSON.stringify(status.options, replacer);
    }
    /**
     * Creates a human-readable string representation of the current sync status.
     * Includes information about connection state, sync completion, and data flow.
     *
     * @returns {string} A string representation of the sync status
     */
    getMessage() {
        const dataFlow = this.dataFlowStatus;
        return `SyncStatus<connected: ${this.connected} connecting: ${this.connecting} lastSyncedAt: ${this.lastSyncedAt} hasSynced: ${this.hasSynced}. Downloading: ${dataFlow.downloading}. Uploading: ${dataFlow.uploading}. UploadError: ${dataFlow.uploadError}, DownloadError?: ${dataFlow.downloadError}>`;
    }
    /**
     * Serializes the SyncStatus instance to a plain object.
     *
     * @returns {SyncStatusOptions} A plain object representation of the sync status
     */
    toJSON() {
        return {
            connected: this.connected,
            connecting: this.connecting,
            dataFlow: this.dataFlowStatus,
            lastSyncedAt: this.lastSyncedAt,
            hasSynced: this.hasSynced,
            priorityStatusEntries: this.priorityStatusEntries
        };
    }
    static comparePriorities(a, b) {
        return b.priority - a.priority; // Reverse because higher priorities have lower numbers
    }
}
class SyncStreamStatusView {
    status;
    core;
    subscription;
    constructor(status, core) {
        this.status = status;
        this.core = core;
        this.subscription = {
            name: core.name,
            parameters: core.parameters,
            active: core.active,
            isDefault: core.is_default,
            hasExplicitSubscription: core.has_explicit_subscription,
            expiresAt: core.expires_at != null ? new Date(core.expires_at * 1000) : null,
            hasSynced: core.last_synced_at != null,
            lastSyncedAt: core.last_synced_at != null ? new Date(core.last_synced_at * 1000) : null
        };
    }
    get progress() {
        if (this.status.dataFlowStatus.downloadProgress == null) {
            // Don't make download progress public if we're not currently downloading.
            return null;
        }
        const { total, downloaded } = this.core.progress;
        const progress = total == 0 ? 0.0 : downloaded / total;
        return { totalOperations: total, downloadedOperations: downloaded, downloadedFraction: progress };
    }
    get priority() {
        return this.core.priority;
    }
}

class UploadQueueStats {
    count;
    size;
    constructor(
    /**
     * Number of records in the upload queue.
     */
    count, 
    /**
     * Size of the upload queue in bytes.
     */
    size = null) {
        this.count = count;
        this.size = size;
    }
    toString() {
        if (this.size == null) {
            return `UploadQueueStats<count:${this.count}>`;
        }
        else {
            return `UploadQueueStats<count: $count size: ${this.size / 1024}kB>`;
        }
    }
}

class BaseObserver {
    listeners = new Set();
    constructor() { }
    dispose() {
        this.listeners.clear();
    }
    /**
     * Register a listener for updates to the PowerSync client.
     */
    registerListener(listener) {
        this.listeners.add(listener);
        return () => {
            this.listeners.delete(listener);
        };
    }
    iterateListeners(cb) {
        for (const listener of this.listeners) {
            cb(listener);
        }
    }
    async iterateAsyncListeners(cb) {
        for (let i of Array.from(this.listeners.values())) {
            await cb(i);
        }
    }
}

class ControlledExecutor {
    task;
    /**
     * Represents the currently running task, which could be a Promise or undefined if no task is running.
     */
    runningTask;
    pendingTaskParam;
    /**
     * Flag to determine if throttling is enabled, which controls whether tasks are queued or run immediately.
     */
    isThrottling;
    closed;
    constructor(task, options) {
        this.task = task;
        const { throttleEnabled = true } = options ?? {};
        this.isThrottling = throttleEnabled;
        this.closed = false;
    }
    schedule(param) {
        if (this.closed) {
            return;
        }
        if (!this.isThrottling) {
            this.task(param);
            return;
        }
        if (this.runningTask) {
            // set or replace the pending task param with latest one
            this.pendingTaskParam = param;
            return;
        }
        this.execute(param);
    }
    dispose() {
        this.closed = true;
        if (this.runningTask) {
            this.runningTask = undefined;
        }
    }
    async execute(param) {
        this.runningTask = this.task(param);
        await this.runningTask;
        this.runningTask = undefined;
        if (this.pendingTaskParam) {
            const pendingParam = this.pendingTaskParam;
            this.pendingTaskParam = undefined;
            this.execute(pendingParam);
        }
    }
}

/**
 * A ponyfill for `Symbol.asyncIterator` that is compatible with the
 * [recommended polyfill](https://github.com/Azure/azure-sdk-for-js/blob/%40azure/core-asynciterator-polyfill_1.0.2/sdk/core/core-asynciterator-polyfill/src/index.ts#L4-L6)
 * we recommend for React Native.
 *
 * As long as we use this symbol (instead of `for await` and `async *`) in this package, we can be compatible with async
 * iterators without requiring them.
 */
const symbolAsyncIterator = Symbol.asyncIterator ?? Symbol.for('Symbol.asyncIterator');
/**
 * Throttle a function to be called at most once every "wait" milliseconds,
 * on the trailing edge.
 *
 * Roughly equivalent to lodash/throttle with {leading: false, trailing: true}
 */
function throttleTrailing(func, wait) {
    let timeoutId = null;
    const later = () => {
        func();
        timeoutId = null;
    };
    return function () {
        if (timeoutId == null) {
            timeoutId = setTimeout(later, wait);
        }
    };
}
/**
 * Throttle a function to be called at most once every "wait" milliseconds,
 * on the leading and trailing edge.
 *
 * Roughly equivalent to lodash/throttle with {leading: true, trailing: true}
 */
function throttleLeadingTrailing(func, wait) {
    let timeoutId = null;
    let lastCallTime = 0;
    const invokeFunction = () => {
        func();
        lastCallTime = Date.now();
        timeoutId = null;
    };
    return function () {
        const now = Date.now();
        const timeToWait = wait - (now - lastCallTime);
        if (timeToWait <= 0) {
            // Leading edge: Call the function immediately if enough time has passed
            invokeFunction();
        }
        else if (!timeoutId) {
            // Set a timeout for the trailing edge if not already set
            timeoutId = setTimeout(invokeFunction, timeToWait);
        }
    };
}

/**
 * @internal
 */
class ConnectionManager extends BaseObserver {
    options;
    /**
     * Tracks active connection attempts
     */
    connectingPromise;
    /**
     * Tracks actively instantiating a streaming sync implementation.
     */
    syncStreamInitPromise;
    /**
     * Active disconnect operation. Calling disconnect multiple times
     * will resolve to the same operation.
     */
    disconnectingPromise;
    /**
     * Tracks the last parameters supplied to `connect` calls.
     * Calling `connect` multiple times in succession will result in:
     * - 1 pending connection operation which will be aborted.
     * - updating the last set of parameters while waiting for the pending
     *   attempt to be aborted
     * - internally connecting with the last set of parameters
     */
    pendingConnectionOptions;
    syncStreamImplementation;
    /**
     * Additional cleanup function which is called after the sync stream implementation
     * is disposed.
     */
    syncDisposer;
    /**
     * Subscriptions managed in this connection manager.
     *
     * On the web, these local subscriptions are merged across tabs by a shared worker.
     */
    locallyActiveSubscriptions = new Map();
    constructor(options) {
        super();
        this.options = options;
        this.connectingPromise = null;
        this.syncStreamInitPromise = null;
        this.disconnectingPromise = null;
        this.pendingConnectionOptions = null;
        this.syncStreamImplementation = null;
        this.syncDisposer = null;
    }
    get connector() {
        return this.pendingConnectionOptions?.connector ?? null;
    }
    get connectionOptions() {
        return this.pendingConnectionOptions?.options ?? null;
    }
    get logger() {
        return this.options.logger;
    }
    async close() {
        await this.syncStreamImplementation?.dispose();
        await this.syncDisposer?.();
    }
    async connect(connector, options) {
        // Keep track if there were pending operations before this call
        const hadPendingOptions = !!this.pendingConnectionOptions;
        // Update pending options to the latest values
        this.pendingConnectionOptions = {
            connector,
            options
        };
        // Disconnecting here provides aborting in progress connection attempts.
        // The connectInternal method will clear pending options once it starts connecting (with the options).
        // We only need to trigger a disconnect here if we have already reached the point of connecting.
        // If we do already have pending options, a disconnect has already been performed.
        // The connectInternal method also does a sanity disconnect to prevent straggler connections.
        // We should also disconnect if we have already completed a connection attempt.
        if (!hadPendingOptions || this.syncStreamImplementation) {
            await this.disconnectInternal();
        }
        // Triggers a connect which checks if pending options are available after the connect completes.
        // The completion can be for a successful, unsuccessful or aborted connection attempt.
        // If pending options are available another connection will be triggered.
        const checkConnection = async () => {
            if (this.pendingConnectionOptions) {
                // Pending options have been placed while connecting.
                // Need to reconnect.
                this.connectingPromise = this.connectInternal()
                    .catch(() => { })
                    .finally(checkConnection);
                return this.connectingPromise;
            }
            else {
                // Clear the connecting promise, done.
                this.connectingPromise = null;
                return;
            }
        };
        this.connectingPromise ??= this.connectInternal()
            .catch(() => { })
            .finally(checkConnection);
        return this.connectingPromise;
    }
    async connectInternal() {
        let appliedOptions = null;
        // This method ensures a disconnect before any connection attempt
        await this.disconnectInternal();
        /**
         * This portion creates a sync implementation which can be racy when disconnecting or
         * if multiple tabs on web are in use.
         * This is protected in an exclusive lock.
         * The promise tracks the creation which is used to synchronize disconnect attempts.
         */
        this.syncStreamInitPromise = new Promise(async (resolve, reject) => {
            try {
                if (!this.pendingConnectionOptions) {
                    this.logger.debug('No pending connection options found, not creating sync stream implementation');
                    // A disconnect could have cleared this.
                    resolve();
                    return;
                }
                if (this.disconnectingPromise) {
                    resolve();
                    return;
                }
                const { connector, options } = this.pendingConnectionOptions;
                appliedOptions = options;
                this.pendingConnectionOptions = null;
                const { sync, onDispose } = await this.options.createSyncImplementation(connector, {
                    subscriptions: this.activeStreams,
                    ...options
                });
                this.iterateListeners((l) => l.syncStreamCreated?.(sync));
                this.syncStreamImplementation = sync;
                this.syncDisposer = onDispose;
                await this.syncStreamImplementation.waitForReady();
                resolve();
            }
            catch (error) {
                reject(error);
            }
        });
        await this.syncStreamInitPromise;
        this.syncStreamInitPromise = null;
        if (!appliedOptions) {
            // A disconnect could have cleared the options which did not create a syncStreamImplementation
            return;
        }
        // It might be possible that a disconnect triggered between the last check
        // and this point. Awaiting here allows the sync stream to be cleared if disconnected.
        await this.disconnectingPromise;
        this.logger.debug('Attempting to connect to PowerSync instance');
        await this.syncStreamImplementation?.connect(appliedOptions);
    }
    /**
     * Close the sync connection.
     *
     * Use {@link connect} to connect again.
     */
    async disconnect() {
        // This will help abort pending connects
        this.pendingConnectionOptions = null;
        await this.disconnectInternal();
    }
    async disconnectInternal() {
        if (this.disconnectingPromise) {
            // A disconnect is already in progress
            return this.disconnectingPromise;
        }
        this.disconnectingPromise = this.performDisconnect();
        await this.disconnectingPromise;
        this.disconnectingPromise = null;
    }
    async performDisconnect() {
        // Wait if a sync stream implementation is being created before closing it
        // (syncStreamImplementation must be assigned before we can properly dispose it)
        await this.syncStreamInitPromise;
        // Keep reference to the sync stream implementation and disposer
        // The class members will be cleared before we trigger the disconnect
        // to prevent any further calls to the sync stream implementation.
        const sync = this.syncStreamImplementation;
        this.syncStreamImplementation = null;
        const disposer = this.syncDisposer;
        this.syncDisposer = null;
        await sync?.disconnect();
        await sync?.dispose();
        await disposer?.();
    }
    stream(adapter, name, parameters) {
        const desc = { name, parameters };
        const waitForFirstSync = (abort) => {
            return adapter.firstStatusMatching((s) => s.forStream(desc)?.subscription.hasSynced, abort);
        };
        return {
            ...desc,
            subscribe: async (options) => {
                // NOTE: We also run this command if a subscription already exists, because this increases the expiry date
                // (relevant if the app is closed before connecting again, where the last subscribe call determines the ttl).
                await adapter.rustSubscriptionsCommand({
                    subscribe: {
                        stream: {
                            name,
                            params: parameters
                        },
                        ttl: options?.ttl,
                        priority: options?.priority
                    }
                });
                if (!this.syncStreamImplementation) {
                    // We're not connected. So, update the offline sync status to reflect the new subscription.
                    // (With an active iteration, the sync client would include it in its state).
                    await adapter.resolveOfflineSyncStatus();
                }
                const key = `${name}|${JSON.stringify(parameters)}`;
                let subscription = this.locallyActiveSubscriptions.get(key);
                if (subscription == null) {
                    const clearSubscription = () => {
                        this.locallyActiveSubscriptions.delete(key);
                        this.subscriptionsMayHaveChanged();
                    };
                    subscription = new ActiveSubscription(name, parameters, this.logger, waitForFirstSync, clearSubscription);
                    this.locallyActiveSubscriptions.set(key, subscription);
                    this.subscriptionsMayHaveChanged();
                }
                return new SyncStreamSubscriptionHandle(subscription);
            },
            unsubscribeAll: async () => {
                await adapter.rustSubscriptionsCommand({ unsubscribe: { name, params: parameters } });
                this.subscriptionsMayHaveChanged();
            }
        };
    }
    /**
     * @internal exposed for testing
     */
    get activeStreams() {
        return [...this.locallyActiveSubscriptions.values()].map((a) => ({ name: a.name, params: a.parameters }));
    }
    subscriptionsMayHaveChanged() {
        this.syncStreamImplementation?.updateSubscriptions(this.activeStreams);
    }
}
class ActiveSubscription {
    name;
    parameters;
    logger;
    waitForFirstSync;
    clearSubscription;
    refcount = 0;
    constructor(name, parameters, logger, waitForFirstSync, clearSubscription) {
        this.name = name;
        this.parameters = parameters;
        this.logger = logger;
        this.waitForFirstSync = waitForFirstSync;
        this.clearSubscription = clearSubscription;
    }
    decrementRefCount() {
        this.refcount--;
        if (this.refcount == 0) {
            this.clearSubscription();
        }
    }
}
class SyncStreamSubscriptionHandle {
    subscription;
    active = true;
    constructor(subscription) {
        this.subscription = subscription;
        subscription.refcount++;
        _finalizer?.register(this, subscription);
    }
    get name() {
        return this.subscription.name;
    }
    get parameters() {
        return this.subscription.parameters;
    }
    waitForFirstSync(abort) {
        return this.subscription.waitForFirstSync(abort);
    }
    unsubscribe() {
        if (this.active) {
            this.active = false;
            _finalizer?.unregister(this);
            this.subscription.decrementRefCount();
        }
    }
}
const _finalizer = 'FinalizationRegistry' in globalThis
    ? new FinalizationRegistry((sub) => {
        sub.logger.warn(`A subscription to ${sub.name} with params ${JSON.stringify(sub.parameters)} leaked! Please ensure calling unsubscribe() when you don't need a subscription anymore. For global subscriptions, consider storing them in global fields to avoid this warning.`);
    })
    : null;

/**
 * An efficient comparator for {@link WatchedQuery} created with {@link Query#watch}. This has the ability to determine if a query
 * result has changes without necessarily processing all items in the result.
 */
class ArrayComparator {
    options;
    constructor(options) {
        this.options = options;
    }
    checkEquality(current, previous) {
        if (current.length === 0 && previous.length === 0) {
            return true;
        }
        if (current.length !== previous.length) {
            return false;
        }
        const { compareBy } = this.options;
        // At this point the lengths are equal
        for (let i = 0; i < current.length; i++) {
            const currentItem = compareBy(current[i]);
            const previousItem = compareBy(previous[i]);
            if (currentItem !== previousItem) {
                return false;
            }
        }
        return true;
    }
}
/**
 * Watched query comparator that always reports changed result sets.
 */
const FalsyComparator = {
    checkEquality: () => false // Default comparator that always returns false
};

/**
 * A BaseObserver that tracks the counts of listeners for each event type.
 */
class MetaBaseObserver extends BaseObserver {
    get listenerCounts() {
        const counts = {};
        let total = 0;
        for (const listener of this.listeners) {
            for (const key in listener) {
                if (listener[key]) {
                    counts[key] = (counts[key] ?? 0) + 1;
                    total++;
                }
            }
        }
        return {
            ...counts,
            total
        };
    }
    get listenerMeta() {
        return {
            counts: this.listenerCounts,
            // Allows registering a meta listener that will be notified of changes in listener counts
            registerListener: (listener) => {
                return this.metaListener.registerListener(listener);
            }
        };
    }
    metaListener;
    constructor() {
        super();
        this.metaListener = new BaseObserver();
    }
    registerListener(listener) {
        const dispose = super.registerListener(listener);
        const updatedCount = this.listenerCounts;
        this.metaListener.iterateListeners((l) => {
            l.listenersChanged?.(updatedCount);
        });
        return () => {
            dispose();
            const updatedCount = this.listenerCounts;
            this.metaListener.iterateListeners((l) => {
                l.listenersChanged?.(updatedCount);
            });
        };
    }
}

var WatchedQueryListenerEvent;
(function (WatchedQueryListenerEvent) {
    WatchedQueryListenerEvent["ON_DATA"] = "onData";
    WatchedQueryListenerEvent["ON_ERROR"] = "onError";
    WatchedQueryListenerEvent["ON_STATE_CHANGE"] = "onStateChange";
    WatchedQueryListenerEvent["SETTINGS_WILL_UPDATE"] = "settingsWillUpdate";
    WatchedQueryListenerEvent["CLOSED"] = "closed";
})(WatchedQueryListenerEvent || (WatchedQueryListenerEvent = {}));
const DEFAULT_WATCH_THROTTLE_MS = 30;
const DEFAULT_WATCH_QUERY_OPTIONS = {
    throttleMs: DEFAULT_WATCH_THROTTLE_MS,
    reportFetching: true
};

/**
 * Performs underlying watching and yields a stream of results.
 * @internal
 */
class AbstractQueryProcessor extends MetaBaseObserver {
    options;
    state;
    abortController;
    initialized;
    _closed;
    disposeListeners;
    get closed() {
        return this._closed;
    }
    constructor(options) {
        super();
        this.options = options;
        this.abortController = new AbortController();
        this._closed = false;
        this.state = this.constructInitialState();
        this.disposeListeners = null;
        this.initialized = this.init(this.abortController.signal);
    }
    constructInitialState() {
        return {
            isLoading: true,
            isFetching: this.reportFetching, // Only set to true if we will report updates in future
            error: null,
            lastUpdated: null,
            data: this.options.placeholderData
        };
    }
    get reportFetching() {
        return this.options.watchOptions.reportFetching ?? true;
    }
    async updateSettingsInternal(settings, signal) {
        // This may have been aborted while awaiting or if multiple calls to `updateSettings` were made
        if (this._closed || signal.aborted) {
            return;
        }
        this.options.watchOptions = settings;
        this.iterateListeners((l) => l[WatchedQueryListenerEvent.SETTINGS_WILL_UPDATE]?.());
        if (!this.state.isFetching && this.reportFetching) {
            await this.updateState({
                isFetching: true
            });
        }
        await this.runWithReporting(() => this.linkQuery({
            abortSignal: signal,
            settings
        }));
    }
    /**
     * Updates the underlying query.
     */
    async updateSettings(settings) {
        // Abort the previous request
        this.abortController.abort();
        // Keep track of this controller's abort status
        const abortController = new AbortController();
        // Allow this to be aborted externally
        this.abortController = abortController;
        await this.initialized;
        return this.updateSettingsInternal(settings, abortController.signal);
    }
    async updateState(update) {
        if (this._closed) {
            return;
        }
        if (typeof update.error !== 'undefined') {
            await this.iterateAsyncListenersWithError(async (l) => l.onError?.(update.error));
            // An error always stops for the current fetching state
            update.isFetching = false;
            update.isLoading = false;
        }
        Object.assign(this.state, { lastUpdated: new Date() }, update);
        if (typeof update.data !== 'undefined') {
            await this.iterateAsyncListenersWithError(async (l) => l.onData?.(this.state.data));
        }
        await this.iterateAsyncListenersWithError(async (l) => l.onStateChange?.(this.state));
    }
    /**
     * Configures base DB listeners and links the query to listeners.
     */
    async init(signal) {
        const { db } = this.options;
        const disposeCloseListener = db.registerListener({
            closing: async () => {
                await this.close();
            }
        });
        // Wait for the schema to be set before listening to changes
        await db.waitForReady();
        const disposeSchemaListener = db.registerListener({
            schemaChanged: async () => {
                await this.runWithReporting(async () => {
                    await this.updateSettings(this.options.watchOptions);
                });
            }
        });
        this.disposeListeners = () => {
            disposeCloseListener();
            disposeSchemaListener();
        };
        // Initial setup
        await this.runWithReporting(async () => {
            await this.updateSettingsInternal(this.options.watchOptions, signal);
        });
    }
    async close() {
        this._closed = true;
        this.abortController.abort();
        this.disposeListeners?.();
        this.disposeListeners = null;
        this.iterateListeners((l) => l.closed?.());
        this.listeners.clear();
    }
    /**
     * Runs a callback and reports errors to the error listeners.
     */
    async runWithReporting(callback) {
        try {
            await callback();
        }
        catch (error) {
            // This will update the error on the state and iterate error listeners
            await this.updateState({ error });
        }
    }
    /**
     * Iterate listeners and reports errors to onError handlers.
     */
    async iterateAsyncListenersWithError(callback) {
        try {
            await this.iterateAsyncListeners(async (l) => callback(l));
        }
        catch (error) {
            try {
                await this.iterateAsyncListeners(async (l) => l.onError?.(error));
            }
            catch (error) {
                // Errors here are ignored
                // since we are already in an error state
                this.options.db.logger.error('Watched query error handler threw an Error', error);
            }
        }
    }
}

/**
 * An empty differential result set.
 * This is used as the initial state for differential incrementally watched queries.
 */
const EMPTY_DIFFERENTIAL = {
    added: [],
    all: [],
    removed: [],
    updated: [],
    unchanged: []
};
/**
 * Default implementation of the {@link DifferentialWatchedQueryComparator} for watched queries.
 * It keys items by their `id` property if available, alternatively it uses JSON stringification
 * of the entire item for the key and comparison.
 */
const DEFAULT_ROW_COMPARATOR = {
    keyBy: (item) => {
        if (item && typeof item == 'object' && typeof item['id'] == 'string') {
            return item['id'];
        }
        return JSON.stringify(item);
    },
    compareBy: (item) => JSON.stringify(item)
};
/**
 * Uses the PowerSync onChange event to trigger watched queries.
 * Results are emitted on every change of the relevant tables.
 * @internal
 */
class DifferentialQueryProcessor extends AbstractQueryProcessor {
    options;
    comparator;
    constructor(options) {
        super(options);
        this.options = options;
        this.comparator = options.rowComparator ?? DEFAULT_ROW_COMPARATOR;
    }
    /*
     * @returns If the sets are equal
     */
    differentiate(current, previousMap) {
        const { keyBy, compareBy } = this.comparator;
        let hasChanged = false;
        const currentMap = new Map();
        const removedTracker = new Set(previousMap.keys());
        // Allow mutating to populate the data temporarily.
        const diff = {
            all: [],
            added: [],
            removed: [],
            updated: [],
            unchanged: []
        };
        /**
         * Looping over the current result set array is important to preserve
         * the ordering of the result set.
         * We can replace items in the current array with previous object references if they are equal.
         */
        for (const item of current) {
            const key = keyBy(item);
            const hash = compareBy(item);
            currentMap.set(key, { hash, item });
            const previousItem = previousMap.get(key);
            if (!previousItem) {
                // New item
                hasChanged = true;
                diff.added.push(item);
                diff.all.push(item);
            }
            else {
                // Existing item
                if (hash == previousItem.hash) {
                    diff.unchanged.push(previousItem.item);
                    // Use the previous object reference
                    diff.all.push(previousItem.item);
                    // update the map to preserve the reference
                    currentMap.set(key, previousItem);
                }
                else {
                    hasChanged = true;
                    diff.updated.push({ current: item, previous: previousItem.item });
                    // Use the new reference
                    diff.all.push(item);
                }
            }
            // The item is present, we don't consider it removed
            removedTracker.delete(key);
        }
        diff.removed = Array.from(removedTracker).map((key) => previousMap.get(key).item);
        hasChanged = hasChanged || diff.removed.length > 0;
        return {
            diff,
            hasChanged,
            map: currentMap
        };
    }
    async linkQuery(options) {
        const { db, watchOptions } = this.options;
        const { abortSignal } = options;
        const compiledQuery = watchOptions.query.compile();
        const tables = await db.resolveTables(compiledQuery.sql, compiledQuery.parameters, {
            tables: options.settings.triggerOnTables
        });
        let currentMap = new Map();
        // populate the currentMap from the placeholder data
        this.state.data.forEach((item) => {
            currentMap.set(this.comparator.keyBy(item), {
                hash: this.comparator.compareBy(item),
                item
            });
        });
        db.onChangeWithCallback({
            onChange: async () => {
                if (this.closed || abortSignal.aborted) {
                    return;
                }
                // This fires for each change of the relevant tables
                try {
                    if (this.reportFetching && !this.state.isFetching) {
                        await this.updateState({ isFetching: true });
                    }
                    const partialStateUpdate = {};
                    // Always run the query if an underlying table has changed
                    const result = await watchOptions.query.execute({
                        sql: compiledQuery.sql,
                        // Allows casting from ReadOnlyArray[unknown] to Array<unknown>
                        // This allows simpler compatibility with PowerSync queries
                        parameters: [...compiledQuery.parameters],
                        db: this.options.db
                    });
                    if (abortSignal.aborted) {
                        return;
                    }
                    if (this.reportFetching) {
                        partialStateUpdate.isFetching = false;
                    }
                    if (this.state.isLoading) {
                        partialStateUpdate.isLoading = false;
                    }
                    const { diff, hasChanged, map } = this.differentiate(result, currentMap);
                    // Update for future comparisons
                    currentMap = map;
                    if (hasChanged) {
                        await this.iterateAsyncListenersWithError((l) => l.onDiff?.(diff));
                        Object.assign(partialStateUpdate, {
                            data: diff.all
                        });
                    }
                    if (this.state.error) {
                        partialStateUpdate.error = null;
                    }
                    if (Object.keys(partialStateUpdate).length > 0) {
                        await this.updateState(partialStateUpdate);
                    }
                }
                catch (error) {
                    await this.updateState({ error });
                }
            },
            onError: async (error) => {
                await this.updateState({ error });
            }
        }, {
            signal: abortSignal,
            tables,
            throttleMs: watchOptions.throttleMs,
            triggerImmediate: true // used to emit the initial state
        });
    }
}

/**
 * Uses the PowerSync onChange event to trigger watched queries.
 * Results are emitted on every change of the relevant tables.
 * @internal
 */
class OnChangeQueryProcessor extends AbstractQueryProcessor {
    options;
    constructor(options) {
        super(options);
        this.options = options;
    }
    /**
     * @returns If the sets are equal
     */
    checkEquality(current, previous) {
        // Use the provided comparator if available. Assume values are unique if not available.
        return this.options.comparator?.checkEquality?.(current, previous) ?? false;
    }
    async linkQuery(options) {
        const { db, watchOptions } = this.options;
        const { abortSignal } = options;
        const compiledQuery = watchOptions.query.compile();
        const tables = await db.resolveTables(compiledQuery.sql, compiledQuery.parameters, {
            tables: options.settings.triggerOnTables
        });
        db.onChangeWithCallback({
            onChange: async () => {
                if (this.closed || abortSignal.aborted) {
                    return;
                }
                // This fires for each change of the relevant tables
                try {
                    if (this.reportFetching && !this.state.isFetching) {
                        await this.updateState({ isFetching: true });
                    }
                    const partialStateUpdate = {};
                    // Always run the query if an underlying table has changed
                    const result = await watchOptions.query.execute({
                        sql: compiledQuery.sql,
                        // Allows casting from ReadOnlyArray[unknown] to Array<unknown>
                        // This allows simpler compatibility with PowerSync queries
                        parameters: [...compiledQuery.parameters],
                        db: this.options.db
                    });
                    if (abortSignal.aborted) {
                        return;
                    }
                    if (this.reportFetching) {
                        partialStateUpdate.isFetching = false;
                    }
                    if (this.state.isLoading) {
                        partialStateUpdate.isLoading = false;
                    }
                    // Check if the result has changed
                    if (!this.checkEquality(result, this.state.data)) {
                        Object.assign(partialStateUpdate, {
                            data: result
                        });
                    }
                    if (this.state.error) {
                        partialStateUpdate.error = null;
                    }
                    if (Object.keys(partialStateUpdate).length > 0) {
                        await this.updateState(partialStateUpdate);
                    }
                }
                catch (error) {
                    await this.updateState({ error });
                }
            },
            onError: async (error) => {
                await this.updateState({ error });
            }
        }, {
            signal: abortSignal,
            tables,
            throttleMs: watchOptions.throttleMs,
            triggerImmediate: true // used to emit the initial state
        });
    }
}

/**
 * @internal
 */
class CustomQuery {
    options;
    constructor(options) {
        this.options = options;
    }
    resolveOptions(options) {
        return {
            reportFetching: options?.reportFetching ?? DEFAULT_WATCH_QUERY_OPTIONS.reportFetching,
            throttleMs: options?.throttleMs ?? DEFAULT_WATCH_QUERY_OPTIONS.throttleMs,
            triggerOnTables: options?.triggerOnTables
        };
    }
    watch(watchOptions) {
        return new OnChangeQueryProcessor({
            db: this.options.db,
            comparator: watchOptions?.comparator ?? FalsyComparator,
            placeholderData: watchOptions?.placeholderData ?? [],
            watchOptions: {
                ...this.resolveOptions(watchOptions),
                query: this.options.query
            }
        });
    }
    differentialWatch(differentialWatchOptions) {
        return new DifferentialQueryProcessor({
            db: this.options.db,
            rowComparator: differentialWatchOptions?.rowComparator,
            placeholderData: differentialWatchOptions?.placeholderData ?? [],
            watchOptions: {
                ...this.resolveOptions(differentialWatchOptions),
                query: this.options.query
            }
        });
    }
}

/**
 * Tests if the input is a {@link SQLOpenOptions}
 */
const isSQLOpenOptions = (test) => {
    // typeof null is `object`, but you cannot use the `in` operator on `null.
    return test && typeof test == 'object' && 'dbFilename' in test;
};
/**
 * Tests if input is a {@link SQLOpenFactory}
 */
const isSQLOpenFactory = (test) => {
    return typeof test?.openDB == 'function';
};
/**
 * Tests if input is a {@link DBAdapter}
 */
const isDBAdapter = (test) => {
    return typeof test?.writeTransaction == 'function';
};

var PSInternalTable;
(function (PSInternalTable) {
    PSInternalTable["DATA"] = "ps_data";
    PSInternalTable["CRUD"] = "ps_crud";
    PSInternalTable["BUCKETS"] = "ps_buckets";
    PSInternalTable["OPLOG"] = "ps_oplog";
    PSInternalTable["UNTYPED"] = "ps_untyped";
})(PSInternalTable || (PSInternalTable = {}));
var PowerSyncControlCommand;
(function (PowerSyncControlCommand) {
    PowerSyncControlCommand["PROCESS_TEXT_LINE"] = "line_text";
    PowerSyncControlCommand["PROCESS_BSON_LINE"] = "line_binary";
    PowerSyncControlCommand["STOP"] = "stop";
    PowerSyncControlCommand["START"] = "start";
    PowerSyncControlCommand["NOTIFY_TOKEN_REFRESHED"] = "refreshed_token";
    PowerSyncControlCommand["NOTIFY_CRUD_UPLOAD_COMPLETED"] = "completed_upload";
    PowerSyncControlCommand["UPDATE_SUBSCRIPTIONS"] = "update_subscriptions";
})(PowerSyncControlCommand || (PowerSyncControlCommand = {}));

/**
 * A batch of client-side changes.
 */
class CrudBatch {
    crud;
    haveMore;
    complete;
    constructor(
    /**
     * List of client-side changes.
     */
    crud, 
    /**
     * true if there are more changes in the local queue.
     */
    haveMore, 
    /**
     * Call to remove the changes from the local queue, once successfully uploaded.
     */
    complete) {
        this.crud = crud;
        this.haveMore = haveMore;
        this.complete = complete;
    }
}

/**
 * Type of local change.
 */
var UpdateType;
(function (UpdateType) {
    /** Insert or replace existing row. All non-null columns are included in the data. Generated by INSERT statements. */
    UpdateType["PUT"] = "PUT";
    /** Update existing row. Contains the id, and value of each changed column. Generated by UPDATE statements. */
    UpdateType["PATCH"] = "PATCH";
    /** Delete existing row. Contains the id. Generated by DELETE statements. */
    UpdateType["DELETE"] = "DELETE";
})(UpdateType || (UpdateType = {}));
/**
 * A single client-side change.
 */
class CrudEntry {
    /**
     * Auto-incrementing client-side id.
     */
    clientId;
    /**
     * ID of the changed row.
     */
    id;
    /**
     * Type of change.
     */
    op;
    /**
     * Data associated with the change.
     */
    opData;
    /**
     * For tables where the `trackPreviousValues` option has been enabled, this tracks previous values for
     * `UPDATE` and `DELETE` statements.
     */
    previousValues;
    /**
     * Table that contained the change.
     */
    table;
    /**
     * Auto-incrementing transaction id. This is the same for all operations within the same transaction.
     */
    transactionId;
    /**
     * Client-side metadata attached with this write.
     *
     * This field is only available when the `trackMetadata` option was set to `true` when creating a table
     * and the insert or update statement set the `_metadata` column.
     */
    metadata;
    static fromRow(dbRow) {
        const data = JSON.parse(dbRow.data);
        return new CrudEntry(parseInt(dbRow.id), data.op, data.type, data.id, dbRow.tx_id, data.data, data.old, data.metadata);
    }
    constructor(clientId, op, table, id, transactionId, opData, previousValues, metadata) {
        this.clientId = clientId;
        this.id = id;
        this.op = op;
        this.opData = opData;
        this.table = table;
        this.transactionId = transactionId;
        this.previousValues = previousValues;
        this.metadata = metadata;
    }
    /**
     * Converts the change to JSON format.
     */
    toJSON() {
        return {
            op_id: this.clientId,
            op: this.op,
            type: this.table,
            id: this.id,
            tx_id: this.transactionId,
            data: this.opData,
            old: this.previousValues,
            metadata: this.metadata
        };
    }
    equals(entry) {
        return JSON.stringify(this.toComparisonArray()) == JSON.stringify(entry.toComparisonArray());
    }
    /**
     * The hash code for this object.
     * @deprecated This should not be necessary in the JS SDK.
     * Use the  @see CrudEntry#equals method instead.
     * TODO remove in the next major release.
     */
    hashCode() {
        return JSON.stringify(this.toComparisonArray());
    }
    /**
     * Generates an array for use in deep comparison operations
     */
    toComparisonArray() {
        return [
            this.transactionId,
            this.clientId,
            this.op,
            this.table,
            this.id,
            this.opData,
            this.previousValues,
            this.metadata
        ];
    }
}

class CrudTransaction extends CrudBatch {
    crud;
    complete;
    transactionId;
    constructor(
    /**
     * List of client-side changes.
     */
    crud, 
    /**
     * Call to remove the changes from the local queue, once successfully uploaded.
     */
    complete, 
    /**
     * If null, this contains a list of changes recorded without an explicit transaction associated.
     */
    transactionId) {
        super(crud, false, complete);
        this.crud = crud;
        this.complete = complete;
        this.transactionId = transactionId;
    }
}

/**
 * Calls to Abortcontroller.abort(reason: any) will result in the
 * `reason` being thrown. This is not necessarily an error,
 *  but extends error for better logging purposes.
 */
class AbortOperation extends Error {
    reason;
    constructor(reason) {
        super(reason);
        this.reason = reason;
        // Set the prototype explicitly
        Object.setPrototypeOf(this, AbortOperation.prototype);
        // Capture stack trace
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, AbortOperation);
        }
    }
}

var OpTypeEnum;
(function (OpTypeEnum) {
    OpTypeEnum[OpTypeEnum["CLEAR"] = 1] = "CLEAR";
    OpTypeEnum[OpTypeEnum["MOVE"] = 2] = "MOVE";
    OpTypeEnum[OpTypeEnum["PUT"] = 3] = "PUT";
    OpTypeEnum[OpTypeEnum["REMOVE"] = 4] = "REMOVE";
})(OpTypeEnum || (OpTypeEnum = {}));
/**
 * Used internally for sync buckets.
 */
class OpType {
    value;
    static fromJSON(jsonValue) {
        return new OpType(OpTypeEnum[jsonValue]);
    }
    constructor(value) {
        this.value = value;
    }
    toJSON() {
        return Object.entries(OpTypeEnum).find(([, value]) => value === this.value)[0];
    }
}

class OplogEntry {
    op_id;
    op;
    checksum;
    subkey;
    object_type;
    object_id;
    data;
    static fromRow(row) {
        return new OplogEntry(row.op_id, OpType.fromJSON(row.op), row.checksum, row.subkey, row.object_type, row.object_id, row.data);
    }
    constructor(op_id, op, checksum, subkey, object_type, object_id, data) {
        this.op_id = op_id;
        this.op = op;
        this.checksum = checksum;
        this.subkey = subkey;
        this.object_type = object_type;
        this.object_id = object_id;
        this.data = data;
    }
    toJSON(fixedKeyEncoding = false) {
        return {
            op_id: this.op_id,
            op: this.op.toJSON(),
            object_type: this.object_type,
            object_id: this.object_id,
            checksum: this.checksum,
            data: this.data,
            // Older versions of the JS SDK used to always JSON.stringify here. That has always been wrong,
            // but we need to migrate gradually to not break existing databases.
            subkey: fixedKeyEncoding ? this.subkey : JSON.stringify(this.subkey)
        };
    }
}

class SyncDataBucket {
    bucket;
    data;
    has_more;
    after;
    next_after;
    static fromRow(row) {
        return new SyncDataBucket(row.bucket, row.data.map((entry) => OplogEntry.fromRow(entry)), row.has_more ?? false, row.after, row.next_after);
    }
    constructor(bucket, data, 
    /**
     * True if the response does not contain all the data for this bucket, and another request must be made.
     */
    has_more, 
    /**
     * The `after` specified in the request.
     */
    after, 
    /**
     * Use this for the next request.
     */
    next_after) {
        this.bucket = bucket;
        this.data = data;
        this.has_more = has_more;
        this.after = after;
        this.next_after = next_after;
    }
    toJSON(fixedKeyEncoding = false) {
        return {
            bucket: this.bucket,
            has_more: this.has_more,
            after: this.after,
            next_after: this.next_after,
            data: this.data.map((entry) => entry.toJSON(fixedKeyEncoding))
        };
    }
}

var buffer$1 = {};

var base64Js = {};

var hasRequiredBase64Js;

function requireBase64Js () {
	if (hasRequiredBase64Js) return base64Js;
	hasRequiredBase64Js = 1;

	base64Js.byteLength = byteLength;
	base64Js.toByteArray = toByteArray;
	base64Js.fromByteArray = fromByteArray;

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}

	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;

	function getLens (b64) {
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=');
	  if (validLen === -1) validLen = len;

	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4);

	  return [validLen, placeHoldersLen]
	}

	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function toByteArray (b64) {
	  var tmp;
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];

	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

	  var curByte = 0;

	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen;

	  var i;
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)];
	    arr[curByte++] = (tmp >> 16) & 0xFF;
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    );
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    );
	  }

	  return parts.join('')
	}
	return base64Js;
}

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredIeee754;

function requireIeee754 () {
	if (hasRequiredIeee754) return ieee754;
	hasRequiredIeee754 = 1;
	ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};
	return ieee754;
}

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var hasRequiredBuffer$1;

function requireBuffer$1 () {
	if (hasRequiredBuffer$1) return buffer$1;
	hasRequiredBuffer$1 = 1;
	(function (exports) {

		const base64 = requireBase64Js();
		const ieee754 = requireIeee754();
		const customInspectSymbol =
		  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
		    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
		    : null;

		exports.Buffer = Buffer;
		exports.SlowBuffer = SlowBuffer;
		exports.INSPECT_MAX_BYTES = 50;

		const K_MAX_LENGTH = 0x7fffffff;
		exports.kMaxLength = K_MAX_LENGTH;

		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
		 *               implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * We report that the browser does not support typed arrays if the are not subclassable
		 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
		 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
		 * for __proto__ and has a buggy typed array implementation.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

		if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
		    typeof console.error === 'function') {
		  console.error(
		    'This browser lacks typed array (Uint8Array) support which is required by ' +
		    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
		  );
		}

		function typedArraySupport () {
		  // Can typed array instances can be augmented?
		  try {
		    const arr = new Uint8Array(1);
		    const proto = { foo: function () { return 42 } };
		    Object.setPrototypeOf(proto, Uint8Array.prototype);
		    Object.setPrototypeOf(arr, proto);
		    return arr.foo() === 42
		  } catch (e) {
		    return false
		  }
		}

		Object.defineProperty(Buffer.prototype, 'parent', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.buffer
		  }
		});

		Object.defineProperty(Buffer.prototype, 'offset', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.byteOffset
		  }
		});

		function createBuffer (length) {
		  if (length > K_MAX_LENGTH) {
		    throw new RangeError('The value "' + length + '" is invalid for option "size"')
		  }
		  // Return an augmented `Uint8Array` instance
		  const buf = new Uint8Array(length);
		  Object.setPrototypeOf(buf, Buffer.prototype);
		  return buf
		}

		/**
		 * The Buffer constructor returns instances of `Uint8Array` that have their
		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
		 * returns a single octet.
		 *
		 * The `Uint8Array` prototype remains unmodified.
		 */

		function Buffer (arg, encodingOrOffset, length) {
		  // Common case.
		  if (typeof arg === 'number') {
		    if (typeof encodingOrOffset === 'string') {
		      throw new TypeError(
		        'The "string" argument must be of type string. Received type number'
		      )
		    }
		    return allocUnsafe(arg)
		  }
		  return from(arg, encodingOrOffset, length)
		}

		Buffer.poolSize = 8192; // not used by this implementation

		function from (value, encodingOrOffset, length) {
		  if (typeof value === 'string') {
		    return fromString(value, encodingOrOffset)
		  }

		  if (ArrayBuffer.isView(value)) {
		    return fromArrayView(value)
		  }

		  if (value == null) {
		    throw new TypeError(
		      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		      'or Array-like Object. Received type ' + (typeof value)
		    )
		  }

		  if (isInstance(value, ArrayBuffer) ||
		      (value && isInstance(value.buffer, ArrayBuffer))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof SharedArrayBuffer !== 'undefined' &&
		      (isInstance(value, SharedArrayBuffer) ||
		      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof value === 'number') {
		    throw new TypeError(
		      'The "value" argument must not be of type number. Received type number'
		    )
		  }

		  const valueOf = value.valueOf && value.valueOf();
		  if (valueOf != null && valueOf !== value) {
		    return Buffer.from(valueOf, encodingOrOffset, length)
		  }

		  const b = fromObject(value);
		  if (b) return b

		  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
		      typeof value[Symbol.toPrimitive] === 'function') {
		    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
		  }

		  throw new TypeError(
		    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		    'or Array-like Object. Received type ' + (typeof value)
		  )
		}

		/**
		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		 * if value is a number.
		 * Buffer.from(str[, encoding])
		 * Buffer.from(array)
		 * Buffer.from(buffer)
		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
		 **/
		Buffer.from = function (value, encodingOrOffset, length) {
		  return from(value, encodingOrOffset, length)
		};

		// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
		// https://github.com/feross/buffer/pull/148
		Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
		Object.setPrototypeOf(Buffer, Uint8Array);

		function assertSize (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('"size" argument must be of type number')
		  } else if (size < 0) {
		    throw new RangeError('The value "' + size + '" is invalid for option "size"')
		  }
		}

		function alloc (size, fill, encoding) {
		  assertSize(size);
		  if (size <= 0) {
		    return createBuffer(size)
		  }
		  if (fill !== undefined) {
		    // Only pay attention to encoding if it's a string. This
		    // prevents accidentally sending in a number that would
		    // be interpreted as a start offset.
		    return typeof encoding === 'string'
		      ? createBuffer(size).fill(fill, encoding)
		      : createBuffer(size).fill(fill)
		  }
		  return createBuffer(size)
		}

		/**
		 * Creates a new filled Buffer instance.
		 * alloc(size[, fill[, encoding]])
		 **/
		Buffer.alloc = function (size, fill, encoding) {
		  return alloc(size, fill, encoding)
		};

		function allocUnsafe (size) {
		  assertSize(size);
		  return createBuffer(size < 0 ? 0 : checked(size) | 0)
		}

		/**
		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		 * */
		Buffer.allocUnsafe = function (size) {
		  return allocUnsafe(size)
		};
		/**
		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		 */
		Buffer.allocUnsafeSlow = function (size) {
		  return allocUnsafe(size)
		};

		function fromString (string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') {
		    encoding = 'utf8';
		  }

		  if (!Buffer.isEncoding(encoding)) {
		    throw new TypeError('Unknown encoding: ' + encoding)
		  }

		  const length = byteLength(string, encoding) | 0;
		  let buf = createBuffer(length);

		  const actual = buf.write(string, encoding);

		  if (actual !== length) {
		    // Writing a hex string, for example, that contains invalid characters will
		    // cause everything after the first invalid character to be ignored. (e.g.
		    // 'abxxcd' will be treated as 'ab')
		    buf = buf.slice(0, actual);
		  }

		  return buf
		}

		function fromArrayLike (array) {
		  const length = array.length < 0 ? 0 : checked(array.length) | 0;
		  const buf = createBuffer(length);
		  for (let i = 0; i < length; i += 1) {
		    buf[i] = array[i] & 255;
		  }
		  return buf
		}

		function fromArrayView (arrayView) {
		  if (isInstance(arrayView, Uint8Array)) {
		    const copy = new Uint8Array(arrayView);
		    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
		  }
		  return fromArrayLike(arrayView)
		}

		function fromArrayBuffer (array, byteOffset, length) {
		  if (byteOffset < 0 || array.byteLength < byteOffset) {
		    throw new RangeError('"offset" is outside of buffer bounds')
		  }

		  if (array.byteLength < byteOffset + (length || 0)) {
		    throw new RangeError('"length" is outside of buffer bounds')
		  }

		  let buf;
		  if (byteOffset === undefined && length === undefined) {
		    buf = new Uint8Array(array);
		  } else if (length === undefined) {
		    buf = new Uint8Array(array, byteOffset);
		  } else {
		    buf = new Uint8Array(array, byteOffset, length);
		  }

		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(buf, Buffer.prototype);

		  return buf
		}

		function fromObject (obj) {
		  if (Buffer.isBuffer(obj)) {
		    const len = checked(obj.length) | 0;
		    const buf = createBuffer(len);

		    if (buf.length === 0) {
		      return buf
		    }

		    obj.copy(buf, 0, 0, len);
		    return buf
		  }

		  if (obj.length !== undefined) {
		    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
		      return createBuffer(0)
		    }
		    return fromArrayLike(obj)
		  }

		  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
		    return fromArrayLike(obj.data)
		  }
		}

		function checked (length) {
		  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= K_MAX_LENGTH) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
		  }
		  return length | 0
		}

		function SlowBuffer (length) {
		  if (+length != length) { // eslint-disable-line eqeqeq
		    length = 0;
		  }
		  return Buffer.alloc(+length)
		}

		Buffer.isBuffer = function isBuffer (b) {
		  return b != null && b._isBuffer === true &&
		    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
		};

		Buffer.compare = function compare (a, b) {
		  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
		  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError(
		      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
		    )
		  }

		  if (a === b) return 0

		  let x = a.length;
		  let y = b.length;

		  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i];
		      y = b[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'latin1':
		    case 'binary':
		    case 'base64':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		};

		Buffer.concat = function concat (list, length) {
		  if (!Array.isArray(list)) {
		    throw new TypeError('"list" argument must be an Array of Buffers')
		  }

		  if (list.length === 0) {
		    return Buffer.alloc(0)
		  }

		  let i;
		  if (length === undefined) {
		    length = 0;
		    for (i = 0; i < list.length; ++i) {
		      length += list[i].length;
		    }
		  }

		  const buffer = Buffer.allocUnsafe(length);
		  let pos = 0;
		  for (i = 0; i < list.length; ++i) {
		    let buf = list[i];
		    if (isInstance(buf, Uint8Array)) {
		      if (pos + buf.length > buffer.length) {
		        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
		        buf.copy(buffer, pos);
		      } else {
		        Uint8Array.prototype.set.call(
		          buffer,
		          buf,
		          pos
		        );
		      }
		    } else if (!Buffer.isBuffer(buf)) {
		      throw new TypeError('"list" argument must be an Array of Buffers')
		    } else {
		      buf.copy(buffer, pos);
		    }
		    pos += buf.length;
		  }
		  return buffer
		};

		function byteLength (string, encoding) {
		  if (Buffer.isBuffer(string)) {
		    return string.length
		  }
		  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
		    return string.byteLength
		  }
		  if (typeof string !== 'string') {
		    throw new TypeError(
		      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
		      'Received type ' + typeof string
		    )
		  }

		  const len = string.length;
		  const mustMatch = (arguments.length > 2 && arguments[2] === true);
		  if (!mustMatch && len === 0) return 0

		  // Use a for loop to avoid recursion
		  let loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return len
		      case 'utf8':
		      case 'utf-8':
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) {
		          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
		        }
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		}
		Buffer.byteLength = byteLength;

		function slowToString (encoding, start, end) {
		  let loweredCase = false;

		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		  // property of a typed array.

		  // This behaves neither like String nor Uint8Array in that we set start/end
		  // to their upper/lower bounds if the value passed is out of range.
		  // undefined is handled specially as per ECMA-262 6th Edition,
		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		  if (start === undefined || start < 0) {
		    start = 0;
		  }
		  // Return early if start > this.length. Done here to prevent potential uint32
		  // coercion fail below.
		  if (start > this.length) {
		    return ''
		  }

		  if (end === undefined || end > this.length) {
		    end = this.length;
		  }

		  if (end <= 0) {
		    return ''
		  }

		  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
		  end >>>= 0;
		  start >>>= 0;

		  if (end <= start) {
		    return ''
		  }

		  if (!encoding) encoding = 'utf8';

		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)

		      case 'ascii':
		        return asciiSlice(this, start, end)

		      case 'latin1':
		      case 'binary':
		        return latin1Slice(this, start, end)

		      case 'base64':
		        return base64Slice(this, start, end)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase();
		        loweredCase = true;
		    }
		  }
		}

		// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
		// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
		// reliably in a browserify context because there could be multiple different
		// copies of the 'buffer' package in use. This method works even for Buffer
		// instances that were created from another copy of the `buffer` package.
		// See: https://github.com/feross/buffer/issues/154
		Buffer.prototype._isBuffer = true;

		function swap (b, n, m) {
		  const i = b[n];
		  b[n] = b[m];
		  b[m] = i;
		}

		Buffer.prototype.swap16 = function swap16 () {
		  const len = this.length;
		  if (len % 2 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 16-bits')
		  }
		  for (let i = 0; i < len; i += 2) {
		    swap(this, i, i + 1);
		  }
		  return this
		};

		Buffer.prototype.swap32 = function swap32 () {
		  const len = this.length;
		  if (len % 4 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 32-bits')
		  }
		  for (let i = 0; i < len; i += 4) {
		    swap(this, i, i + 3);
		    swap(this, i + 1, i + 2);
		  }
		  return this
		};

		Buffer.prototype.swap64 = function swap64 () {
		  const len = this.length;
		  if (len % 8 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 64-bits')
		  }
		  for (let i = 0; i < len; i += 8) {
		    swap(this, i, i + 7);
		    swap(this, i + 1, i + 6);
		    swap(this, i + 2, i + 5);
		    swap(this, i + 3, i + 4);
		  }
		  return this
		};

		Buffer.prototype.toString = function toString () {
		  const length = this.length;
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		};

		Buffer.prototype.toLocaleString = Buffer.prototype.toString;

		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		};

		Buffer.prototype.inspect = function inspect () {
		  let str = '';
		  const max = exports.INSPECT_MAX_BYTES;
		  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
		  if (this.length > max) str += ' ... ';
		  return '<Buffer ' + str + '>'
		};
		if (customInspectSymbol) {
		  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
		}

		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		  if (isInstance(target, Uint8Array)) {
		    target = Buffer.from(target, target.offset, target.byteLength);
		  }
		  if (!Buffer.isBuffer(target)) {
		    throw new TypeError(
		      'The "target" argument must be one of type Buffer or Uint8Array. ' +
		      'Received type ' + (typeof target)
		    )
		  }

		  if (start === undefined) {
		    start = 0;
		  }
		  if (end === undefined) {
		    end = target ? target.length : 0;
		  }
		  if (thisStart === undefined) {
		    thisStart = 0;
		  }
		  if (thisEnd === undefined) {
		    thisEnd = this.length;
		  }

		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		    throw new RangeError('out of range index')
		  }

		  if (thisStart >= thisEnd && start >= end) {
		    return 0
		  }
		  if (thisStart >= thisEnd) {
		    return -1
		  }
		  if (start >= end) {
		    return 1
		  }

		  start >>>= 0;
		  end >>>= 0;
		  thisStart >>>= 0;
		  thisEnd >>>= 0;

		  if (this === target) return 0

		  let x = thisEnd - thisStart;
		  let y = end - start;
		  const len = Math.min(x, y);

		  const thisCopy = this.slice(thisStart, thisEnd);
		  const targetCopy = target.slice(start, end);

		  for (let i = 0; i < len; ++i) {
		    if (thisCopy[i] !== targetCopy[i]) {
		      x = thisCopy[i];
		      y = targetCopy[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
		//
		// Arguments:
		// - buffer - a Buffer to search
		// - val - a string, Buffer, or number
		// - byteOffset - an index into `buffer`; will be clamped to an int32
		// - encoding - an optional encoding, relevant is val is a string
		// - dir - true for indexOf, false for lastIndexOf
		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		  // Empty buffer means no match
		  if (buffer.length === 0) return -1

		  // Normalize byteOffset
		  if (typeof byteOffset === 'string') {
		    encoding = byteOffset;
		    byteOffset = 0;
		  } else if (byteOffset > 0x7fffffff) {
		    byteOffset = 0x7fffffff;
		  } else if (byteOffset < -2147483648) {
		    byteOffset = -2147483648;
		  }
		  byteOffset = +byteOffset; // Coerce to Number.
		  if (numberIsNaN(byteOffset)) {
		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
		    byteOffset = dir ? 0 : (buffer.length - 1);
		  }

		  // Normalize byteOffset: negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
		  if (byteOffset >= buffer.length) {
		    if (dir) return -1
		    else byteOffset = buffer.length - 1;
		  } else if (byteOffset < 0) {
		    if (dir) byteOffset = 0;
		    else return -1
		  }

		  // Normalize val
		  if (typeof val === 'string') {
		    val = Buffer.from(val, encoding);
		  }

		  // Finally, search either indexOf (if dir is true) or lastIndexOf
		  if (Buffer.isBuffer(val)) {
		    // Special case: looking for empty string/buffer always fails
		    if (val.length === 0) {
		      return -1
		    }
		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		  } else if (typeof val === 'number') {
		    val = val & 0xFF; // Search for a byte value [0-255]
		    if (typeof Uint8Array.prototype.indexOf === 'function') {
		      if (dir) {
		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
		      } else {
		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
		      }
		    }
		    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
		  }

		  throw new TypeError('val must be string, number or Buffer')
		}

		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		  let indexSize = 1;
		  let arrLength = arr.length;
		  let valLength = val.length;

		  if (encoding !== undefined) {
		    encoding = String(encoding).toLowerCase();
		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
		        encoding === 'utf16le' || encoding === 'utf-16le') {
		      if (arr.length < 2 || val.length < 2) {
		        return -1
		      }
		      indexSize = 2;
		      arrLength /= 2;
		      valLength /= 2;
		      byteOffset /= 2;
		    }
		  }

		  function read (buf, i) {
		    if (indexSize === 1) {
		      return buf[i]
		    } else {
		      return buf.readUInt16BE(i * indexSize)
		    }
		  }

		  let i;
		  if (dir) {
		    let foundIndex = -1;
		    for (i = byteOffset; i < arrLength; i++) {
		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
		        if (foundIndex === -1) foundIndex = i;
		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
		      } else {
		        if (foundIndex !== -1) i -= i - foundIndex;
		        foundIndex = -1;
		      }
		    }
		  } else {
		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
		    for (i = byteOffset; i >= 0; i--) {
		      let found = true;
		      for (let j = 0; j < valLength; j++) {
		        if (read(arr, i + j) !== read(val, j)) {
		          found = false;
		          break
		        }
		      }
		      if (found) return i
		    }
		  }

		  return -1
		}

		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		  return this.indexOf(val, byteOffset, encoding) !== -1
		};

		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		};

		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		};

		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0;
		  const remaining = buf.length - offset;
		  if (!length) {
		    length = remaining;
		  } else {
		    length = Number(length);
		    if (length > remaining) {
		      length = remaining;
		    }
		  }

		  const strLen = string.length;

		  if (length > strLen / 2) {
		    length = strLen / 2;
		  }
		  let i;
		  for (i = 0; i < length; ++i) {
		    const parsed = parseInt(string.substr(i * 2, 2), 16);
		    if (numberIsNaN(parsed)) return i
		    buf[offset + i] = parsed;
		  }
		  return i
		}

		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}

		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}

		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}

		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}

		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8';
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset;
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset >>> 0;
		    if (isFinite(length)) {
		      length = length >>> 0;
		      if (encoding === undefined) encoding = 'utf8';
		    } else {
		      encoding = length;
		      length = undefined;
		    }
		  } else {
		    throw new Error(
		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
		    )
		  }

		  const remaining = this.length - offset;
		  if (length === undefined || length > remaining) length = remaining;

		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('Attempt to write outside buffer bounds')
		  }

		  if (!encoding) encoding = 'utf8';

		  let loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)

		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return asciiWrite(this, string, offset, length)

		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		};

		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		};

		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}

		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end);
		  const res = [];

		  let i = start;
		  while (i < end) {
		    const firstByte = buf[i];
		    let codePoint = null;
		    let bytesPerSequence = (firstByte > 0xEF)
		      ? 4
		      : (firstByte > 0xDF)
		          ? 3
		          : (firstByte > 0xBF)
		              ? 2
		              : 1;

		    if (i + bytesPerSequence <= end) {
		      let secondByte, thirdByte, fourthByte, tempCodePoint;

		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte;
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1];
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          fourthByte = buf[i + 3];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint;
		            }
		          }
		      }
		    }

		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD;
		      bytesPerSequence = 1;
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000;
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
		      codePoint = 0xDC00 | codePoint & 0x3FF;
		    }

		    res.push(codePoint);
		    i += bytesPerSequence;
		  }

		  return decodeCodePointsArray(res)
		}

		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		const MAX_ARGUMENTS_LENGTH = 0x1000;

		function decodeCodePointsArray (codePoints) {
		  const len = codePoints.length;
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }

		  // Decode in chunks to avoid "call stack size exceeded".
		  let res = '';
		  let i = 0;
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    );
		  }
		  return res
		}

		function asciiSlice (buf, start, end) {
		  let ret = '';
		  end = Math.min(buf.length, end);

		  for (let i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i] & 0x7F);
		  }
		  return ret
		}

		function latin1Slice (buf, start, end) {
		  let ret = '';
		  end = Math.min(buf.length, end);

		  for (let i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i]);
		  }
		  return ret
		}

		function hexSlice (buf, start, end) {
		  const len = buf.length;

		  if (!start || start < 0) start = 0;
		  if (!end || end < 0 || end > len) end = len;

		  let out = '';
		  for (let i = start; i < end; ++i) {
		    out += hexSliceLookupTable[buf[i]];
		  }
		  return out
		}

		function utf16leSlice (buf, start, end) {
		  const bytes = buf.slice(start, end);
		  let res = '';
		  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
		  for (let i = 0; i < bytes.length - 1; i += 2) {
		    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
		  }
		  return res
		}

		Buffer.prototype.slice = function slice (start, end) {
		  const len = this.length;
		  start = ~~start;
		  end = end === undefined ? len : ~~end;

		  if (start < 0) {
		    start += len;
		    if (start < 0) start = 0;
		  } else if (start > len) {
		    start = len;
		  }

		  if (end < 0) {
		    end += len;
		    if (end < 0) end = 0;
		  } else if (end > len) {
		    end = len;
		  }

		  if (end < start) end = start;

		  const newBuf = this.subarray(start, end);
		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(newBuf, Buffer.prototype);

		  return newBuf
		};

		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}

		Buffer.prototype.readUintLE =
		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let val = this[offset];
		  let mul = 1;
		  let i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUintBE =
		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length);
		  }

		  let val = this[offset + --byteLength];
		  let mul = 1;
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUint8 =
		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  return this[offset]
		};

		Buffer.prototype.readUint16LE =
		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return this[offset] | (this[offset + 1] << 8)
		};

		Buffer.prototype.readUint16BE =
		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return (this[offset] << 8) | this[offset + 1]
		};

		Buffer.prototype.readUint32LE =
		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		};

		Buffer.prototype.readUint32BE =
		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		};

		Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const lo = first +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 24;

		  const hi = this[++offset] +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    last * 2 ** 24;

		  return BigInt(lo) + (BigInt(hi) << BigInt(32))
		});

		Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const hi = first * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    this[++offset];

		  const lo = this[++offset] * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    last;

		  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
		});

		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let val = this[offset];
		  let mul = 1;
		  let i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let i = byteLength;
		  let mul = 1;
		  let val = this[offset + --i];
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		};

		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  const val = this[offset] | (this[offset + 1] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  const val = this[offset + 1] | (this[offset] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		};

		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		};

		Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const val = this[offset + 4] +
		    this[offset + 5] * 2 ** 8 +
		    this[offset + 6] * 2 ** 16 +
		    (last << 24); // Overflow

		  return (BigInt(val) << BigInt(32)) +
		    BigInt(first +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 24)
		});

		Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const val = (first << 24) + // Overflow
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    this[++offset];

		  return (BigInt(val) << BigInt(32)) +
		    BigInt(this[++offset] * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    last)
		});

		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, true, 23, 4)
		};

		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, false, 23, 4)
		};

		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, true, 52, 8)
		};

		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, false, 52, 8)
		};

		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}

		Buffer.prototype.writeUintLE =
		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  let mul = 1;
		  let i = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUintBE =
		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  let i = byteLength - 1;
		  let mul = 1;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUint8 =
		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeUint16LE =
		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeUint16BE =
		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeUint32LE =
		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset + 3] = (value >>> 24);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 1] = (value >>> 8);
		  this[offset] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeUint32BE =
		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		function wrtBigUInt64LE (buf, value, offset, min, max) {
		  checkIntBI(value, min, max, buf, offset, 7);

		  let lo = Number(value & BigInt(0xffffffff));
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  return offset
		}

		function wrtBigUInt64BE (buf, value, offset, min, max) {
		  checkIntBI(value, min, max, buf, offset, 7);

		  let lo = Number(value & BigInt(0xffffffff));
		  buf[offset + 7] = lo;
		  lo = lo >> 8;
		  buf[offset + 6] = lo;
		  lo = lo >> 8;
		  buf[offset + 5] = lo;
		  lo = lo >> 8;
		  buf[offset + 4] = lo;
		  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
		  buf[offset + 3] = hi;
		  hi = hi >> 8;
		  buf[offset + 2] = hi;
		  hi = hi >> 8;
		  buf[offset + 1] = hi;
		  hi = hi >> 8;
		  buf[offset] = hi;
		  return offset + 8
		}

		Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
		  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
		});

		Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
		  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
		});

		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    const limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  let i = 0;
		  let mul = 1;
		  let sub = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    const limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  let i = byteLength - 1;
		  let mul = 1;
		  let sub = 0;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
		  if (value < 0) value = 0xff + value + 1;
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 3] = (value >>> 24);
		  return offset + 4
		};

		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  if (value < 0) value = 0xffffffff + value + 1;
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
		  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
		});

		Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
		  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
		});

		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		  if (offset < 0) throw new RangeError('Index out of range')
		}

		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4);
		  return offset + 4
		}

		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		};

		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8);
		  return offset + 8
		}

		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		};

		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
		  if (!start) start = 0;
		  if (!end && end !== 0) end = this.length;
		  if (targetStart >= target.length) targetStart = target.length;
		  if (!targetStart) targetStart = 0;
		  if (end > 0 && end < start) end = start;

		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0

		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

		  // Are we oob?
		  if (end > this.length) end = this.length;
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start;
		  }

		  const len = end - start;

		  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
		    // Use built-in when available, missing from IE11
		    this.copyWithin(targetStart, start, end);
		  } else {
		    Uint8Array.prototype.set.call(
		      target,
		      this.subarray(start, end),
		      targetStart
		    );
		  }

		  return len
		};

		// Usage:
		//    buffer.fill(number[, offset[, end]])
		//    buffer.fill(buffer[, offset[, end]])
		//    buffer.fill(string[, offset[, end]][, encoding])
		Buffer.prototype.fill = function fill (val, start, end, encoding) {
		  // Handle string cases:
		  if (typeof val === 'string') {
		    if (typeof start === 'string') {
		      encoding = start;
		      start = 0;
		      end = this.length;
		    } else if (typeof end === 'string') {
		      encoding = end;
		      end = this.length;
		    }
		    if (encoding !== undefined && typeof encoding !== 'string') {
		      throw new TypeError('encoding must be a string')
		    }
		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
		      throw new TypeError('Unknown encoding: ' + encoding)
		    }
		    if (val.length === 1) {
		      const code = val.charCodeAt(0);
		      if ((encoding === 'utf8' && code < 128) ||
		          encoding === 'latin1') {
		        // Fast path: If `val` fits into a single byte, use that numeric value.
		        val = code;
		      }
		    }
		  } else if (typeof val === 'number') {
		    val = val & 255;
		  } else if (typeof val === 'boolean') {
		    val = Number(val);
		  }

		  // Invalid ranges are not set to a default, so can range check early.
		  if (start < 0 || this.length < start || this.length < end) {
		    throw new RangeError('Out of range index')
		  }

		  if (end <= start) {
		    return this
		  }

		  start = start >>> 0;
		  end = end === undefined ? this.length : end >>> 0;

		  if (!val) val = 0;

		  let i;
		  if (typeof val === 'number') {
		    for (i = start; i < end; ++i) {
		      this[i] = val;
		    }
		  } else {
		    const bytes = Buffer.isBuffer(val)
		      ? val
		      : Buffer.from(val, encoding);
		    const len = bytes.length;
		    if (len === 0) {
		      throw new TypeError('The value "' + val +
		        '" is invalid for argument "value"')
		    }
		    for (i = 0; i < end - start; ++i) {
		      this[i + start] = bytes[i % len];
		    }
		  }

		  return this
		};

		// CUSTOM ERRORS
		// =============

		// Simplified versions from Node, changed for Buffer-only usage
		const errors = {};
		function E (sym, getMessage, Base) {
		  errors[sym] = class NodeError extends Base {
		    constructor () {
		      super();

		      Object.defineProperty(this, 'message', {
		        value: getMessage.apply(this, arguments),
		        writable: true,
		        configurable: true
		      });

		      // Add the error code to the name to include it in the stack trace.
		      this.name = `${this.name} [${sym}]`;
		      // Access the stack to generate the error message including the error code
		      // from the name.
		      this.stack; // eslint-disable-line no-unused-expressions
		      // Reset the name to the actual name.
		      delete this.name;
		    }

		    get code () {
		      return sym
		    }

		    set code (value) {
		      Object.defineProperty(this, 'code', {
		        configurable: true,
		        enumerable: true,
		        value,
		        writable: true
		      });
		    }

		    toString () {
		      return `${this.name} [${sym}]: ${this.message}`
		    }
		  };
		}

		E('ERR_BUFFER_OUT_OF_BOUNDS',
		  function (name) {
		    if (name) {
		      return `${name} is outside of buffer bounds`
		    }

		    return 'Attempt to access memory outside buffer bounds'
		  }, RangeError);
		E('ERR_INVALID_ARG_TYPE',
		  function (name, actual) {
		    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
		  }, TypeError);
		E('ERR_OUT_OF_RANGE',
		  function (str, range, input) {
		    let msg = `The value of "${str}" is out of range.`;
		    let received = input;
		    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
		      received = addNumericalSeparator(String(input));
		    } else if (typeof input === 'bigint') {
		      received = String(input);
		      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
		        received = addNumericalSeparator(received);
		      }
		      received += 'n';
		    }
		    msg += ` It must be ${range}. Received ${received}`;
		    return msg
		  }, RangeError);

		function addNumericalSeparator (val) {
		  let res = '';
		  let i = val.length;
		  const start = val[0] === '-' ? 1 : 0;
		  for (; i >= start + 4; i -= 3) {
		    res = `_${val.slice(i - 3, i)}${res}`;
		  }
		  return `${val.slice(0, i)}${res}`
		}

		// CHECK FUNCTIONS
		// ===============

		function checkBounds (buf, offset, byteLength) {
		  validateNumber(offset, 'offset');
		  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
		    boundsError(offset, buf.length - (byteLength + 1));
		  }
		}

		function checkIntBI (value, min, max, buf, offset, byteLength) {
		  if (value > max || value < min) {
		    const n = typeof min === 'bigint' ? 'n' : '';
		    let range;
		    {
		      if (min === 0 || min === BigInt(0)) {
		        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
		      } else {
		        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
		                `${(byteLength + 1) * 8 - 1}${n}`;
		      }
		    }
		    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
		  }
		  checkBounds(buf, offset, byteLength);
		}

		function validateNumber (value, name) {
		  if (typeof value !== 'number') {
		    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
		  }
		}

		function boundsError (value, length, type) {
		  if (Math.floor(value) !== value) {
		    validateNumber(value, type);
		    throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value)
		  }

		  if (length < 0) {
		    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
		  }

		  throw new errors.ERR_OUT_OF_RANGE('offset',
		                                    `>= ${0} and <= ${length}`,
		                                    value)
		}

		// HELPER FUNCTIONS
		// ================

		const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

		function base64clean (str) {
		  // Node takes equal signs as end of the Base64 encoding
		  str = str.split('=')[0];
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = str.trim().replace(INVALID_BASE64_RE, '');
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '=';
		  }
		  return str
		}

		function utf8ToBytes (string, units) {
		  units = units || Infinity;
		  let codePoint;
		  const length = string.length;
		  let leadSurrogate = null;
		  const bytes = [];

		  for (let i = 0; i < length; ++i) {
		    codePoint = string.charCodeAt(i);

		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        }

		        // valid lead
		        leadSurrogate = codePoint;

		        continue
		      }

		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		        leadSurrogate = codePoint;
		        continue
		      }

		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		    }

		    leadSurrogate = null;

		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint);
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }

		  return bytes
		}

		function asciiToBytes (str) {
		  const byteArray = [];
		  for (let i = 0; i < str.length; ++i) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF);
		  }
		  return byteArray
		}

		function utf16leToBytes (str, units) {
		  let c, hi, lo;
		  const byteArray = [];
		  for (let i = 0; i < str.length; ++i) {
		    if ((units -= 2) < 0) break

		    c = str.charCodeAt(i);
		    hi = c >> 8;
		    lo = c % 256;
		    byteArray.push(lo);
		    byteArray.push(hi);
		  }

		  return byteArray
		}

		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}

		function blitBuffer (src, dst, offset, length) {
		  let i;
		  for (i = 0; i < length; ++i) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i];
		  }
		  return i
		}

		// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
		// the `instanceof` check but they should be treated as of that type.
		// See: https://github.com/feross/buffer/issues/166
		function isInstance (obj, type) {
		  return obj instanceof type ||
		    (obj != null && obj.constructor != null && obj.constructor.name != null &&
		      obj.constructor.name === type.name)
		}
		function numberIsNaN (obj) {
		  // For IE11 support
		  return obj !== obj // eslint-disable-line no-self-compare
		}

		// Create lookup table for `toString('hex')`
		// See: https://github.com/feross/buffer/issues/219
		const hexSliceLookupTable = (function () {
		  const alphabet = '0123456789abcdef';
		  const table = new Array(256);
		  for (let i = 0; i < 16; ++i) {
		    const i16 = i * 16;
		    for (let j = 0; j < 16; ++j) {
		      table[i16 + j] = alphabet[i] + alphabet[j];
		    }
		  }
		  return table
		})();

		// Return not function with Error if BigInt not supported
		function defineBigIntMethod (fn) {
		  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
		}

		function BufferBigIntNotDefined () {
		  throw new Error('BigInt not supported')
		} 
	} (buffer$1));
	return buffer$1;
}

var bufferExports$1 = requireBuffer$1();

var dist = {};

var buffer = {};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var hasRequiredBuffer;

function requireBuffer () {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	(function (exports) {

		var base64 = requireBase64Js();
		var ieee754 = requireIeee754();
		var customInspectSymbol =
		  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
		    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
		    : null;

		exports.Buffer = Buffer;
		exports.SlowBuffer = SlowBuffer;
		exports.INSPECT_MAX_BYTES = 50;

		var K_MAX_LENGTH = 0x7fffffff;
		exports.kMaxLength = K_MAX_LENGTH;

		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
		 *               implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * We report that the browser does not support typed arrays if the are not subclassable
		 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
		 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
		 * for __proto__ and has a buggy typed array implementation.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

		if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
		    typeof console.error === 'function') {
		  console.error(
		    'This browser lacks typed array (Uint8Array) support which is required by ' +
		    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
		  );
		}

		function typedArraySupport () {
		  // Can typed array instances can be augmented?
		  try {
		    var arr = new Uint8Array(1);
		    var proto = { foo: function () { return 42 } };
		    Object.setPrototypeOf(proto, Uint8Array.prototype);
		    Object.setPrototypeOf(arr, proto);
		    return arr.foo() === 42
		  } catch (e) {
		    return false
		  }
		}

		Object.defineProperty(Buffer.prototype, 'parent', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.buffer
		  }
		});

		Object.defineProperty(Buffer.prototype, 'offset', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.byteOffset
		  }
		});

		function createBuffer (length) {
		  if (length > K_MAX_LENGTH) {
		    throw new RangeError('The value "' + length + '" is invalid for option "size"')
		  }
		  // Return an augmented `Uint8Array` instance
		  var buf = new Uint8Array(length);
		  Object.setPrototypeOf(buf, Buffer.prototype);
		  return buf
		}

		/**
		 * The Buffer constructor returns instances of `Uint8Array` that have their
		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
		 * returns a single octet.
		 *
		 * The `Uint8Array` prototype remains unmodified.
		 */

		function Buffer (arg, encodingOrOffset, length) {
		  // Common case.
		  if (typeof arg === 'number') {
		    if (typeof encodingOrOffset === 'string') {
		      throw new TypeError(
		        'The "string" argument must be of type string. Received type number'
		      )
		    }
		    return allocUnsafe(arg)
		  }
		  return from(arg, encodingOrOffset, length)
		}

		Buffer.poolSize = 8192; // not used by this implementation

		function from (value, encodingOrOffset, length) {
		  if (typeof value === 'string') {
		    return fromString(value, encodingOrOffset)
		  }

		  if (ArrayBuffer.isView(value)) {
		    return fromArrayView(value)
		  }

		  if (value == null) {
		    throw new TypeError(
		      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		      'or Array-like Object. Received type ' + (typeof value)
		    )
		  }

		  if (isInstance(value, ArrayBuffer) ||
		      (value && isInstance(value.buffer, ArrayBuffer))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof SharedArrayBuffer !== 'undefined' &&
		      (isInstance(value, SharedArrayBuffer) ||
		      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof value === 'number') {
		    throw new TypeError(
		      'The "value" argument must not be of type number. Received type number'
		    )
		  }

		  var valueOf = value.valueOf && value.valueOf();
		  if (valueOf != null && valueOf !== value) {
		    return Buffer.from(valueOf, encodingOrOffset, length)
		  }

		  var b = fromObject(value);
		  if (b) return b

		  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
		      typeof value[Symbol.toPrimitive] === 'function') {
		    return Buffer.from(
		      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
		    )
		  }

		  throw new TypeError(
		    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		    'or Array-like Object. Received type ' + (typeof value)
		  )
		}

		/**
		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		 * if value is a number.
		 * Buffer.from(str[, encoding])
		 * Buffer.from(array)
		 * Buffer.from(buffer)
		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
		 **/
		Buffer.from = function (value, encodingOrOffset, length) {
		  return from(value, encodingOrOffset, length)
		};

		// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
		// https://github.com/feross/buffer/pull/148
		Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
		Object.setPrototypeOf(Buffer, Uint8Array);

		function assertSize (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('"size" argument must be of type number')
		  } else if (size < 0) {
		    throw new RangeError('The value "' + size + '" is invalid for option "size"')
		  }
		}

		function alloc (size, fill, encoding) {
		  assertSize(size);
		  if (size <= 0) {
		    return createBuffer(size)
		  }
		  if (fill !== undefined) {
		    // Only pay attention to encoding if it's a string. This
		    // prevents accidentally sending in a number that would
		    // be interpreted as a start offset.
		    return typeof encoding === 'string'
		      ? createBuffer(size).fill(fill, encoding)
		      : createBuffer(size).fill(fill)
		  }
		  return createBuffer(size)
		}

		/**
		 * Creates a new filled Buffer instance.
		 * alloc(size[, fill[, encoding]])
		 **/
		Buffer.alloc = function (size, fill, encoding) {
		  return alloc(size, fill, encoding)
		};

		function allocUnsafe (size) {
		  assertSize(size);
		  return createBuffer(size < 0 ? 0 : checked(size) | 0)
		}

		/**
		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		 * */
		Buffer.allocUnsafe = function (size) {
		  return allocUnsafe(size)
		};
		/**
		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		 */
		Buffer.allocUnsafeSlow = function (size) {
		  return allocUnsafe(size)
		};

		function fromString (string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') {
		    encoding = 'utf8';
		  }

		  if (!Buffer.isEncoding(encoding)) {
		    throw new TypeError('Unknown encoding: ' + encoding)
		  }

		  var length = byteLength(string, encoding) | 0;
		  var buf = createBuffer(length);

		  var actual = buf.write(string, encoding);

		  if (actual !== length) {
		    // Writing a hex string, for example, that contains invalid characters will
		    // cause everything after the first invalid character to be ignored. (e.g.
		    // 'abxxcd' will be treated as 'ab')
		    buf = buf.slice(0, actual);
		  }

		  return buf
		}

		function fromArrayLike (array) {
		  var length = array.length < 0 ? 0 : checked(array.length) | 0;
		  var buf = createBuffer(length);
		  for (var i = 0; i < length; i += 1) {
		    buf[i] = array[i] & 255;
		  }
		  return buf
		}

		function fromArrayView (arrayView) {
		  if (isInstance(arrayView, Uint8Array)) {
		    var copy = new Uint8Array(arrayView);
		    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
		  }
		  return fromArrayLike(arrayView)
		}

		function fromArrayBuffer (array, byteOffset, length) {
		  if (byteOffset < 0 || array.byteLength < byteOffset) {
		    throw new RangeError('"offset" is outside of buffer bounds')
		  }

		  if (array.byteLength < byteOffset + (length || 0)) {
		    throw new RangeError('"length" is outside of buffer bounds')
		  }

		  var buf;
		  if (byteOffset === undefined && length === undefined) {
		    buf = new Uint8Array(array);
		  } else if (length === undefined) {
		    buf = new Uint8Array(array, byteOffset);
		  } else {
		    buf = new Uint8Array(array, byteOffset, length);
		  }

		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(buf, Buffer.prototype);

		  return buf
		}

		function fromObject (obj) {
		  if (Buffer.isBuffer(obj)) {
		    var len = checked(obj.length) | 0;
		    var buf = createBuffer(len);

		    if (buf.length === 0) {
		      return buf
		    }

		    obj.copy(buf, 0, 0, len);
		    return buf
		  }

		  if (obj.length !== undefined) {
		    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
		      return createBuffer(0)
		    }
		    return fromArrayLike(obj)
		  }

		  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
		    return fromArrayLike(obj.data)
		  }
		}

		function checked (length) {
		  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= K_MAX_LENGTH) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
		  }
		  return length | 0
		}

		function SlowBuffer (length) {
		  if (+length != length) { // eslint-disable-line eqeqeq
		    length = 0;
		  }
		  return Buffer.alloc(+length)
		}

		Buffer.isBuffer = function isBuffer (b) {
		  return b != null && b._isBuffer === true &&
		    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
		};

		Buffer.compare = function compare (a, b) {
		  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
		  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError(
		      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
		    )
		  }

		  if (a === b) return 0

		  var x = a.length;
		  var y = b.length;

		  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i];
		      y = b[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'latin1':
		    case 'binary':
		    case 'base64':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		};

		Buffer.concat = function concat (list, length) {
		  if (!Array.isArray(list)) {
		    throw new TypeError('"list" argument must be an Array of Buffers')
		  }

		  if (list.length === 0) {
		    return Buffer.alloc(0)
		  }

		  var i;
		  if (length === undefined) {
		    length = 0;
		    for (i = 0; i < list.length; ++i) {
		      length += list[i].length;
		    }
		  }

		  var buffer = Buffer.allocUnsafe(length);
		  var pos = 0;
		  for (i = 0; i < list.length; ++i) {
		    var buf = list[i];
		    if (isInstance(buf, Uint8Array)) {
		      if (pos + buf.length > buffer.length) {
		        Buffer.from(buf).copy(buffer, pos);
		      } else {
		        Uint8Array.prototype.set.call(
		          buffer,
		          buf,
		          pos
		        );
		      }
		    } else if (!Buffer.isBuffer(buf)) {
		      throw new TypeError('"list" argument must be an Array of Buffers')
		    } else {
		      buf.copy(buffer, pos);
		    }
		    pos += buf.length;
		  }
		  return buffer
		};

		function byteLength (string, encoding) {
		  if (Buffer.isBuffer(string)) {
		    return string.length
		  }
		  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
		    return string.byteLength
		  }
		  if (typeof string !== 'string') {
		    throw new TypeError(
		      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
		      'Received type ' + typeof string
		    )
		  }

		  var len = string.length;
		  var mustMatch = (arguments.length > 2 && arguments[2] === true);
		  if (!mustMatch && len === 0) return 0

		  // Use a for loop to avoid recursion
		  var loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return len
		      case 'utf8':
		      case 'utf-8':
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) {
		          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
		        }
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		}
		Buffer.byteLength = byteLength;

		function slowToString (encoding, start, end) {
		  var loweredCase = false;

		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		  // property of a typed array.

		  // This behaves neither like String nor Uint8Array in that we set start/end
		  // to their upper/lower bounds if the value passed is out of range.
		  // undefined is handled specially as per ECMA-262 6th Edition,
		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		  if (start === undefined || start < 0) {
		    start = 0;
		  }
		  // Return early if start > this.length. Done here to prevent potential uint32
		  // coercion fail below.
		  if (start > this.length) {
		    return ''
		  }

		  if (end === undefined || end > this.length) {
		    end = this.length;
		  }

		  if (end <= 0) {
		    return ''
		  }

		  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
		  end >>>= 0;
		  start >>>= 0;

		  if (end <= start) {
		    return ''
		  }

		  if (!encoding) encoding = 'utf8';

		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)

		      case 'ascii':
		        return asciiSlice(this, start, end)

		      case 'latin1':
		      case 'binary':
		        return latin1Slice(this, start, end)

		      case 'base64':
		        return base64Slice(this, start, end)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase();
		        loweredCase = true;
		    }
		  }
		}

		// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
		// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
		// reliably in a browserify context because there could be multiple different
		// copies of the 'buffer' package in use. This method works even for Buffer
		// instances that were created from another copy of the `buffer` package.
		// See: https://github.com/feross/buffer/issues/154
		Buffer.prototype._isBuffer = true;

		function swap (b, n, m) {
		  var i = b[n];
		  b[n] = b[m];
		  b[m] = i;
		}

		Buffer.prototype.swap16 = function swap16 () {
		  var len = this.length;
		  if (len % 2 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 16-bits')
		  }
		  for (var i = 0; i < len; i += 2) {
		    swap(this, i, i + 1);
		  }
		  return this
		};

		Buffer.prototype.swap32 = function swap32 () {
		  var len = this.length;
		  if (len % 4 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 32-bits')
		  }
		  for (var i = 0; i < len; i += 4) {
		    swap(this, i, i + 3);
		    swap(this, i + 1, i + 2);
		  }
		  return this
		};

		Buffer.prototype.swap64 = function swap64 () {
		  var len = this.length;
		  if (len % 8 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 64-bits')
		  }
		  for (var i = 0; i < len; i += 8) {
		    swap(this, i, i + 7);
		    swap(this, i + 1, i + 6);
		    swap(this, i + 2, i + 5);
		    swap(this, i + 3, i + 4);
		  }
		  return this
		};

		Buffer.prototype.toString = function toString () {
		  var length = this.length;
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		};

		Buffer.prototype.toLocaleString = Buffer.prototype.toString;

		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		};

		Buffer.prototype.inspect = function inspect () {
		  var str = '';
		  var max = exports.INSPECT_MAX_BYTES;
		  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
		  if (this.length > max) str += ' ... ';
		  return '<Buffer ' + str + '>'
		};
		if (customInspectSymbol) {
		  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
		}

		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		  if (isInstance(target, Uint8Array)) {
		    target = Buffer.from(target, target.offset, target.byteLength);
		  }
		  if (!Buffer.isBuffer(target)) {
		    throw new TypeError(
		      'The "target" argument must be one of type Buffer or Uint8Array. ' +
		      'Received type ' + (typeof target)
		    )
		  }

		  if (start === undefined) {
		    start = 0;
		  }
		  if (end === undefined) {
		    end = target ? target.length : 0;
		  }
		  if (thisStart === undefined) {
		    thisStart = 0;
		  }
		  if (thisEnd === undefined) {
		    thisEnd = this.length;
		  }

		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		    throw new RangeError('out of range index')
		  }

		  if (thisStart >= thisEnd && start >= end) {
		    return 0
		  }
		  if (thisStart >= thisEnd) {
		    return -1
		  }
		  if (start >= end) {
		    return 1
		  }

		  start >>>= 0;
		  end >>>= 0;
		  thisStart >>>= 0;
		  thisEnd >>>= 0;

		  if (this === target) return 0

		  var x = thisEnd - thisStart;
		  var y = end - start;
		  var len = Math.min(x, y);

		  var thisCopy = this.slice(thisStart, thisEnd);
		  var targetCopy = target.slice(start, end);

		  for (var i = 0; i < len; ++i) {
		    if (thisCopy[i] !== targetCopy[i]) {
		      x = thisCopy[i];
		      y = targetCopy[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
		//
		// Arguments:
		// - buffer - a Buffer to search
		// - val - a string, Buffer, or number
		// - byteOffset - an index into `buffer`; will be clamped to an int32
		// - encoding - an optional encoding, relevant is val is a string
		// - dir - true for indexOf, false for lastIndexOf
		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		  // Empty buffer means no match
		  if (buffer.length === 0) return -1

		  // Normalize byteOffset
		  if (typeof byteOffset === 'string') {
		    encoding = byteOffset;
		    byteOffset = 0;
		  } else if (byteOffset > 0x7fffffff) {
		    byteOffset = 0x7fffffff;
		  } else if (byteOffset < -2147483648) {
		    byteOffset = -2147483648;
		  }
		  byteOffset = +byteOffset; // Coerce to Number.
		  if (numberIsNaN(byteOffset)) {
		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
		    byteOffset = dir ? 0 : (buffer.length - 1);
		  }

		  // Normalize byteOffset: negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
		  if (byteOffset >= buffer.length) {
		    if (dir) return -1
		    else byteOffset = buffer.length - 1;
		  } else if (byteOffset < 0) {
		    if (dir) byteOffset = 0;
		    else return -1
		  }

		  // Normalize val
		  if (typeof val === 'string') {
		    val = Buffer.from(val, encoding);
		  }

		  // Finally, search either indexOf (if dir is true) or lastIndexOf
		  if (Buffer.isBuffer(val)) {
		    // Special case: looking for empty string/buffer always fails
		    if (val.length === 0) {
		      return -1
		    }
		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		  } else if (typeof val === 'number') {
		    val = val & 0xFF; // Search for a byte value [0-255]
		    if (typeof Uint8Array.prototype.indexOf === 'function') {
		      if (dir) {
		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
		      } else {
		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
		      }
		    }
		    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
		  }

		  throw new TypeError('val must be string, number or Buffer')
		}

		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		  var indexSize = 1;
		  var arrLength = arr.length;
		  var valLength = val.length;

		  if (encoding !== undefined) {
		    encoding = String(encoding).toLowerCase();
		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
		        encoding === 'utf16le' || encoding === 'utf-16le') {
		      if (arr.length < 2 || val.length < 2) {
		        return -1
		      }
		      indexSize = 2;
		      arrLength /= 2;
		      valLength /= 2;
		      byteOffset /= 2;
		    }
		  }

		  function read (buf, i) {
		    if (indexSize === 1) {
		      return buf[i]
		    } else {
		      return buf.readUInt16BE(i * indexSize)
		    }
		  }

		  var i;
		  if (dir) {
		    var foundIndex = -1;
		    for (i = byteOffset; i < arrLength; i++) {
		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
		        if (foundIndex === -1) foundIndex = i;
		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
		      } else {
		        if (foundIndex !== -1) i -= i - foundIndex;
		        foundIndex = -1;
		      }
		    }
		  } else {
		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
		    for (i = byteOffset; i >= 0; i--) {
		      var found = true;
		      for (var j = 0; j < valLength; j++) {
		        if (read(arr, i + j) !== read(val, j)) {
		          found = false;
		          break
		        }
		      }
		      if (found) return i
		    }
		  }

		  return -1
		}

		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		  return this.indexOf(val, byteOffset, encoding) !== -1
		};

		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		};

		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		};

		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0;
		  var remaining = buf.length - offset;
		  if (!length) {
		    length = remaining;
		  } else {
		    length = Number(length);
		    if (length > remaining) {
		      length = remaining;
		    }
		  }

		  var strLen = string.length;

		  if (length > strLen / 2) {
		    length = strLen / 2;
		  }
		  for (var i = 0; i < length; ++i) {
		    var parsed = parseInt(string.substr(i * 2, 2), 16);
		    if (numberIsNaN(parsed)) return i
		    buf[offset + i] = parsed;
		  }
		  return i
		}

		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}

		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}

		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}

		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}

		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8';
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset;
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset >>> 0;
		    if (isFinite(length)) {
		      length = length >>> 0;
		      if (encoding === undefined) encoding = 'utf8';
		    } else {
		      encoding = length;
		      length = undefined;
		    }
		  } else {
		    throw new Error(
		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
		    )
		  }

		  var remaining = this.length - offset;
		  if (length === undefined || length > remaining) length = remaining;

		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('Attempt to write outside buffer bounds')
		  }

		  if (!encoding) encoding = 'utf8';

		  var loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)

		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return asciiWrite(this, string, offset, length)

		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		};

		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		};

		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}

		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end);
		  var res = [];

		  var i = start;
		  while (i < end) {
		    var firstByte = buf[i];
		    var codePoint = null;
		    var bytesPerSequence = (firstByte > 0xEF)
		      ? 4
		      : (firstByte > 0xDF)
		          ? 3
		          : (firstByte > 0xBF)
		              ? 2
		              : 1;

		    if (i + bytesPerSequence <= end) {
		      var secondByte, thirdByte, fourthByte, tempCodePoint;

		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte;
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1];
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          fourthByte = buf[i + 3];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint;
		            }
		          }
		      }
		    }

		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD;
		      bytesPerSequence = 1;
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000;
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
		      codePoint = 0xDC00 | codePoint & 0x3FF;
		    }

		    res.push(codePoint);
		    i += bytesPerSequence;
		  }

		  return decodeCodePointsArray(res)
		}

		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		var MAX_ARGUMENTS_LENGTH = 0x1000;

		function decodeCodePointsArray (codePoints) {
		  var len = codePoints.length;
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }

		  // Decode in chunks to avoid "call stack size exceeded".
		  var res = '';
		  var i = 0;
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    );
		  }
		  return res
		}

		function asciiSlice (buf, start, end) {
		  var ret = '';
		  end = Math.min(buf.length, end);

		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i] & 0x7F);
		  }
		  return ret
		}

		function latin1Slice (buf, start, end) {
		  var ret = '';
		  end = Math.min(buf.length, end);

		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i]);
		  }
		  return ret
		}

		function hexSlice (buf, start, end) {
		  var len = buf.length;

		  if (!start || start < 0) start = 0;
		  if (!end || end < 0 || end > len) end = len;

		  var out = '';
		  for (var i = start; i < end; ++i) {
		    out += hexSliceLookupTable[buf[i]];
		  }
		  return out
		}

		function utf16leSlice (buf, start, end) {
		  var bytes = buf.slice(start, end);
		  var res = '';
		  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
		  for (var i = 0; i < bytes.length - 1; i += 2) {
		    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
		  }
		  return res
		}

		Buffer.prototype.slice = function slice (start, end) {
		  var len = this.length;
		  start = ~~start;
		  end = end === undefined ? len : ~~end;

		  if (start < 0) {
		    start += len;
		    if (start < 0) start = 0;
		  } else if (start > len) {
		    start = len;
		  }

		  if (end < 0) {
		    end += len;
		    if (end < 0) end = 0;
		  } else if (end > len) {
		    end = len;
		  }

		  if (end < start) end = start;

		  var newBuf = this.subarray(start, end);
		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(newBuf, Buffer.prototype);

		  return newBuf
		};

		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}

		Buffer.prototype.readUintLE =
		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var val = this[offset];
		  var mul = 1;
		  var i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUintBE =
		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length);
		  }

		  var val = this[offset + --byteLength];
		  var mul = 1;
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUint8 =
		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  return this[offset]
		};

		Buffer.prototype.readUint16LE =
		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return this[offset] | (this[offset + 1] << 8)
		};

		Buffer.prototype.readUint16BE =
		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return (this[offset] << 8) | this[offset + 1]
		};

		Buffer.prototype.readUint32LE =
		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		};

		Buffer.prototype.readUint32BE =
		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		};

		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var val = this[offset];
		  var mul = 1;
		  var i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var i = byteLength;
		  var mul = 1;
		  var val = this[offset + --i];
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		};

		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  var val = this[offset] | (this[offset + 1] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  var val = this[offset + 1] | (this[offset] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		};

		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		};

		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, true, 23, 4)
		};

		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, false, 23, 4)
		};

		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, true, 52, 8)
		};

		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, false, 52, 8)
		};

		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}

		Buffer.prototype.writeUintLE =
		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  var mul = 1;
		  var i = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUintBE =
		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  var i = byteLength - 1;
		  var mul = 1;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUint8 =
		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeUint16LE =
		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeUint16BE =
		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeUint32LE =
		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset + 3] = (value >>> 24);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 1] = (value >>> 8);
		  this[offset] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeUint32BE =
		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    var limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  var i = 0;
		  var mul = 1;
		  var sub = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    var limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  var i = byteLength - 1;
		  var mul = 1;
		  var sub = 0;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
		  if (value < 0) value = 0xff + value + 1;
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 3] = (value >>> 24);
		  return offset + 4
		};

		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  if (value < 0) value = 0xffffffff + value + 1;
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		  if (offset < 0) throw new RangeError('Index out of range')
		}

		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4);
		  return offset + 4
		}

		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		};

		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8);
		  return offset + 8
		}

		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		};

		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
		  if (!start) start = 0;
		  if (!end && end !== 0) end = this.length;
		  if (targetStart >= target.length) targetStart = target.length;
		  if (!targetStart) targetStart = 0;
		  if (end > 0 && end < start) end = start;

		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0

		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

		  // Are we oob?
		  if (end > this.length) end = this.length;
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start;
		  }

		  var len = end - start;

		  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
		    // Use built-in when available, missing from IE11
		    this.copyWithin(targetStart, start, end);
		  } else {
		    Uint8Array.prototype.set.call(
		      target,
		      this.subarray(start, end),
		      targetStart
		    );
		  }

		  return len
		};

		// Usage:
		//    buffer.fill(number[, offset[, end]])
		//    buffer.fill(buffer[, offset[, end]])
		//    buffer.fill(string[, offset[, end]][, encoding])
		Buffer.prototype.fill = function fill (val, start, end, encoding) {
		  // Handle string cases:
		  if (typeof val === 'string') {
		    if (typeof start === 'string') {
		      encoding = start;
		      start = 0;
		      end = this.length;
		    } else if (typeof end === 'string') {
		      encoding = end;
		      end = this.length;
		    }
		    if (encoding !== undefined && typeof encoding !== 'string') {
		      throw new TypeError('encoding must be a string')
		    }
		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
		      throw new TypeError('Unknown encoding: ' + encoding)
		    }
		    if (val.length === 1) {
		      var code = val.charCodeAt(0);
		      if ((encoding === 'utf8' && code < 128) ||
		          encoding === 'latin1') {
		        // Fast path: If `val` fits into a single byte, use that numeric value.
		        val = code;
		      }
		    }
		  } else if (typeof val === 'number') {
		    val = val & 255;
		  } else if (typeof val === 'boolean') {
		    val = Number(val);
		  }

		  // Invalid ranges are not set to a default, so can range check early.
		  if (start < 0 || this.length < start || this.length < end) {
		    throw new RangeError('Out of range index')
		  }

		  if (end <= start) {
		    return this
		  }

		  start = start >>> 0;
		  end = end === undefined ? this.length : end >>> 0;

		  if (!val) val = 0;

		  var i;
		  if (typeof val === 'number') {
		    for (i = start; i < end; ++i) {
		      this[i] = val;
		    }
		  } else {
		    var bytes = Buffer.isBuffer(val)
		      ? val
		      : Buffer.from(val, encoding);
		    var len = bytes.length;
		    if (len === 0) {
		      throw new TypeError('The value "' + val +
		        '" is invalid for argument "value"')
		    }
		    for (i = 0; i < end - start; ++i) {
		      this[i + start] = bytes[i % len];
		    }
		  }

		  return this
		};

		// HELPER FUNCTIONS
		// ================

		var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

		function base64clean (str) {
		  // Node takes equal signs as end of the Base64 encoding
		  str = str.split('=')[0];
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = str.trim().replace(INVALID_BASE64_RE, '');
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '=';
		  }
		  return str
		}

		function utf8ToBytes (string, units) {
		  units = units || Infinity;
		  var codePoint;
		  var length = string.length;
		  var leadSurrogate = null;
		  var bytes = [];

		  for (var i = 0; i < length; ++i) {
		    codePoint = string.charCodeAt(i);

		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        }

		        // valid lead
		        leadSurrogate = codePoint;

		        continue
		      }

		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		        leadSurrogate = codePoint;
		        continue
		      }

		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		    }

		    leadSurrogate = null;

		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint);
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }

		  return bytes
		}

		function asciiToBytes (str) {
		  var byteArray = [];
		  for (var i = 0; i < str.length; ++i) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF);
		  }
		  return byteArray
		}

		function utf16leToBytes (str, units) {
		  var c, hi, lo;
		  var byteArray = [];
		  for (var i = 0; i < str.length; ++i) {
		    if ((units -= 2) < 0) break

		    c = str.charCodeAt(i);
		    hi = c >> 8;
		    lo = c % 256;
		    byteArray.push(lo);
		    byteArray.push(hi);
		  }

		  return byteArray
		}

		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}

		function blitBuffer (src, dst, offset, length) {
		  for (var i = 0; i < length; ++i) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i];
		  }
		  return i
		}

		// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
		// the `instanceof` check but they should be treated as of that type.
		// See: https://github.com/feross/buffer/issues/166
		function isInstance (obj, type) {
		  return obj instanceof type ||
		    (obj != null && obj.constructor != null && obj.constructor.name != null &&
		      obj.constructor.name === type.name)
		}
		function numberIsNaN (obj) {
		  // For IE11 support
		  return obj !== obj // eslint-disable-line no-self-compare
		}

		// Create lookup table for `toString('hex')`
		// See: https://github.com/feross/buffer/issues/219
		var hexSliceLookupTable = (function () {
		  var alphabet = '0123456789abcdef';
		  var table = new Array(256);
		  for (var i = 0; i < 16; ++i) {
		    var i16 = i * 16;
		    for (var j = 0; j < 16; ++j) {
		      table[i16 + j] = alphabet[i] + alphabet[j];
		    }
		  }
		  return table
		})(); 
	} (buffer));
	return buffer;
}

var bufferExports = requireBuffer();

var Codecs = {};

var Frames = {};

var hasRequiredFrames;

function requireFrames () {
	if (hasRequiredFrames) return Frames;
	hasRequiredFrames = 1;
	(function (exports) {
		/*
		 * Copyright 2021-2022 the original author or authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Frame = exports.Lengths = exports.Flags = exports.FrameTypes = void 0;
		var FrameTypes;
		(function (FrameTypes) {
		    FrameTypes[FrameTypes["RESERVED"] = 0] = "RESERVED";
		    FrameTypes[FrameTypes["SETUP"] = 1] = "SETUP";
		    FrameTypes[FrameTypes["LEASE"] = 2] = "LEASE";
		    FrameTypes[FrameTypes["KEEPALIVE"] = 3] = "KEEPALIVE";
		    FrameTypes[FrameTypes["REQUEST_RESPONSE"] = 4] = "REQUEST_RESPONSE";
		    FrameTypes[FrameTypes["REQUEST_FNF"] = 5] = "REQUEST_FNF";
		    FrameTypes[FrameTypes["REQUEST_STREAM"] = 6] = "REQUEST_STREAM";
		    FrameTypes[FrameTypes["REQUEST_CHANNEL"] = 7] = "REQUEST_CHANNEL";
		    FrameTypes[FrameTypes["REQUEST_N"] = 8] = "REQUEST_N";
		    FrameTypes[FrameTypes["CANCEL"] = 9] = "CANCEL";
		    FrameTypes[FrameTypes["PAYLOAD"] = 10] = "PAYLOAD";
		    FrameTypes[FrameTypes["ERROR"] = 11] = "ERROR";
		    FrameTypes[FrameTypes["METADATA_PUSH"] = 12] = "METADATA_PUSH";
		    FrameTypes[FrameTypes["RESUME"] = 13] = "RESUME";
		    FrameTypes[FrameTypes["RESUME_OK"] = 14] = "RESUME_OK";
		    FrameTypes[FrameTypes["EXT"] = 63] = "EXT";
		})(FrameTypes = exports.FrameTypes || (exports.FrameTypes = {}));
		(function (Flags) {
		    Flags[Flags["NONE"] = 0] = "NONE";
		    Flags[Flags["COMPLETE"] = 64] = "COMPLETE";
		    Flags[Flags["FOLLOWS"] = 128] = "FOLLOWS";
		    Flags[Flags["IGNORE"] = 512] = "IGNORE";
		    Flags[Flags["LEASE"] = 64] = "LEASE";
		    Flags[Flags["METADATA"] = 256] = "METADATA";
		    Flags[Flags["NEXT"] = 32] = "NEXT";
		    Flags[Flags["RESPOND"] = 128] = "RESPOND";
		    Flags[Flags["RESUME_ENABLE"] = 128] = "RESUME_ENABLE";
		})(exports.Flags || (exports.Flags = {}));
		(function (Flags) {
		    function hasMetadata(flags) {
		        return (flags & Flags.METADATA) === Flags.METADATA;
		    }
		    Flags.hasMetadata = hasMetadata;
		    function hasComplete(flags) {
		        return (flags & Flags.COMPLETE) === Flags.COMPLETE;
		    }
		    Flags.hasComplete = hasComplete;
		    function hasNext(flags) {
		        return (flags & Flags.NEXT) === Flags.NEXT;
		    }
		    Flags.hasNext = hasNext;
		    function hasFollows(flags) {
		        return (flags & Flags.FOLLOWS) === Flags.FOLLOWS;
		    }
		    Flags.hasFollows = hasFollows;
		    function hasIgnore(flags) {
		        return (flags & Flags.IGNORE) === Flags.IGNORE;
		    }
		    Flags.hasIgnore = hasIgnore;
		    function hasRespond(flags) {
		        return (flags & Flags.RESPOND) === Flags.RESPOND;
		    }
		    Flags.hasRespond = hasRespond;
		    function hasLease(flags) {
		        return (flags & Flags.LEASE) === Flags.LEASE;
		    }
		    Flags.hasLease = hasLease;
		    function hasResume(flags) {
		        return (flags & Flags.RESUME_ENABLE) === Flags.RESUME_ENABLE;
		    }
		    Flags.hasResume = hasResume;
		})(exports.Flags || (exports.Flags = {}));
		(function (Lengths) {
		    Lengths[Lengths["FRAME"] = 3] = "FRAME";
		    Lengths[Lengths["HEADER"] = 6] = "HEADER";
		    Lengths[Lengths["METADATA"] = 3] = "METADATA";
		    Lengths[Lengths["REQUEST"] = 3] = "REQUEST";
		})(exports.Lengths || (exports.Lengths = {}));
		(function (Frame) {
		    function isConnection(frame) {
		        return frame.streamId === 0;
		    }
		    Frame.isConnection = isConnection;
		    function isRequest(frame) {
		        return (FrameTypes.REQUEST_RESPONSE <= frame.type &&
		            frame.type <= FrameTypes.REQUEST_CHANNEL);
		    }
		    Frame.isRequest = isRequest;
		})(exports.Frame || (exports.Frame = {}));
		
	} (Frames));
	return Frames;
}

var hasRequiredCodecs;

function requireCodecs () {
	if (hasRequiredCodecs) return Codecs;
	hasRequiredCodecs = 1;
	(function (exports) {
		var __generator = (Codecs && Codecs.__generator) || function (thisArg, body) {
		    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
		    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
		    function verb(n) { return function (v) { return step([n, v]); }; }
		    function step(op) {
		        if (f) throw new TypeError("Generator is already executing.");
		        while (_) try {
		            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
		            if (y = 0, t) op = [op[0] & 2, t.value];
		            switch (op[0]) {
		                case 0: case 1: t = op; break;
		                case 4: _.label++; return { value: op[1], done: false };
		                case 5: _.label++; y = op[1]; op = [0]; continue;
		                case 7: op = _.ops.pop(); _.trys.pop(); continue;
		                default:
		                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
		                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
		                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
		                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
		                    if (t[2]) _.ops.pop();
		                    _.trys.pop(); continue;
		            }
		            op = body.call(thisArg, _);
		        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
		        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
		    }
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Deserializer = exports.sizeOfFrame = exports.serializeFrame = exports.deserializeFrame = exports.serializeFrameWithLength = exports.deserializeFrames = exports.deserializeFrameWithLength = exports.writeUInt64BE = exports.readUInt64BE = exports.writeUInt24BE = exports.readUInt24BE = exports.MAX_VERSION = exports.MAX_TTL = exports.MAX_STREAM_ID = exports.MAX_RESUME_LENGTH = exports.MAX_REQUEST_N = exports.MAX_REQUEST_COUNT = exports.MAX_MIME_LENGTH = exports.MAX_METADATA_LENGTH = exports.MAX_LIFETIME = exports.MAX_KEEPALIVE = exports.MAX_CODE = exports.FRAME_TYPE_OFFFSET = exports.FLAGS_MASK = void 0;
		var Frames_1 = requireFrames();
		exports.FLAGS_MASK = 0x3ff; // low 10 bits
		exports.FRAME_TYPE_OFFFSET = 10; // frame type is offset 10 bytes within the uint16 containing type + flags
		exports.MAX_CODE = 0x7fffffff; // uint31
		exports.MAX_KEEPALIVE = 0x7fffffff; // uint31
		exports.MAX_LIFETIME = 0x7fffffff; // uint31
		exports.MAX_METADATA_LENGTH = 0xffffff; // uint24
		exports.MAX_MIME_LENGTH = 0xff; // int8
		exports.MAX_REQUEST_COUNT = 0x7fffffff; // uint31
		exports.MAX_REQUEST_N = 0x7fffffff; // uint31
		exports.MAX_RESUME_LENGTH = 0xffff; // uint16
		exports.MAX_STREAM_ID = 0x7fffffff; // uint31
		exports.MAX_TTL = 0x7fffffff; // uint31
		exports.MAX_VERSION = 0xffff; // uint16
		/**
		 * Mimimum value that would overflow bitwise operators (2^32).
		 */
		var BITWISE_OVERFLOW = 0x100000000;
		/**
		 * Read a uint24 from a buffer starting at the given offset.
		 */
		function readUInt24BE(buffer, offset) {
		    var val1 = buffer.readUInt8(offset) << 16;
		    var val2 = buffer.readUInt8(offset + 1) << 8;
		    var val3 = buffer.readUInt8(offset + 2);
		    return val1 | val2 | val3;
		}
		exports.readUInt24BE = readUInt24BE;
		/**
		 * Writes a uint24 to a buffer starting at the given offset, returning the
		 * offset of the next byte.
		 */
		function writeUInt24BE(buffer, value, offset) {
		    offset = buffer.writeUInt8(value >>> 16, offset); // 3rd byte
		    offset = buffer.writeUInt8((value >>> 8) & 0xff, offset); // 2nd byte
		    return buffer.writeUInt8(value & 0xff, offset); // 1st byte
		}
		exports.writeUInt24BE = writeUInt24BE;
		/**
		 * Read a uint64 (technically supports up to 53 bits per JS number
		 * representation).
		 */
		function readUInt64BE(buffer, offset) {
		    var high = buffer.readUInt32BE(offset);
		    var low = buffer.readUInt32BE(offset + 4);
		    return high * BITWISE_OVERFLOW + low;
		}
		exports.readUInt64BE = readUInt64BE;
		/**
		 * Write a uint64 (technically supports up to 53 bits per JS number
		 * representation).
		 */
		function writeUInt64BE(buffer, value, offset) {
		    var high = (value / BITWISE_OVERFLOW) | 0;
		    var low = value % BITWISE_OVERFLOW;
		    offset = buffer.writeUInt32BE(high, offset); // first half of uint64
		    return buffer.writeUInt32BE(low, offset); // second half of uint64
		}
		exports.writeUInt64BE = writeUInt64BE;
		/**
		 * Frame header is:
		 * - stream id (uint32 = 4)
		 * - type + flags (uint 16 = 2)
		 */
		var FRAME_HEADER_SIZE = 6;
		/**
		 * Size of frame length and metadata length fields.
		 */
		var UINT24_SIZE = 3;
		/**
		 * Reads a frame from a buffer that is prefixed with the frame length.
		 */
		function deserializeFrameWithLength(buffer) {
		    var frameLength = readUInt24BE(buffer, 0);
		    return deserializeFrame(buffer.slice(UINT24_SIZE, UINT24_SIZE + frameLength));
		}
		exports.deserializeFrameWithLength = deserializeFrameWithLength;
		/**
		 * Given a buffer that may contain zero or more length-prefixed frames followed
		 * by zero or more bytes of a (partial) subsequent frame, returns an array of
		 * the frames and an int representing the buffer offset.
		 */
		function deserializeFrames(buffer) {
		    var offset, frameLength, frameStart, frameEnd, frameBuffer, frame;
		    return __generator(this, function (_a) {
		        switch (_a.label) {
		            case 0:
		                offset = 0;
		                _a.label = 1;
		            case 1:
		                if (!(offset + UINT24_SIZE < buffer.length)) return [3 /*break*/, 3];
		                frameLength = readUInt24BE(buffer, offset);
		                frameStart = offset + UINT24_SIZE;
		                frameEnd = frameStart + frameLength;
		                if (frameEnd > buffer.length) {
		                    // not all bytes of next frame received
		                    return [3 /*break*/, 3];
		                }
		                frameBuffer = buffer.slice(frameStart, frameEnd);
		                frame = deserializeFrame(frameBuffer);
		                offset = frameEnd;
		                return [4 /*yield*/, [frame, offset]];
		            case 2:
		                _a.sent();
		                return [3 /*break*/, 1];
		            case 3: return [2 /*return*/];
		        }
		    });
		}
		exports.deserializeFrames = deserializeFrames;
		/**
		 * Writes a frame to a buffer with a length prefix.
		 */
		function serializeFrameWithLength(frame) {
		    var buffer = serializeFrame(frame);
		    var lengthPrefixed = bufferExports.Buffer.allocUnsafe(buffer.length + UINT24_SIZE);
		    writeUInt24BE(lengthPrefixed, buffer.length, 0);
		    buffer.copy(lengthPrefixed, UINT24_SIZE);
		    return lengthPrefixed;
		}
		exports.serializeFrameWithLength = serializeFrameWithLength;
		/**
		 * Read a frame from the buffer.
		 */
		function deserializeFrame(buffer) {
		    var offset = 0;
		    var streamId = buffer.readInt32BE(offset);
		    offset += 4;
		    // invariant(
		    //   streamId >= 0,
		    //   'RSocketBinaryFraming: Invalid frame, expected a positive stream id, got `%s.',
		    //   streamId,
		    // );
		    var typeAndFlags = buffer.readUInt16BE(offset);
		    offset += 2;
		    var type = typeAndFlags >>> exports.FRAME_TYPE_OFFFSET; // keep highest 6 bits
		    var flags = typeAndFlags & exports.FLAGS_MASK; // keep lowest 10 bits
		    switch (type) {
		        case Frames_1.FrameTypes.SETUP:
		            return deserializeSetupFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.PAYLOAD:
		            return deserializePayloadFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.ERROR:
		            return deserializeErrorFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.KEEPALIVE:
		            return deserializeKeepAliveFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.REQUEST_FNF:
		            return deserializeRequestFnfFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.REQUEST_RESPONSE:
		            return deserializeRequestResponseFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.REQUEST_STREAM:
		            return deserializeRequestStreamFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.REQUEST_CHANNEL:
		            return deserializeRequestChannelFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.METADATA_PUSH:
		            return deserializeMetadataPushFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.REQUEST_N:
		            return deserializeRequestNFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.RESUME:
		            return deserializeResumeFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.RESUME_OK:
		            return deserializeResumeOkFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.CANCEL:
		            return deserializeCancelFrame(buffer, streamId, flags);
		        case Frames_1.FrameTypes.LEASE:
		            return deserializeLeaseFrame(buffer, streamId, flags);
		        // invariant(
		        //   false,
		        //   "RSocketBinaryFraming: Unsupported frame type `%s`.",
		        //   getFrameTypeName(type)
		        // );
		    }
		}
		exports.deserializeFrame = deserializeFrame;
		/**
		 * Convert the frame to a (binary) buffer.
		 */
		function serializeFrame(frame) {
		    switch (frame.type) {
		        case Frames_1.FrameTypes.SETUP:
		            return serializeSetupFrame(frame);
		        case Frames_1.FrameTypes.PAYLOAD:
		            return serializePayloadFrame(frame);
		        case Frames_1.FrameTypes.ERROR:
		            return serializeErrorFrame(frame);
		        case Frames_1.FrameTypes.KEEPALIVE:
		            return serializeKeepAliveFrame(frame);
		        case Frames_1.FrameTypes.REQUEST_FNF:
		        case Frames_1.FrameTypes.REQUEST_RESPONSE:
		            return serializeRequestFrame(frame);
		        case Frames_1.FrameTypes.REQUEST_STREAM:
		        case Frames_1.FrameTypes.REQUEST_CHANNEL:
		            return serializeRequestManyFrame(frame);
		        case Frames_1.FrameTypes.METADATA_PUSH:
		            return serializeMetadataPushFrame(frame);
		        case Frames_1.FrameTypes.REQUEST_N:
		            return serializeRequestNFrame(frame);
		        case Frames_1.FrameTypes.RESUME:
		            return serializeResumeFrame(frame);
		        case Frames_1.FrameTypes.RESUME_OK:
		            return serializeResumeOkFrame(frame);
		        case Frames_1.FrameTypes.CANCEL:
		            return serializeCancelFrame(frame);
		        case Frames_1.FrameTypes.LEASE:
		            return serializeLeaseFrame(frame);
		        // invariant(
		        //   false,
		        //   "RSocketBinaryFraming: Unsupported frame type `%s`.",
		        //   getFrameTypeName(frame.type)
		        // );
		    }
		}
		exports.serializeFrame = serializeFrame;
		/**
		 * Byte size of frame without size prefix
		 */
		function sizeOfFrame(frame) {
		    switch (frame.type) {
		        case Frames_1.FrameTypes.SETUP:
		            return sizeOfSetupFrame(frame);
		        case Frames_1.FrameTypes.PAYLOAD:
		            return sizeOfPayloadFrame(frame);
		        case Frames_1.FrameTypes.ERROR:
		            return sizeOfErrorFrame(frame);
		        case Frames_1.FrameTypes.KEEPALIVE:
		            return sizeOfKeepAliveFrame(frame);
		        case Frames_1.FrameTypes.REQUEST_FNF:
		        case Frames_1.FrameTypes.REQUEST_RESPONSE:
		            return sizeOfRequestFrame(frame);
		        case Frames_1.FrameTypes.REQUEST_STREAM:
		        case Frames_1.FrameTypes.REQUEST_CHANNEL:
		            return sizeOfRequestManyFrame(frame);
		        case Frames_1.FrameTypes.METADATA_PUSH:
		            return sizeOfMetadataPushFrame(frame);
		        case Frames_1.FrameTypes.REQUEST_N:
		            return sizeOfRequestNFrame();
		        case Frames_1.FrameTypes.RESUME:
		            return sizeOfResumeFrame(frame);
		        case Frames_1.FrameTypes.RESUME_OK:
		            return sizeOfResumeOkFrame();
		        case Frames_1.FrameTypes.CANCEL:
		            return sizeOfCancelFrame();
		        case Frames_1.FrameTypes.LEASE:
		            return sizeOfLeaseFrame(frame);
		        // invariant(
		        //   false,
		        //   "RSocketBinaryFraming: Unsupported frame type `%s`.",
		        //   getFrameTypeName(frame.type)
		        // );
		    }
		}
		exports.sizeOfFrame = sizeOfFrame;
		/**
		 * Writes a SETUP frame into a new buffer and returns it.
		 *
		 * Prefix size is:
		 * - version (2x uint16 = 4)
		 * - keepalive (uint32 = 4)
		 * - lifetime (uint32 = 4)
		 * - mime lengths (2x uint8 = 2)
		 */
		var SETUP_FIXED_SIZE = 14;
		var RESUME_TOKEN_LENGTH_SIZE = 2;
		function serializeSetupFrame(frame) {
		    var resumeTokenLength = frame.resumeToken != null ? frame.resumeToken.byteLength : 0;
		    var metadataMimeTypeLength = frame.metadataMimeType != null
		        ? bufferExports.Buffer.byteLength(frame.metadataMimeType, "ascii")
		        : 0;
		    var dataMimeTypeLength = frame.dataMimeType != null
		        ? bufferExports.Buffer.byteLength(frame.dataMimeType, "ascii")
		        : 0;
		    var payloadLength = getPayloadLength(frame);
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE +
		        SETUP_FIXED_SIZE + //
		        (resumeTokenLength ? RESUME_TOKEN_LENGTH_SIZE + resumeTokenLength : 0) +
		        metadataMimeTypeLength +
		        dataMimeTypeLength +
		        payloadLength);
		    var offset = writeHeader(frame, buffer);
		    offset = buffer.writeUInt16BE(frame.majorVersion, offset);
		    offset = buffer.writeUInt16BE(frame.minorVersion, offset);
		    offset = buffer.writeUInt32BE(frame.keepAlive, offset);
		    offset = buffer.writeUInt32BE(frame.lifetime, offset);
		    if (frame.flags & Frames_1.Flags.RESUME_ENABLE) {
		        offset = buffer.writeUInt16BE(resumeTokenLength, offset);
		        if (frame.resumeToken != null) {
		            offset += frame.resumeToken.copy(buffer, offset);
		        }
		    }
		    offset = buffer.writeUInt8(metadataMimeTypeLength, offset);
		    if (frame.metadataMimeType != null) {
		        offset += buffer.write(frame.metadataMimeType, offset, offset + metadataMimeTypeLength, "ascii");
		    }
		    offset = buffer.writeUInt8(dataMimeTypeLength, offset);
		    if (frame.dataMimeType != null) {
		        offset += buffer.write(frame.dataMimeType, offset, offset + dataMimeTypeLength, "ascii");
		    }
		    writePayload(frame, buffer, offset);
		    return buffer;
		}
		function sizeOfSetupFrame(frame) {
		    var resumeTokenLength = frame.resumeToken != null ? frame.resumeToken.byteLength : 0;
		    var metadataMimeTypeLength = frame.metadataMimeType != null
		        ? bufferExports.Buffer.byteLength(frame.metadataMimeType, "ascii")
		        : 0;
		    var dataMimeTypeLength = frame.dataMimeType != null
		        ? bufferExports.Buffer.byteLength(frame.dataMimeType, "ascii")
		        : 0;
		    var payloadLength = getPayloadLength(frame);
		    return (FRAME_HEADER_SIZE +
		        SETUP_FIXED_SIZE + //
		        (resumeTokenLength ? RESUME_TOKEN_LENGTH_SIZE + resumeTokenLength : 0) +
		        metadataMimeTypeLength +
		        dataMimeTypeLength +
		        payloadLength);
		}
		/**
		 * Reads a SETUP frame from the buffer and returns it.
		 */
		function deserializeSetupFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId === 0,
		    //   'RSocketBinaryFraming: Invalid SETUP frame, expected stream id to be 0.',
		    // );
		    buffer.length;
		    var offset = FRAME_HEADER_SIZE;
		    var majorVersion = buffer.readUInt16BE(offset);
		    offset += 2;
		    var minorVersion = buffer.readUInt16BE(offset);
		    offset += 2;
		    var keepAlive = buffer.readInt32BE(offset);
		    offset += 4;
		    // invariant(
		    //   keepAlive >= 0 && keepAlive <= MAX_KEEPALIVE,
		    //   'RSocketBinaryFraming: Invalid SETUP frame, expected keepAlive to be ' +
		    //     '>= 0 and <= %s. Got `%s`.',
		    //   MAX_KEEPALIVE,
		    //   keepAlive,
		    // );
		    var lifetime = buffer.readInt32BE(offset);
		    offset += 4;
		    // invariant(
		    //   lifetime >= 0 && lifetime <= MAX_LIFETIME,
		    //   'RSocketBinaryFraming: Invalid SETUP frame, expected lifetime to be ' +
		    //     '>= 0 and <= %s. Got `%s`.',
		    //   MAX_LIFETIME,
		    //   lifetime,
		    // );
		    var resumeToken = null;
		    if (flags & Frames_1.Flags.RESUME_ENABLE) {
		        var resumeTokenLength = buffer.readInt16BE(offset);
		        offset += 2;
		        // invariant(
		        //   resumeTokenLength >= 0 && resumeTokenLength <= MAX_RESUME_LENGTH,
		        //   'RSocketBinaryFraming: Invalid SETUP frame, expected resumeToken length ' +
		        //     'to be >= 0 and <= %s. Got `%s`.',
		        //   MAX_RESUME_LENGTH,
		        //   resumeTokenLength,
		        // );
		        resumeToken = buffer.slice(offset, offset + resumeTokenLength);
		        offset += resumeTokenLength;
		    }
		    var metadataMimeTypeLength = buffer.readUInt8(offset);
		    offset += 1;
		    var metadataMimeType = buffer.toString("ascii", offset, offset + metadataMimeTypeLength);
		    offset += metadataMimeTypeLength;
		    var dataMimeTypeLength = buffer.readUInt8(offset);
		    offset += 1;
		    var dataMimeType = buffer.toString("ascii", offset, offset + dataMimeTypeLength);
		    offset += dataMimeTypeLength;
		    var frame = {
		        data: null,
		        dataMimeType: dataMimeType,
		        flags: flags,
		        keepAlive: keepAlive,
		        lifetime: lifetime,
		        majorVersion: majorVersion,
		        metadata: null,
		        metadataMimeType: metadataMimeType,
		        minorVersion: minorVersion,
		        resumeToken: resumeToken,
		        // streamId,
		        streamId: 0,
		        type: Frames_1.FrameTypes.SETUP,
		    };
		    readPayload(buffer, frame, offset);
		    return frame;
		}
		/**
		 * Writes an ERROR frame into a new buffer and returns it.
		 *
		 * Prefix size is for the error code (uint32 = 4).
		 */
		var ERROR_FIXED_SIZE = 4;
		function serializeErrorFrame(frame) {
		    var messageLength = frame.message != null ? bufferExports.Buffer.byteLength(frame.message, "utf8") : 0;
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + ERROR_FIXED_SIZE + messageLength);
		    var offset = writeHeader(frame, buffer);
		    offset = buffer.writeUInt32BE(frame.code, offset);
		    if (frame.message != null) {
		        buffer.write(frame.message, offset, offset + messageLength, "utf8");
		    }
		    return buffer;
		}
		function sizeOfErrorFrame(frame) {
		    var messageLength = frame.message != null ? bufferExports.Buffer.byteLength(frame.message, "utf8") : 0;
		    return FRAME_HEADER_SIZE + ERROR_FIXED_SIZE + messageLength;
		}
		/**
		 * Reads an ERROR frame from the buffer and returns it.
		 */
		function deserializeErrorFrame(buffer, streamId, flags) {
		    buffer.length;
		    var offset = FRAME_HEADER_SIZE;
		    var code = buffer.readInt32BE(offset);
		    offset += 4;
		    // invariant(
		    //   code >= 0 && code <= MAX_CODE,
		    //   "RSocketBinaryFraming: Invalid ERROR frame, expected code to be >= 0 and <= %s. Got `%s`.",
		    //   MAX_CODE,
		    //   code
		    // );
		    var messageLength = buffer.length - offset;
		    var message = "";
		    if (messageLength > 0) {
		        message = buffer.toString("utf8", offset, offset + messageLength);
		        offset += messageLength;
		    }
		    return {
		        code: code,
		        flags: flags,
		        message: message,
		        streamId: streamId,
		        type: Frames_1.FrameTypes.ERROR,
		    };
		}
		/**
		 * Writes a KEEPALIVE frame into a new buffer and returns it.
		 *
		 * Prefix size is for the last received position (uint64 = 8).
		 */
		var KEEPALIVE_FIXED_SIZE = 8;
		function serializeKeepAliveFrame(frame) {
		    var dataLength = frame.data != null ? frame.data.byteLength : 0;
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + KEEPALIVE_FIXED_SIZE + dataLength);
		    var offset = writeHeader(frame, buffer);
		    offset = writeUInt64BE(buffer, frame.lastReceivedPosition, offset);
		    if (frame.data != null) {
		        frame.data.copy(buffer, offset);
		    }
		    return buffer;
		}
		function sizeOfKeepAliveFrame(frame) {
		    var dataLength = frame.data != null ? frame.data.byteLength : 0;
		    return FRAME_HEADER_SIZE + KEEPALIVE_FIXED_SIZE + dataLength;
		}
		/**
		 * Reads a KEEPALIVE frame from the buffer and returns it.
		 */
		function deserializeKeepAliveFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId === 0,
		    //   "RSocketBinaryFraming: Invalid KEEPALIVE frame, expected stream id to be 0."
		    // );
		    buffer.length;
		    var offset = FRAME_HEADER_SIZE;
		    var lastReceivedPosition = readUInt64BE(buffer, offset);
		    offset += 8;
		    var data = null;
		    if (offset < buffer.length) {
		        data = buffer.slice(offset, buffer.length);
		    }
		    return {
		        data: data,
		        flags: flags,
		        lastReceivedPosition: lastReceivedPosition,
		        // streamId,
		        streamId: 0,
		        type: Frames_1.FrameTypes.KEEPALIVE,
		    };
		}
		/**
		 * Writes a LEASE frame into a new buffer and returns it.
		 *
		 * Prefix size is for the ttl (uint32) and requestcount (uint32).
		 */
		var LEASE_FIXED_SIZE = 8;
		function serializeLeaseFrame(frame) {
		    var metaLength = frame.metadata != null ? frame.metadata.byteLength : 0;
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + LEASE_FIXED_SIZE + metaLength);
		    var offset = writeHeader(frame, buffer);
		    offset = buffer.writeUInt32BE(frame.ttl, offset);
		    offset = buffer.writeUInt32BE(frame.requestCount, offset);
		    if (frame.metadata != null) {
		        frame.metadata.copy(buffer, offset);
		    }
		    return buffer;
		}
		function sizeOfLeaseFrame(frame) {
		    var metaLength = frame.metadata != null ? frame.metadata.byteLength : 0;
		    return FRAME_HEADER_SIZE + LEASE_FIXED_SIZE + metaLength;
		}
		/**
		 * Reads a LEASE frame from the buffer and returns it.
		 */
		function deserializeLeaseFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId === 0,
		    //   "RSocketBinaryFraming: Invalid LEASE frame, expected stream id to be 0."
		    // );
		    // const length = buffer.length;
		    var offset = FRAME_HEADER_SIZE;
		    var ttl = buffer.readUInt32BE(offset);
		    offset += 4;
		    var requestCount = buffer.readUInt32BE(offset);
		    offset += 4;
		    var metadata = null;
		    if (offset < buffer.length) {
		        metadata = buffer.slice(offset, buffer.length);
		    }
		    return {
		        flags: flags,
		        metadata: metadata,
		        requestCount: requestCount,
		        // streamId,
		        streamId: 0,
		        ttl: ttl,
		        type: Frames_1.FrameTypes.LEASE,
		    };
		}
		/**
		 * Writes a REQUEST_FNF or REQUEST_RESPONSE frame to a new buffer and returns
		 * it.
		 *
		 * Note that these frames have the same shape and only differ in their type.
		 */
		function serializeRequestFrame(frame) {
		    var payloadLength = getPayloadLength(frame);
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + payloadLength);
		    var offset = writeHeader(frame, buffer);
		    writePayload(frame, buffer, offset);
		    return buffer;
		}
		function sizeOfRequestFrame(frame) {
		    var payloadLength = getPayloadLength(frame);
		    return FRAME_HEADER_SIZE + payloadLength;
		}
		/**
		 * Writes a METADATA_PUSH frame to a new buffer and returns
		 * it.
		 */
		function serializeMetadataPushFrame(frame) {
		    var metadata = frame.metadata;
		    if (metadata != null) {
		        var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + metadata.byteLength);
		        var offset = writeHeader(frame, buffer);
		        metadata.copy(buffer, offset);
		        return buffer;
		    }
		    else {
		        var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE);
		        writeHeader(frame, buffer);
		        return buffer;
		    }
		}
		function sizeOfMetadataPushFrame(frame) {
		    return (FRAME_HEADER_SIZE + (frame.metadata != null ? frame.metadata.byteLength : 0));
		}
		function deserializeRequestFnfFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId > 0,
		    //   "RSocketBinaryFraming: Invalid REQUEST_FNF frame, expected stream id to be > 0."
		    // );
		    buffer.length;
		    var frame = {
		        data: null,
		        flags: flags,
		        // length,
		        metadata: null,
		        streamId: streamId,
		        type: Frames_1.FrameTypes.REQUEST_FNF,
		    };
		    readPayload(buffer, frame, FRAME_HEADER_SIZE);
		    return frame;
		}
		function deserializeRequestResponseFrame(buffer, streamId, flags) {
		    // invariant(
		    // streamId > 0,
		    // "RSocketBinaryFraming: Invalid REQUEST_RESPONSE frame, expected stream id to be > 0."
		    // );
		    // const length = buffer.length;
		    var frame = {
		        data: null,
		        flags: flags,
		        // length,
		        metadata: null,
		        streamId: streamId,
		        type: Frames_1.FrameTypes.REQUEST_RESPONSE,
		    };
		    readPayload(buffer, frame, FRAME_HEADER_SIZE);
		    return frame;
		}
		function deserializeMetadataPushFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId === 0,
		    //   "RSocketBinaryFraming: Invalid METADATA_PUSH frame, expected stream id to be 0."
		    // );
		    // const length = buffer.length;
		    return {
		        flags: flags,
		        // length,
		        metadata: length === FRAME_HEADER_SIZE
		            ? null
		            : buffer.slice(FRAME_HEADER_SIZE, length),
		        // streamId,
		        streamId: 0,
		        type: Frames_1.FrameTypes.METADATA_PUSH,
		    };
		}
		/**
		 * Writes a REQUEST_STREAM or REQUEST_CHANNEL frame to a new buffer and returns
		 * it.
		 *
		 * Note that these frames have the same shape and only differ in their type.
		 *
		 * Prefix size is for requestN (uint32 = 4).
		 */
		var REQUEST_MANY_HEADER = 4;
		function serializeRequestManyFrame(frame) {
		    var payloadLength = getPayloadLength(frame);
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + REQUEST_MANY_HEADER + payloadLength);
		    var offset = writeHeader(frame, buffer);
		    offset = buffer.writeUInt32BE(frame.requestN, offset);
		    writePayload(frame, buffer, offset);
		    return buffer;
		}
		function sizeOfRequestManyFrame(frame) {
		    var payloadLength = getPayloadLength(frame);
		    return FRAME_HEADER_SIZE + REQUEST_MANY_HEADER + payloadLength;
		}
		function deserializeRequestStreamFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId > 0,
		    //   "RSocketBinaryFraming: Invalid REQUEST_STREAM frame, expected stream id to be > 0."
		    // );
		    buffer.length;
		    var offset = FRAME_HEADER_SIZE;
		    var requestN = buffer.readInt32BE(offset);
		    offset += 4;
		    // invariant(
		    //   requestN > 0,
		    //   "RSocketBinaryFraming: Invalid REQUEST_STREAM frame, expected requestN to be > 0, got `%s`.",
		    //   requestN
		    // );
		    var frame = {
		        data: null,
		        flags: flags,
		        // length,
		        metadata: null,
		        requestN: requestN,
		        streamId: streamId,
		        type: Frames_1.FrameTypes.REQUEST_STREAM,
		    };
		    readPayload(buffer, frame, offset);
		    return frame;
		}
		function deserializeRequestChannelFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId > 0,
		    //   "RSocketBinaryFraming: Invalid REQUEST_CHANNEL frame, expected stream id to be > 0."
		    // );
		    buffer.length;
		    var offset = FRAME_HEADER_SIZE;
		    var requestN = buffer.readInt32BE(offset);
		    offset += 4;
		    // invariant(
		    //   requestN > 0,
		    //   "RSocketBinaryFraming: Invalid REQUEST_STREAM frame, expected requestN to be > 0, got `%s`.",
		    //   requestN
		    // );
		    var frame = {
		        data: null,
		        flags: flags,
		        // length,
		        metadata: null,
		        requestN: requestN,
		        streamId: streamId,
		        type: Frames_1.FrameTypes.REQUEST_CHANNEL,
		    };
		    readPayload(buffer, frame, offset);
		    return frame;
		}
		/**
		 * Writes a REQUEST_N frame to a new buffer and returns it.
		 *
		 * Prefix size is for requestN (uint32 = 4).
		 */
		var REQUEST_N_HEADER = 4;
		function serializeRequestNFrame(frame) {
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + REQUEST_N_HEADER);
		    var offset = writeHeader(frame, buffer);
		    buffer.writeUInt32BE(frame.requestN, offset);
		    return buffer;
		}
		function sizeOfRequestNFrame(frame) {
		    return FRAME_HEADER_SIZE + REQUEST_N_HEADER;
		}
		function deserializeRequestNFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId > 0,
		    //   "RSocketBinaryFraming: Invalid REQUEST_N frame, expected stream id to be > 0."
		    // );
		    buffer.length;
		    var requestN = buffer.readInt32BE(FRAME_HEADER_SIZE);
		    // invariant(
		    //   requestN > 0,
		    //   "RSocketBinaryFraming: Invalid REQUEST_STREAM frame, expected requestN to be > 0, got `%s`.",
		    //   requestN
		    // );
		    return {
		        flags: flags,
		        // length,
		        requestN: requestN,
		        streamId: streamId,
		        type: Frames_1.FrameTypes.REQUEST_N,
		    };
		}
		/**
		 * Writes a CANCEL frame to a new buffer and returns it.
		 */
		function serializeCancelFrame(frame) {
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE);
		    writeHeader(frame, buffer);
		    return buffer;
		}
		function sizeOfCancelFrame(frame) {
		    return FRAME_HEADER_SIZE;
		}
		function deserializeCancelFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId > 0,
		    //   "RSocketBinaryFraming: Invalid CANCEL frame, expected stream id to be > 0."
		    // );
		    buffer.length;
		    return {
		        flags: flags,
		        // length,
		        streamId: streamId,
		        type: Frames_1.FrameTypes.CANCEL,
		    };
		}
		/**
		 * Writes a PAYLOAD frame to a new buffer and returns it.
		 */
		function serializePayloadFrame(frame) {
		    var payloadLength = getPayloadLength(frame);
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + payloadLength);
		    var offset = writeHeader(frame, buffer);
		    writePayload(frame, buffer, offset);
		    return buffer;
		}
		function sizeOfPayloadFrame(frame) {
		    var payloadLength = getPayloadLength(frame);
		    return FRAME_HEADER_SIZE + payloadLength;
		}
		function deserializePayloadFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId > 0,
		    //   "RSocketBinaryFraming: Invalid PAYLOAD frame, expected stream id to be > 0."
		    // );
		    buffer.length;
		    var frame = {
		        data: null,
		        flags: flags,
		        // length,
		        metadata: null,
		        streamId: streamId,
		        type: Frames_1.FrameTypes.PAYLOAD,
		    };
		    readPayload(buffer, frame, FRAME_HEADER_SIZE);
		    return frame;
		}
		/**
		 * Writes a RESUME frame into a new buffer and returns it.
		 *
		 * Fixed size is:
		 * - major version (uint16 = 2)
		 * - minor version (uint16 = 2)
		 * - token length (uint16 = 2)
		 * - client position (uint64 = 8)
		 * - server position (uint64 = 8)
		 */
		var RESUME_FIXED_SIZE = 22;
		function serializeResumeFrame(frame) {
		    var resumeTokenLength = frame.resumeToken.byteLength;
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + RESUME_FIXED_SIZE + resumeTokenLength);
		    var offset = writeHeader(frame, buffer);
		    offset = buffer.writeUInt16BE(frame.majorVersion, offset);
		    offset = buffer.writeUInt16BE(frame.minorVersion, offset);
		    offset = buffer.writeUInt16BE(resumeTokenLength, offset);
		    offset += frame.resumeToken.copy(buffer, offset);
		    offset = writeUInt64BE(buffer, frame.serverPosition, offset);
		    writeUInt64BE(buffer, frame.clientPosition, offset);
		    return buffer;
		}
		function sizeOfResumeFrame(frame) {
		    var resumeTokenLength = frame.resumeToken.byteLength;
		    return FRAME_HEADER_SIZE + RESUME_FIXED_SIZE + resumeTokenLength;
		}
		function deserializeResumeFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId === 0,
		    //   "RSocketBinaryFraming: Invalid RESUME frame, expected stream id to be 0."
		    // );
		    buffer.length;
		    var offset = FRAME_HEADER_SIZE;
		    var majorVersion = buffer.readUInt16BE(offset);
		    offset += 2;
		    var minorVersion = buffer.readUInt16BE(offset);
		    offset += 2;
		    var resumeTokenLength = buffer.readInt16BE(offset);
		    offset += 2;
		    // invariant(
		    //   resumeTokenLength >= 0 && resumeTokenLength <= MAX_RESUME_LENGTH,
		    //   "RSocketBinaryFraming: Invalid SETUP frame, expected resumeToken length " +
		    //     "to be >= 0 and <= %s. Got `%s`.",
		    //   MAX_RESUME_LENGTH,
		    //   resumeTokenLength
		    // );
		    var resumeToken = buffer.slice(offset, offset + resumeTokenLength);
		    offset += resumeTokenLength;
		    var serverPosition = readUInt64BE(buffer, offset);
		    offset += 8;
		    var clientPosition = readUInt64BE(buffer, offset);
		    offset += 8;
		    return {
		        clientPosition: clientPosition,
		        flags: flags,
		        // length,
		        majorVersion: majorVersion,
		        minorVersion: minorVersion,
		        resumeToken: resumeToken,
		        serverPosition: serverPosition,
		        // streamId,
		        streamId: 0,
		        type: Frames_1.FrameTypes.RESUME,
		    };
		}
		/**
		 * Writes a RESUME_OK frame into a new buffer and returns it.
		 *
		 * Fixed size is:
		 * - client position (uint64 = 8)
		 */
		var RESUME_OK_FIXED_SIZE = 8;
		function serializeResumeOkFrame(frame) {
		    var buffer = bufferExports.Buffer.allocUnsafe(FRAME_HEADER_SIZE + RESUME_OK_FIXED_SIZE);
		    var offset = writeHeader(frame, buffer);
		    writeUInt64BE(buffer, frame.clientPosition, offset);
		    return buffer;
		}
		function sizeOfResumeOkFrame(frame) {
		    return FRAME_HEADER_SIZE + RESUME_OK_FIXED_SIZE;
		}
		function deserializeResumeOkFrame(buffer, streamId, flags) {
		    // invariant(
		    //   streamId === 0,
		    //   "RSocketBinaryFraming: Invalid RESUME frame, expected stream id to be 0."
		    // );
		    buffer.length;
		    var clientPosition = readUInt64BE(buffer, FRAME_HEADER_SIZE);
		    return {
		        clientPosition: clientPosition,
		        flags: flags,
		        // length,
		        // streamId,
		        streamId: 0,
		        type: Frames_1.FrameTypes.RESUME_OK,
		    };
		}
		/**
		 * Write the header of the frame into the buffer.
		 */
		function writeHeader(frame, buffer) {
		    var offset = buffer.writeInt32BE(frame.streamId, 0);
		    // shift frame to high 6 bits, extract lowest 10 bits from flags
		    return buffer.writeUInt16BE((frame.type << exports.FRAME_TYPE_OFFFSET) | (frame.flags & exports.FLAGS_MASK), offset);
		}
		/**
		 * Determine the length of the payload section of a frame. Only applies to
		 * frame types that MAY have both metadata and data.
		 */
		function getPayloadLength(frame) {
		    var payloadLength = 0;
		    if (frame.data != null) {
		        payloadLength += frame.data.byteLength;
		    }
		    if (Frames_1.Flags.hasMetadata(frame.flags)) {
		        payloadLength += UINT24_SIZE;
		        if (frame.metadata != null) {
		            payloadLength += frame.metadata.byteLength;
		        }
		    }
		    return payloadLength;
		}
		/**
		 * Write the payload of a frame into the given buffer. Only applies to frame
		 * types that MAY have both metadata and data.
		 */
		function writePayload(frame, buffer, offset) {
		    if (Frames_1.Flags.hasMetadata(frame.flags)) {
		        if (frame.metadata != null) {
		            var metaLength = frame.metadata.byteLength;
		            offset = writeUInt24BE(buffer, metaLength, offset);
		            offset += frame.metadata.copy(buffer, offset);
		        }
		        else {
		            offset = writeUInt24BE(buffer, 0, offset);
		        }
		    }
		    if (frame.data != null) {
		        frame.data.copy(buffer, offset);
		    }
		}
		/**
		 * Read the payload from a buffer and write it into the frame. Only applies to
		 * frame types that MAY have both metadata and data.
		 */
		function readPayload(buffer, frame, offset) {
		    if (Frames_1.Flags.hasMetadata(frame.flags)) {
		        var metaLength = readUInt24BE(buffer, offset);
		        offset += UINT24_SIZE;
		        if (metaLength > 0) {
		            frame.metadata = buffer.slice(offset, offset + metaLength);
		            offset += metaLength;
		        }
		    }
		    if (offset < buffer.length) {
		        frame.data = buffer.slice(offset, buffer.length);
		    }
		}
		// exported as class to facilitate testing
		var Deserializer = /** @class */ (function () {
		    function Deserializer() {
		    }
		    /**
		     * Read a frame from the buffer.
		     */
		    Deserializer.prototype.deserializeFrame = function (buffer) {
		        return deserializeFrame(buffer);
		    };
		    /**
		     * Reads a frame from a buffer that is prefixed with the frame length.
		     */
		    Deserializer.prototype.deserializeFrameWithLength = function (buffer) {
		        return deserializeFrameWithLength(buffer);
		    };
		    /**
		     * Given a buffer that may contain zero or more length-prefixed frames followed
		     * by zero or more bytes of a (partial) subsequent frame, returns an array of
		     * the frames and a int representing the buffer offset.
		     */
		    Deserializer.prototype.deserializeFrames = function (buffer) {
		        return deserializeFrames(buffer);
		    };
		    return Deserializer;
		}());
		exports.Deserializer = Deserializer;
		
	} (Codecs));
	return Codecs;
}

var Common = {};

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return Common;
	hasRequiredCommon = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Common, "__esModule", { value: true });
	
	return Common;
}

var Deferred = {};

var hasRequiredDeferred;

function requireDeferred () {
	if (hasRequiredDeferred) return Deferred;
	hasRequiredDeferred = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values = (Deferred && Deferred.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(Deferred, "__esModule", { value: true });
	Deferred.Deferred = void 0;
	var Deferred$1 = /** @class */ (function () {
	    function Deferred() {
	        this._done = false;
	        this.onCloseCallbacks = [];
	    }
	    Object.defineProperty(Deferred.prototype, "done", {
	        get: function () {
	            return this._done;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Signals to an observer that the Deferred operation has been closed, which invokes
	     * the provided `onClose` callback.
	     */
	    Deferred.prototype.close = function (error) {
	        var e_1, _a, e_2, _b;
	        if (this.done) {
	            console.warn("Trying to close for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        this._done = true;
	        this._error = error;
	        if (error) {
	            try {
	                for (var _c = __values(this.onCloseCallbacks), _d = _c.next(); !_d.done; _d = _c.next()) {
	                    var callback = _d.value;
	                    callback(error);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return;
	        }
	        try {
	            for (var _e = __values(this.onCloseCallbacks), _f = _e.next(); !_f.done; _f = _e.next()) {
	                var callback = _f.value;
	                callback();
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	    };
	    /**
	     * Registers a callback to be called when the Closeable is closed. optionally with an Error.
	     */
	    Deferred.prototype.onClose = function (callback) {
	        if (this._done) {
	            callback(this._error);
	            return;
	        }
	        this.onCloseCallbacks.push(callback);
	    };
	    return Deferred;
	}());
	Deferred.Deferred = Deferred$1;
	
	return Deferred;
}

var Errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return Errors;
	hasRequiredErrors = 1;
	(function (exports) {
		/*
		 * Copyright 2021-2022 the original author or authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __extends = (Errors && Errors.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ErrorCodes = exports.RSocketError = void 0;
		var RSocketError = /** @class */ (function (_super) {
		    __extends(RSocketError, _super);
		    function RSocketError(code, message) {
		        var _this = _super.call(this, message) || this;
		        _this.code = code;
		        return _this;
		    }
		    return RSocketError;
		}(Error));
		exports.RSocketError = RSocketError;
		(function (ErrorCodes) {
		    ErrorCodes[ErrorCodes["RESERVED"] = 0] = "RESERVED";
		    ErrorCodes[ErrorCodes["INVALID_SETUP"] = 1] = "INVALID_SETUP";
		    ErrorCodes[ErrorCodes["UNSUPPORTED_SETUP"] = 2] = "UNSUPPORTED_SETUP";
		    ErrorCodes[ErrorCodes["REJECTED_SETUP"] = 3] = "REJECTED_SETUP";
		    ErrorCodes[ErrorCodes["REJECTED_RESUME"] = 4] = "REJECTED_RESUME";
		    ErrorCodes[ErrorCodes["CONNECTION_CLOSE"] = 258] = "CONNECTION_CLOSE";
		    ErrorCodes[ErrorCodes["CONNECTION_ERROR"] = 257] = "CONNECTION_ERROR";
		    ErrorCodes[ErrorCodes["APPLICATION_ERROR"] = 513] = "APPLICATION_ERROR";
		    ErrorCodes[ErrorCodes["REJECTED"] = 514] = "REJECTED";
		    ErrorCodes[ErrorCodes["CANCELED"] = 515] = "CANCELED";
		    ErrorCodes[ErrorCodes["INVALID"] = 516] = "INVALID";
		    ErrorCodes[ErrorCodes["RESERVED_EXTENSION"] = 4294967295] = "RESERVED_EXTENSION";
		})(exports.ErrorCodes || (exports.ErrorCodes = {}));
		
	} (Errors));
	return Errors;
}

var RSocket = {};

var hasRequiredRSocket;

function requireRSocket () {
	if (hasRequiredRSocket) return RSocket;
	hasRequiredRSocket = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(RSocket, "__esModule", { value: true });
	
	return RSocket;
}

var RSocketConnector = {};

var ClientServerMultiplexerDemultiplexer = {};

var hasRequiredClientServerMultiplexerDemultiplexer;

function requireClientServerMultiplexerDemultiplexer () {
	if (hasRequiredClientServerMultiplexerDemultiplexer) return ClientServerMultiplexerDemultiplexer;
	hasRequiredClientServerMultiplexerDemultiplexer = 1;
	(function (exports) {
		/*
		 * Copyright 2021-2022 the original author or authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __extends = (ClientServerMultiplexerDemultiplexer && ClientServerMultiplexerDemultiplexer.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		var __awaiter = (ClientServerMultiplexerDemultiplexer && ClientServerMultiplexerDemultiplexer.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		var __generator = (ClientServerMultiplexerDemultiplexer && ClientServerMultiplexerDemultiplexer.__generator) || function (thisArg, body) {
		    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
		    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
		    function verb(n) { return function (v) { return step([n, v]); }; }
		    function step(op) {
		        if (f) throw new TypeError("Generator is already executing.");
		        while (_) try {
		            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
		            if (y = 0, t) op = [op[0] & 2, t.value];
		            switch (op[0]) {
		                case 0: case 1: t = op; break;
		                case 4: _.label++; return { value: op[1], done: false };
		                case 5: _.label++; y = op[1]; op = [0]; continue;
		                case 7: op = _.ops.pop(); _.trys.pop(); continue;
		                default:
		                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
		                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
		                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
		                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
		                    if (t[2]) _.ops.pop();
		                    _.trys.pop(); continue;
		            }
		            op = body.call(thisArg, _);
		        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
		        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
		    }
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer = exports.ResumableClientServerInputMultiplexerDemultiplexer = exports.ClientServerInputMultiplexerDemultiplexer = exports.StreamIdGenerator = void 0;
		var _1 = requireDist();
		var Deferred_1 = requireDeferred();
		var Errors_1 = requireErrors();
		var Frames_1 = requireFrames();
		(function (StreamIdGenerator) {
		    function create(seedId) {
		        return new StreamIdGeneratorImpl(seedId);
		    }
		    StreamIdGenerator.create = create;
		    var StreamIdGeneratorImpl = /** @class */ (function () {
		        function StreamIdGeneratorImpl(currentId) {
		            this.currentId = currentId;
		        }
		        StreamIdGeneratorImpl.prototype.next = function (handler) {
		            var nextId = this.currentId + 2;
		            if (!handler(nextId)) {
		                return;
		            }
		            this.currentId = nextId;
		        };
		        return StreamIdGeneratorImpl;
		    }());
		})(exports.StreamIdGenerator || (exports.StreamIdGenerator = {}));
		var ClientServerInputMultiplexerDemultiplexer = /** @class */ (function (_super) {
		    __extends(ClientServerInputMultiplexerDemultiplexer, _super);
		    function ClientServerInputMultiplexerDemultiplexer(streamIdSupplier, outbound, closeable) {
		        var _this = _super.call(this) || this;
		        _this.streamIdSupplier = streamIdSupplier;
		        _this.outbound = outbound;
		        _this.closeable = closeable;
		        _this.registry = {};
		        closeable.onClose(_this.close.bind(_this));
		        return _this;
		    }
		    ClientServerInputMultiplexerDemultiplexer.prototype.handle = function (frame) {
		        if (Frames_1.Frame.isConnection(frame)) {
		            if (frame.type === _1.FrameTypes.RESERVED) {
		                // TODO: throw
		                return;
		            }
		            this.connectionFramesHandler.handle(frame);
		            // TODO: Connection Handler
		        }
		        else if (Frames_1.Frame.isRequest(frame)) {
		            if (this.registry[frame.streamId]) {
		                // TODO: Send error and close connection
		                return;
		            }
		            this.requestFramesHandler.handle(frame, this);
		        }
		        else {
		            var handler = this.registry[frame.streamId];
		            if (!handler) {
		                // TODO: add validation
		                return;
		            }
		            handler.handle(frame);
		        }
		        // TODO: add extensions support
		    };
		    ClientServerInputMultiplexerDemultiplexer.prototype.connectionInbound = function (handler) {
		        if (this.connectionFramesHandler) {
		            throw new Error("Connection frame handler has already been installed");
		        }
		        this.connectionFramesHandler = handler;
		    };
		    ClientServerInputMultiplexerDemultiplexer.prototype.handleRequestStream = function (handler) {
		        if (this.requestFramesHandler) {
		            throw new Error("Stream handler has already been installed");
		        }
		        this.requestFramesHandler = handler;
		    };
		    ClientServerInputMultiplexerDemultiplexer.prototype.send = function (frame) {
		        this.outbound.send(frame);
		    };
		    Object.defineProperty(ClientServerInputMultiplexerDemultiplexer.prototype, "connectionOutbound", {
		        get: function () {
		            return this;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    ClientServerInputMultiplexerDemultiplexer.prototype.createRequestStream = function (streamHandler) {
		        var _this = this;
		        // handle requester side stream registration
		        if (this.done) {
		            streamHandler.handleReject(new Error("Already closed"));
		            return;
		        }
		        var registry = this.registry;
		        this.streamIdSupplier.next(function (streamId) { return streamHandler.handleReady(streamId, _this); }, Object.keys(registry));
		    };
		    ClientServerInputMultiplexerDemultiplexer.prototype.connect = function (handler) {
		        this.registry[handler.streamId] = handler;
		    };
		    ClientServerInputMultiplexerDemultiplexer.prototype.disconnect = function (stream) {
		        delete this.registry[stream.streamId];
		    };
		    ClientServerInputMultiplexerDemultiplexer.prototype.close = function (error) {
		        if (this.done) {
		            _super.prototype.close.call(this, error);
		            return;
		        }
		        for (var streamId in this.registry) {
		            var stream = this.registry[streamId];
		            stream.close(new Error("Closed. ".concat(error ? "Original cause [".concat(error, "].") : "")));
		        }
		        _super.prototype.close.call(this, error);
		    };
		    return ClientServerInputMultiplexerDemultiplexer;
		}(Deferred_1.Deferred));
		exports.ClientServerInputMultiplexerDemultiplexer = ClientServerInputMultiplexerDemultiplexer;
		var ResumableClientServerInputMultiplexerDemultiplexer = /** @class */ (function (_super) {
		    __extends(ResumableClientServerInputMultiplexerDemultiplexer, _super);
		    function ResumableClientServerInputMultiplexerDemultiplexer(streamIdSupplier, outbound, closeable, frameStore, token, sessionStoreOrReconnector, sessionTimeout) {
		        var _this = _super.call(this, streamIdSupplier, outbound, new Deferred_1.Deferred()) || this;
		        _this.frameStore = frameStore;
		        _this.token = token;
		        _this.sessionTimeout = sessionTimeout;
		        if (sessionStoreOrReconnector instanceof Function) {
		            _this.reconnector = sessionStoreOrReconnector;
		        }
		        else {
		            _this.sessionStore = sessionStoreOrReconnector;
		        }
		        closeable.onClose(_this.handleConnectionClose.bind(_this));
		        return _this;
		    }
		    ResumableClientServerInputMultiplexerDemultiplexer.prototype.send = function (frame) {
		        if (Frames_1.Frame.isConnection(frame)) {
		            if (frame.type === _1.FrameTypes.KEEPALIVE) {
		                frame.lastReceivedPosition = this.frameStore.lastReceivedFramePosition;
		            }
		            else if (frame.type === _1.FrameTypes.ERROR) {
		                this.outbound.send(frame);
		                if (this.sessionStore) {
		                    delete this.sessionStore[this.token];
		                }
		                _super.prototype.close.call(this, new Errors_1.RSocketError(frame.code, frame.message));
		                return;
		            }
		        }
		        else {
		            this.frameStore.store(frame);
		        }
		        this.outbound.send(frame);
		    };
		    ResumableClientServerInputMultiplexerDemultiplexer.prototype.handle = function (frame) {
		        if (Frames_1.Frame.isConnection(frame)) {
		            if (frame.type === _1.FrameTypes.KEEPALIVE) {
		                try {
		                    this.frameStore.dropTo(frame.lastReceivedPosition);
		                }
		                catch (re) {
		                    this.outbound.send({
		                        type: _1.FrameTypes.ERROR,
		                        streamId: 0,
		                        flags: _1.Flags.NONE,
		                        code: re.code,
		                        message: re.message,
		                    });
		                    this.close(re);
		                }
		            }
		            else if (frame.type === _1.FrameTypes.ERROR) {
		                _super.prototype.handle.call(this, frame);
		                if (this.sessionStore) {
		                    delete this.sessionStore[this.token];
		                }
		                _super.prototype.close.call(this, new Errors_1.RSocketError(frame.code, frame.message));
		                return;
		            }
		        }
		        else {
		            this.frameStore.record(frame);
		        }
		        _super.prototype.handle.call(this, frame);
		    };
		    ResumableClientServerInputMultiplexerDemultiplexer.prototype.resume = function (frame, outbound, closeable) {
		        this.outbound = outbound;
		        switch (frame.type) {
		            case _1.FrameTypes.RESUME: {
		                clearTimeout(this.timeoutId);
		                if (this.frameStore.lastReceivedFramePosition < frame.clientPosition) {
		                    var e = new Errors_1.RSocketError(_1.ErrorCodes.REJECTED_RESUME, "Impossible to resume since first available client frame position is greater than last received server frame position");
		                    this.outbound.send({
		                        type: _1.FrameTypes.ERROR,
		                        streamId: 0,
		                        flags: _1.Flags.NONE,
		                        code: e.code,
		                        message: e.message,
		                    });
		                    this.close(e);
		                    return;
		                }
		                try {
		                    this.frameStore.dropTo(frame.serverPosition);
		                }
		                catch (re) {
		                    this.outbound.send({
		                        type: _1.FrameTypes.ERROR,
		                        streamId: 0,
		                        flags: _1.Flags.NONE,
		                        code: re.code,
		                        message: re.message,
		                    });
		                    this.close(re);
		                    return;
		                }
		                this.outbound.send({
		                    type: _1.FrameTypes.RESUME_OK,
		                    streamId: 0,
		                    flags: _1.Flags.NONE,
		                    clientPosition: this.frameStore.lastReceivedFramePosition,
		                });
		                break;
		            }
		            case _1.FrameTypes.RESUME_OK: {
		                try {
		                    this.frameStore.dropTo(frame.clientPosition);
		                }
		                catch (re) {
		                    this.outbound.send({
		                        type: _1.FrameTypes.ERROR,
		                        streamId: 0,
		                        flags: _1.Flags.NONE,
		                        code: re.code,
		                        message: re.message,
		                    });
		                    this.close(re);
		                }
		                break;
		            }
		        }
		        this.frameStore.drain(this.outbound.send.bind(this.outbound));
		        closeable.onClose(this.handleConnectionClose.bind(this));
		        this.connectionFramesHandler.resume();
		    };
		    ResumableClientServerInputMultiplexerDemultiplexer.prototype.handleConnectionClose = function (_error) {
		        return __awaiter(this, void 0, void 0, function () {
		            var e_1;
		            return __generator(this, function (_a) {
		                switch (_a.label) {
		                    case 0:
		                        this.connectionFramesHandler.pause();
		                        if (!this.reconnector) return [3 /*break*/, 5];
		                        _a.label = 1;
		                    case 1:
		                        _a.trys.push([1, 3, , 4]);
		                        return [4 /*yield*/, this.reconnector(this, this.frameStore)];
		                    case 2:
		                        _a.sent();
		                        return [3 /*break*/, 4];
		                    case 3:
		                        e_1 = _a.sent();
		                        this.close(e_1);
		                        return [3 /*break*/, 4];
		                    case 4: return [3 /*break*/, 6];
		                    case 5:
		                        this.timeoutId = setTimeout(this.close.bind(this), this.sessionTimeout);
		                        _a.label = 6;
		                    case 6: return [2 /*return*/];
		                }
		            });
		        });
		    };
		    return ResumableClientServerInputMultiplexerDemultiplexer;
		}(ClientServerInputMultiplexerDemultiplexer));
		exports.ResumableClientServerInputMultiplexerDemultiplexer = ResumableClientServerInputMultiplexerDemultiplexer;
		var ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer = /** @class */ (function () {
		    function ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer(outbound, closeable, delegate) {
		        this.outbound = outbound;
		        this.closeable = closeable;
		        this.delegate = delegate;
		        this.resumed = false;
		    }
		    ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer.prototype.close = function () {
		        this.delegate.close();
		    };
		    ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer.prototype.onClose = function (callback) {
		        this.delegate.onClose(callback);
		    };
		    Object.defineProperty(ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer.prototype, "connectionOutbound", {
		        get: function () {
		            return this.delegate.connectionOutbound;
		        },
		        enumerable: false,
		        configurable: true
		    });
		    ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer.prototype.createRequestStream = function (streamHandler) {
		        this.delegate.createRequestStream(streamHandler);
		    };
		    ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer.prototype.connectionInbound = function (handler) {
		        this.delegate.connectionInbound(handler);
		    };
		    ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer.prototype.handleRequestStream = function (handler) {
		        this.delegate.handleRequestStream(handler);
		    };
		    ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer.prototype.handle = function (frame) {
		        var _this = this;
		        if (!this.resumed) {
		            if (frame.type === _1.FrameTypes.RESUME_OK) {
		                this.resumed = true;
		                this.delegate.resume(frame, this.outbound, this.closeable);
		                return;
		            }
		            else {
		                this.outbound.send({
		                    type: _1.FrameTypes.ERROR,
		                    streamId: 0,
		                    code: _1.ErrorCodes.CONNECTION_ERROR,
		                    message: "Incomplete RESUME handshake. Unexpected frame ".concat(frame.type, " received"),
		                    flags: _1.Flags.NONE,
		                });
		                this.closeable.close();
		                this.closeable.onClose(function () {
		                    return _this.delegate.close(new Errors_1.RSocketError(_1.ErrorCodes.CONNECTION_ERROR, "Incomplete RESUME handshake. Unexpected frame ".concat(frame.type, " received")));
		                });
		            }
		            return;
		        }
		        this.delegate.handle(frame);
		    };
		    return ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer;
		}());
		exports.ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer = ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer;
		
	} (ClientServerMultiplexerDemultiplexer));
	return ClientServerMultiplexerDemultiplexer;
}

var RSocketSupport = {};

var RequestChannelStream = {};

var Fragmenter = {};

var hasRequiredFragmenter;

function requireFragmenter () {
	if (hasRequiredFragmenter) return Fragmenter;
	hasRequiredFragmenter = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __generator = (Fragmenter && Fragmenter.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(Fragmenter, "__esModule", { value: true });
	Fragmenter.fragmentWithRequestN = Fragmenter.fragment = Fragmenter.isFragmentable = void 0;
	var Frames_1 = requireFrames();
	function isFragmentable(payload, fragmentSize, frameType) {
	    if (fragmentSize === 0) {
	        return false;
	    }
	    return (payload.data.byteLength +
	        (payload.metadata ? payload.metadata.byteLength + Frames_1.Lengths.METADATA : 0) +
	        (frameType == Frames_1.FrameTypes.REQUEST_STREAM ||
	            frameType == Frames_1.FrameTypes.REQUEST_CHANNEL
	            ? Frames_1.Lengths.REQUEST
	            : 0) >
	        fragmentSize);
	}
	Fragmenter.isFragmentable = isFragmentable;
	function fragment(streamId, payload, fragmentSize, frameType, isComplete) {
	    var dataLength, firstFrame, remaining, metadata, metadataLength, metadataPosition, nextMetadataPosition, nextMetadataPosition, dataPosition, data, nextDataPosition, nextDataPosition;
	    var _a, _b;
	    if (isComplete === void 0) { isComplete = false; }
	    return __generator(this, function (_c) {
	        switch (_c.label) {
	            case 0:
	                dataLength = (_b = (_a = payload.data) === null || _a === void 0 ? void 0 : _a.byteLength) !== null && _b !== void 0 ? _b : 0;
	                firstFrame = frameType !== Frames_1.FrameTypes.PAYLOAD;
	                remaining = fragmentSize;
	                if (!payload.metadata) return [3 /*break*/, 6];
	                metadataLength = payload.metadata.byteLength;
	                if (!(metadataLength === 0)) return [3 /*break*/, 1];
	                remaining -= Frames_1.Lengths.METADATA;
	                metadata = bufferExports.Buffer.allocUnsafe(0);
	                return [3 /*break*/, 6];
	            case 1:
	                metadataPosition = 0;
	                if (!firstFrame) return [3 /*break*/, 3];
	                remaining -= Frames_1.Lengths.METADATA;
	                nextMetadataPosition = Math.min(metadataLength, metadataPosition + remaining);
	                metadata = payload.metadata.slice(metadataPosition, nextMetadataPosition);
	                remaining -= metadata.byteLength;
	                metadataPosition = nextMetadataPosition;
	                if (!(remaining === 0)) return [3 /*break*/, 3];
	                firstFrame = false;
	                return [4 /*yield*/, {
	                        type: frameType,
	                        flags: Frames_1.Flags.FOLLOWS | Frames_1.Flags.METADATA,
	                        data: undefined,
	                        metadata: metadata,
	                        streamId: streamId,
	                    }];
	            case 2:
	                _c.sent();
	                metadata = undefined;
	                remaining = fragmentSize;
	                _c.label = 3;
	            case 3:
	                if (!(metadataPosition < metadataLength)) return [3 /*break*/, 6];
	                remaining -= Frames_1.Lengths.METADATA;
	                nextMetadataPosition = Math.min(metadataLength, metadataPosition + remaining);
	                metadata = payload.metadata.slice(metadataPosition, nextMetadataPosition);
	                remaining -= metadata.byteLength;
	                metadataPosition = nextMetadataPosition;
	                if (!(remaining === 0 || dataLength === 0)) return [3 /*break*/, 5];
	                return [4 /*yield*/, {
	                        type: Frames_1.FrameTypes.PAYLOAD,
	                        flags: Frames_1.Flags.NEXT |
	                            Frames_1.Flags.METADATA |
	                            (metadataPosition === metadataLength &&
	                                isComplete &&
	                                dataLength === 0
	                                ? Frames_1.Flags.COMPLETE
	                                : Frames_1.Flags.FOLLOWS),
	                        data: undefined,
	                        metadata: metadata,
	                        streamId: streamId,
	                    }];
	            case 4:
	                _c.sent();
	                metadata = undefined;
	                remaining = fragmentSize;
	                _c.label = 5;
	            case 5: return [3 /*break*/, 3];
	            case 6:
	                dataPosition = 0;
	                if (!firstFrame) return [3 /*break*/, 8];
	                nextDataPosition = Math.min(dataLength, dataPosition + remaining);
	                data = payload.data.slice(dataPosition, nextDataPosition);
	                remaining -= data.byteLength;
	                dataPosition = nextDataPosition;
	                return [4 /*yield*/, {
	                        type: frameType,
	                        flags: Frames_1.Flags.FOLLOWS | (metadata ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE),
	                        data: data,
	                        metadata: metadata,
	                        streamId: streamId,
	                    }];
	            case 7:
	                _c.sent();
	                metadata = undefined;
	                data = undefined;
	                remaining = fragmentSize;
	                _c.label = 8;
	            case 8:
	                if (!(dataPosition < dataLength)) return [3 /*break*/, 10];
	                nextDataPosition = Math.min(dataLength, dataPosition + remaining);
	                data = payload.data.slice(dataPosition, nextDataPosition);
	                remaining -= data.byteLength;
	                dataPosition = nextDataPosition;
	                return [4 /*yield*/, {
	                        type: Frames_1.FrameTypes.PAYLOAD,
	                        flags: dataPosition === dataLength
	                            ? (isComplete ? Frames_1.Flags.COMPLETE : Frames_1.Flags.NONE) |
	                                Frames_1.Flags.NEXT |
	                                (metadata ? Frames_1.Flags.METADATA : 0)
	                            : Frames_1.Flags.FOLLOWS | Frames_1.Flags.NEXT | (metadata ? Frames_1.Flags.METADATA : 0),
	                        data: data,
	                        metadata: metadata,
	                        streamId: streamId,
	                    }];
	            case 9:
	                _c.sent();
	                metadata = undefined;
	                data = undefined;
	                remaining = fragmentSize;
	                return [3 /*break*/, 8];
	            case 10: return [2 /*return*/];
	        }
	    });
	}
	Fragmenter.fragment = fragment;
	function fragmentWithRequestN(streamId, payload, fragmentSize, frameType, requestN, isComplete) {
	    var dataLength, firstFrame, remaining, metadata, metadataLength, metadataPosition, nextMetadataPosition, nextMetadataPosition, dataPosition, data, nextDataPosition, nextDataPosition;
	    var _a, _b;
	    if (isComplete === void 0) { isComplete = false; }
	    return __generator(this, function (_c) {
	        switch (_c.label) {
	            case 0:
	                dataLength = (_b = (_a = payload.data) === null || _a === void 0 ? void 0 : _a.byteLength) !== null && _b !== void 0 ? _b : 0;
	                firstFrame = true;
	                remaining = fragmentSize;
	                if (!payload.metadata) return [3 /*break*/, 6];
	                metadataLength = payload.metadata.byteLength;
	                if (!(metadataLength === 0)) return [3 /*break*/, 1];
	                remaining -= Frames_1.Lengths.METADATA;
	                metadata = bufferExports.Buffer.allocUnsafe(0);
	                return [3 /*break*/, 6];
	            case 1:
	                metadataPosition = 0;
	                if (!firstFrame) return [3 /*break*/, 3];
	                remaining -= Frames_1.Lengths.METADATA + Frames_1.Lengths.REQUEST;
	                nextMetadataPosition = Math.min(metadataLength, metadataPosition + remaining);
	                metadata = payload.metadata.slice(metadataPosition, nextMetadataPosition);
	                remaining -= metadata.byteLength;
	                metadataPosition = nextMetadataPosition;
	                if (!(remaining === 0)) return [3 /*break*/, 3];
	                firstFrame = false;
	                return [4 /*yield*/, {
	                        type: frameType,
	                        flags: Frames_1.Flags.FOLLOWS | Frames_1.Flags.METADATA,
	                        data: undefined,
	                        requestN: requestN,
	                        metadata: metadata,
	                        streamId: streamId,
	                    }];
	            case 2:
	                _c.sent();
	                metadata = undefined;
	                remaining = fragmentSize;
	                _c.label = 3;
	            case 3:
	                if (!(metadataPosition < metadataLength)) return [3 /*break*/, 6];
	                remaining -= Frames_1.Lengths.METADATA;
	                nextMetadataPosition = Math.min(metadataLength, metadataPosition + remaining);
	                metadata = payload.metadata.slice(metadataPosition, nextMetadataPosition);
	                remaining -= metadata.byteLength;
	                metadataPosition = nextMetadataPosition;
	                if (!(remaining === 0 || dataLength === 0)) return [3 /*break*/, 5];
	                return [4 /*yield*/, {
	                        type: Frames_1.FrameTypes.PAYLOAD,
	                        flags: Frames_1.Flags.NEXT |
	                            Frames_1.Flags.METADATA |
	                            (metadataPosition === metadataLength &&
	                                isComplete &&
	                                dataLength === 0
	                                ? Frames_1.Flags.COMPLETE
	                                : Frames_1.Flags.FOLLOWS),
	                        data: undefined,
	                        metadata: metadata,
	                        streamId: streamId,
	                    }];
	            case 4:
	                _c.sent();
	                metadata = undefined;
	                remaining = fragmentSize;
	                _c.label = 5;
	            case 5: return [3 /*break*/, 3];
	            case 6:
	                dataPosition = 0;
	                if (!firstFrame) return [3 /*break*/, 8];
	                remaining -= Frames_1.Lengths.REQUEST;
	                nextDataPosition = Math.min(dataLength, dataPosition + remaining);
	                data = payload.data.slice(dataPosition, nextDataPosition);
	                remaining -= data.byteLength;
	                dataPosition = nextDataPosition;
	                return [4 /*yield*/, {
	                        type: frameType,
	                        flags: Frames_1.Flags.FOLLOWS | (metadata ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE),
	                        data: data,
	                        requestN: requestN,
	                        metadata: metadata,
	                        streamId: streamId,
	                    }];
	            case 7:
	                _c.sent();
	                metadata = undefined;
	                data = undefined;
	                remaining = fragmentSize;
	                _c.label = 8;
	            case 8:
	                if (!(dataPosition < dataLength)) return [3 /*break*/, 10];
	                nextDataPosition = Math.min(dataLength, dataPosition + remaining);
	                data = payload.data.slice(dataPosition, nextDataPosition);
	                remaining -= data.byteLength;
	                dataPosition = nextDataPosition;
	                return [4 /*yield*/, {
	                        type: Frames_1.FrameTypes.PAYLOAD,
	                        flags: dataPosition === dataLength
	                            ? (isComplete ? Frames_1.Flags.COMPLETE : Frames_1.Flags.NONE) |
	                                Frames_1.Flags.NEXT |
	                                (metadata ? Frames_1.Flags.METADATA : 0)
	                            : Frames_1.Flags.FOLLOWS | Frames_1.Flags.NEXT | (metadata ? Frames_1.Flags.METADATA : 0),
	                        data: data,
	                        metadata: metadata,
	                        streamId: streamId,
	                    }];
	            case 9:
	                _c.sent();
	                metadata = undefined;
	                data = undefined;
	                remaining = fragmentSize;
	                return [3 /*break*/, 8];
	            case 10: return [2 /*return*/];
	        }
	    });
	}
	Fragmenter.fragmentWithRequestN = fragmentWithRequestN;
	
	return Fragmenter;
}

var Reassembler = {};

var hasRequiredReassembler;

function requireReassembler () {
	if (hasRequiredReassembler) return Reassembler;
	hasRequiredReassembler = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Reassembler, "__esModule", { value: true });
	Reassembler.cancel = Reassembler.reassemble = Reassembler.add = void 0;
	function add(holder, dataFragment, metadataFragment) {
	    if (!holder.hasFragments) {
	        holder.hasFragments = true;
	        holder.data = dataFragment;
	        if (metadataFragment) {
	            holder.metadata = metadataFragment;
	        }
	        return true;
	    }
	    // TODO: add validation
	    holder.data = holder.data
	        ? bufferExports.Buffer.concat([holder.data, dataFragment])
	        : dataFragment;
	    if (holder.metadata && metadataFragment) {
	        holder.metadata = bufferExports.Buffer.concat([holder.metadata, metadataFragment]);
	    }
	    return true;
	}
	Reassembler.add = add;
	function reassemble(holder, dataFragment, metadataFragment) {
	    // TODO: add validation
	    holder.hasFragments = false;
	    var data = holder.data
	        ? bufferExports.Buffer.concat([holder.data, dataFragment])
	        : dataFragment;
	    holder.data = undefined;
	    if (holder.metadata) {
	        var metadata = metadataFragment
	            ? bufferExports.Buffer.concat([holder.metadata, metadataFragment])
	            : holder.metadata;
	        holder.metadata = undefined;
	        return {
	            data: data,
	            metadata: metadata,
	        };
	    }
	    return {
	        data: data,
	    };
	}
	Reassembler.reassemble = reassemble;
	function cancel(holder) {
	    holder.hasFragments = false;
	    holder.data = undefined;
	    holder.metadata = undefined;
	}
	Reassembler.cancel = cancel;
	
	return Reassembler;
}

var hasRequiredRequestChannelStream;

function requireRequestChannelStream () {
	if (hasRequiredRequestChannelStream) return RequestChannelStream;
	hasRequiredRequestChannelStream = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (RequestChannelStream && RequestChannelStream.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (RequestChannelStream && RequestChannelStream.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (RequestChannelStream && RequestChannelStream.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __values = (RequestChannelStream && RequestChannelStream.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(RequestChannelStream, "__esModule", { value: true });
	RequestChannelStream.RequestChannelResponderStream = RequestChannelStream.RequestChannelRequesterStream = void 0;
	var Errors_1 = requireErrors();
	var Fragmenter_1 = requireFragmenter();
	var Frames_1 = requireFrames();
	var Reassembler = __importStar(requireReassembler());
	var RequestChannelRequesterStream = /** @class */ (function () {
	    function RequestChannelRequesterStream(payload, isComplete, receiver, fragmentSize, initialRequestN, leaseManager) {
	        this.payload = payload;
	        this.isComplete = isComplete;
	        this.receiver = receiver;
	        this.fragmentSize = fragmentSize;
	        this.initialRequestN = initialRequestN;
	        this.leaseManager = leaseManager;
	        this.streamType = Frames_1.FrameTypes.REQUEST_CHANNEL;
	        // TODO: add payload size validation
	    }
	    RequestChannelRequesterStream.prototype.handleReady = function (streamId, stream) {
	        var e_1, _a;
	        if (this.outboundDone) {
	            return false;
	        }
	        this.streamId = streamId;
	        this.stream = stream;
	        stream.connect(this);
	        var isCompleted = this.isComplete;
	        if (isCompleted) {
	            this.outboundDone = isCompleted;
	        }
	        if ((0, Fragmenter_1.isFragmentable)(this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_CHANNEL)) {
	            try {
	                for (var _b = __values((0, Fragmenter_1.fragmentWithRequestN)(streamId, this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_CHANNEL, this.initialRequestN, isCompleted)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var frame = _c.value;
	                    this.stream.send(frame);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this.stream.send({
	                type: Frames_1.FrameTypes.REQUEST_CHANNEL,
	                data: this.payload.data,
	                metadata: this.payload.metadata,
	                requestN: this.initialRequestN,
	                flags: (this.payload.metadata !== undefined ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE) |
	                    (isCompleted ? Frames_1.Flags.COMPLETE : Frames_1.Flags.NONE),
	                streamId: streamId,
	            });
	        }
	        if (this.hasExtension) {
	            this.stream.send({
	                type: Frames_1.FrameTypes.EXT,
	                streamId: streamId,
	                extendedContent: this.extendedContent,
	                extendedType: this.extendedType,
	                flags: this.flags,
	            });
	        }
	        return true;
	    };
	    RequestChannelRequesterStream.prototype.handleReject = function (error) {
	        if (this.inboundDone) {
	            return;
	        }
	        this.inboundDone = true;
	        this.outboundDone = true;
	        this.receiver.onError(error);
	    };
	    RequestChannelRequesterStream.prototype.handle = function (frame) {
	        var errorMessage;
	        var frameType = frame.type;
	        switch (frameType) {
	            case Frames_1.FrameTypes.PAYLOAD: {
	                var hasComplete = Frames_1.Flags.hasComplete(frame.flags);
	                var hasNext = Frames_1.Flags.hasNext(frame.flags);
	                if (hasComplete || !Frames_1.Flags.hasFollows(frame.flags)) {
	                    if (hasComplete) {
	                        this.inboundDone = true;
	                        if (this.outboundDone) {
	                            this.stream.disconnect(this);
	                        }
	                        if (!hasNext) {
	                            // TODO: add validation no frame in reassembly
	                            this.receiver.onComplete();
	                            return;
	                        }
	                    }
	                    var payload = this.hasFragments
	                        ? Reassembler.reassemble(this, frame.data, frame.metadata)
	                        : {
	                            data: frame.data,
	                            metadata: frame.metadata,
	                        };
	                    this.receiver.onNext(payload, hasComplete);
	                    return;
	                }
	                if (Reassembler.add(this, frame.data, frame.metadata)) {
	                    return;
	                }
	                errorMessage = "Unexpected frame size";
	                break;
	            }
	            case Frames_1.FrameTypes.CANCEL: {
	                if (this.outboundDone) {
	                    return;
	                }
	                this.outboundDone = true;
	                if (this.inboundDone) {
	                    this.stream.disconnect(this);
	                }
	                this.receiver.cancel();
	                return;
	            }
	            case Frames_1.FrameTypes.REQUEST_N: {
	                if (this.outboundDone) {
	                    return;
	                }
	                if (this.hasFragments) {
	                    errorMessage = "Unexpected frame type [".concat(frameType, "] during reassembly");
	                    break;
	                }
	                this.receiver.request(frame.requestN);
	                return;
	            }
	            case Frames_1.FrameTypes.ERROR: {
	                var outboundDone = this.outboundDone;
	                this.inboundDone = true;
	                this.outboundDone = true;
	                this.stream.disconnect(this);
	                Reassembler.cancel(this);
	                if (!outboundDone) {
	                    this.receiver.cancel();
	                }
	                this.receiver.onError(new Errors_1.RSocketError(frame.code, frame.message));
	                return;
	            }
	            case Frames_1.FrameTypes.EXT:
	                this.receiver.onExtension(frame.extendedType, frame.extendedContent, Frames_1.Flags.hasIgnore(frame.flags));
	                return;
	            default: {
	                errorMessage = "Unexpected frame type [".concat(frameType, "]");
	            }
	        }
	        this.close(new Errors_1.RSocketError(Errors_1.ErrorCodes.CANCELED, errorMessage));
	        this.stream.send({
	            type: Frames_1.FrameTypes.CANCEL,
	            streamId: this.streamId,
	            flags: Frames_1.Flags.NONE,
	        });
	        this.stream.disconnect(this);
	    };
	    RequestChannelRequesterStream.prototype.request = function (n) {
	        if (this.inboundDone) {
	            return;
	        }
	        if (!this.streamId) {
	            this.initialRequestN += n;
	            return;
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.REQUEST_N,
	            flags: Frames_1.Flags.NONE,
	            requestN: n,
	            streamId: this.streamId,
	        });
	    };
	    RequestChannelRequesterStream.prototype.cancel = function () {
	        var _a;
	        var inboundDone = this.inboundDone;
	        var outboundDone = this.outboundDone;
	        if (inboundDone && outboundDone) {
	            return;
	        }
	        this.inboundDone = true;
	        this.outboundDone = true;
	        if (!outboundDone) {
	            this.receiver.cancel();
	        }
	        if (!this.streamId) {
	            (_a = this.leaseManager) === null || _a === void 0 ? void 0 : _a.cancelRequest(this);
	            return;
	        }
	        this.stream.send({
	            type: inboundDone ? Frames_1.FrameTypes.ERROR : Frames_1.FrameTypes.CANCEL,
	            flags: Frames_1.Flags.NONE,
	            streamId: this.streamId,
	            code: Errors_1.ErrorCodes.CANCELED,
	            message: "Cancelled",
	        });
	        this.stream.disconnect(this);
	        Reassembler.cancel(this);
	    };
	    RequestChannelRequesterStream.prototype.onNext = function (payload, isComplete) {
	        var e_2, _a;
	        if (this.outboundDone) {
	            return;
	        }
	        if (isComplete) {
	            this.outboundDone = true;
	            if (this.inboundDone) {
	                this.stream.disconnect(this);
	            }
	        }
	        if ((0, Fragmenter_1.isFragmentable)(payload, this.fragmentSize, Frames_1.FrameTypes.PAYLOAD)) {
	            try {
	                for (var _b = __values((0, Fragmenter_1.fragment)(this.streamId, payload, this.fragmentSize, Frames_1.FrameTypes.PAYLOAD, isComplete)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var frame = _c.value;
	                    this.stream.send(frame);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this.stream.send({
	                type: Frames_1.FrameTypes.PAYLOAD,
	                streamId: this.streamId,
	                flags: Frames_1.Flags.NEXT |
	                    (payload.metadata ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE) |
	                    (isComplete ? Frames_1.Flags.COMPLETE : Frames_1.Flags.NONE),
	                data: payload.data,
	                metadata: payload.metadata,
	            });
	        }
	    };
	    RequestChannelRequesterStream.prototype.onComplete = function () {
	        if (!this.streamId) {
	            this.isComplete = true;
	            return;
	        }
	        if (this.outboundDone) {
	            return;
	        }
	        this.outboundDone = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.PAYLOAD,
	            streamId: this.streamId,
	            flags: Frames_1.Flags.COMPLETE,
	            data: null,
	            metadata: null,
	        });
	        if (this.inboundDone) {
	            this.stream.disconnect(this);
	        }
	    };
	    RequestChannelRequesterStream.prototype.onError = function (error) {
	        if (this.outboundDone) {
	            return;
	        }
	        var inboundDone = this.inboundDone;
	        this.outboundDone = true;
	        this.inboundDone = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.ERROR,
	            streamId: this.streamId,
	            flags: Frames_1.Flags.NONE,
	            code: error instanceof Errors_1.RSocketError
	                ? error.code
	                : Errors_1.ErrorCodes.APPLICATION_ERROR,
	            message: error.message,
	        });
	        this.stream.disconnect(this);
	        if (!inboundDone) {
	            this.receiver.onError(error);
	        }
	    };
	    RequestChannelRequesterStream.prototype.onExtension = function (extendedType, content, canBeIgnored) {
	        if (this.outboundDone) {
	            return;
	        }
	        if (!this.streamId) {
	            this.hasExtension = true;
	            this.extendedType = extendedType;
	            this.extendedContent = content;
	            this.flags = canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE;
	            return;
	        }
	        this.stream.send({
	            streamId: this.streamId,
	            type: Frames_1.FrameTypes.EXT,
	            extendedType: extendedType,
	            extendedContent: content,
	            flags: canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE,
	        });
	    };
	    RequestChannelRequesterStream.prototype.close = function (error) {
	        if (this.inboundDone && this.outboundDone) {
	            return;
	        }
	        var inboundDone = this.inboundDone;
	        var outboundDone = this.outboundDone;
	        this.inboundDone = true;
	        this.outboundDone = true;
	        Reassembler.cancel(this);
	        if (!outboundDone) {
	            this.receiver.cancel();
	        }
	        if (!inboundDone) {
	            if (error) {
	                this.receiver.onError(error);
	            }
	            else {
	                this.receiver.onComplete();
	            }
	        }
	    };
	    return RequestChannelRequesterStream;
	}());
	RequestChannelStream.RequestChannelRequesterStream = RequestChannelRequesterStream;
	var RequestChannelResponderStream = /** @class */ (function () {
	    function RequestChannelResponderStream(streamId, stream, fragmentSize, handler, frame) {
	        this.streamId = streamId;
	        this.stream = stream;
	        this.fragmentSize = fragmentSize;
	        this.handler = handler;
	        this.streamType = Frames_1.FrameTypes.REQUEST_CHANNEL;
	        stream.connect(this);
	        if (Frames_1.Flags.hasFollows(frame.flags)) {
	            Reassembler.add(this, frame.data, frame.metadata);
	            this.initialRequestN = frame.requestN;
	            this.isComplete = Frames_1.Flags.hasComplete(frame.flags);
	            return;
	        }
	        var payload = {
	            data: frame.data,
	            metadata: frame.metadata,
	        };
	        var hasComplete = Frames_1.Flags.hasComplete(frame.flags);
	        this.inboundDone = hasComplete;
	        try {
	            this.receiver = handler(payload, frame.requestN, hasComplete, this);
	            if (this.outboundDone && this.defferedError) {
	                this.receiver.onError(this.defferedError);
	            }
	        }
	        catch (error) {
	            if (this.outboundDone && !this.inboundDone) {
	                this.cancel();
	            }
	            else {
	                this.inboundDone = true;
	            }
	            this.onError(error);
	        }
	    }
	    RequestChannelResponderStream.prototype.handle = function (frame) {
	        var errorMessage;
	        var frameType = frame.type;
	        switch (frameType) {
	            case Frames_1.FrameTypes.PAYLOAD: {
	                if (Frames_1.Flags.hasFollows(frame.flags)) {
	                    if (Reassembler.add(this, frame.data, frame.metadata)) {
	                        return;
	                    }
	                    errorMessage = "Unexpected frame size";
	                    break;
	                }
	                var payload = this.hasFragments
	                    ? Reassembler.reassemble(this, frame.data, frame.metadata)
	                    : {
	                        data: frame.data,
	                        metadata: frame.metadata,
	                    };
	                var hasComplete = Frames_1.Flags.hasComplete(frame.flags);
	                if (!this.receiver) {
	                    var inboundDone = this.isComplete || hasComplete;
	                    if (inboundDone) {
	                        this.inboundDone = true;
	                        if (this.outboundDone) {
	                            this.stream.disconnect(this);
	                        }
	                    }
	                    try {
	                        this.receiver = this.handler(payload, this.initialRequestN, inboundDone, this);
	                        if (this.outboundDone && this.defferedError) {
	                        }
	                    }
	                    catch (error) {
	                        if (this.outboundDone && !this.inboundDone) {
	                            this.cancel();
	                        }
	                        else {
	                            this.inboundDone = true;
	                        }
	                        this.onError(error);
	                    }
	                }
	                else {
	                    if (hasComplete) {
	                        this.inboundDone = true;
	                        if (this.outboundDone) {
	                            this.stream.disconnect(this);
	                        }
	                        if (!Frames_1.Flags.hasNext(frame.flags)) {
	                            this.receiver.onComplete();
	                            return;
	                        }
	                    }
	                    this.receiver.onNext(payload, hasComplete);
	                }
	                return;
	            }
	            case Frames_1.FrameTypes.REQUEST_N: {
	                if (!this.receiver || this.hasFragments) {
	                    errorMessage = "Unexpected frame type [".concat(frameType, "] during reassembly");
	                    break;
	                }
	                this.receiver.request(frame.requestN);
	                return;
	            }
	            case Frames_1.FrameTypes.ERROR:
	            case Frames_1.FrameTypes.CANCEL: {
	                var inboundDone = this.inboundDone;
	                var outboundDone = this.outboundDone;
	                this.inboundDone = true;
	                this.outboundDone = true;
	                this.stream.disconnect(this);
	                Reassembler.cancel(this);
	                if (!this.receiver) {
	                    return;
	                }
	                if (!outboundDone) {
	                    this.receiver.cancel();
	                }
	                if (!inboundDone) {
	                    var error = frameType === Frames_1.FrameTypes.CANCEL
	                        ? new Errors_1.RSocketError(Errors_1.ErrorCodes.CANCELED, "Cancelled")
	                        : new Errors_1.RSocketError(frame.code, frame.message);
	                    this.receiver.onError(error);
	                }
	                return;
	            }
	            case Frames_1.FrameTypes.EXT: {
	                if (!this.receiver || this.hasFragments) {
	                    errorMessage = "Unexpected frame type [".concat(frameType, "] during reassembly");
	                    break;
	                }
	                this.receiver.onExtension(frame.extendedType, frame.extendedContent, Frames_1.Flags.hasIgnore(frame.flags));
	                return;
	            }
	            default: {
	                errorMessage = "Unexpected frame type [".concat(frameType, "]");
	                // TODO: throws if strict
	            }
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.ERROR,
	            flags: Frames_1.Flags.NONE,
	            code: Errors_1.ErrorCodes.CANCELED,
	            message: errorMessage,
	            streamId: this.streamId,
	        });
	        this.stream.disconnect(this);
	        this.close(new Errors_1.RSocketError(Errors_1.ErrorCodes.CANCELED, errorMessage));
	    };
	    RequestChannelResponderStream.prototype.onError = function (error) {
	        if (this.outboundDone) {
	            console.warn("Trying to error for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        var inboundDone = this.inboundDone;
	        this.outboundDone = true;
	        this.inboundDone = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.ERROR,
	            flags: Frames_1.Flags.NONE,
	            code: error instanceof Errors_1.RSocketError
	                ? error.code
	                : Errors_1.ErrorCodes.APPLICATION_ERROR,
	            message: error.message,
	            streamId: this.streamId,
	        });
	        this.stream.disconnect(this);
	        if (!inboundDone) {
	            if (this.receiver) {
	                this.receiver.onError(error);
	            }
	            else {
	                this.defferedError = error;
	            }
	        }
	    };
	    RequestChannelResponderStream.prototype.onNext = function (payload, isCompletion) {
	        var e_3, _a;
	        if (this.outboundDone) {
	            return;
	        }
	        if (isCompletion) {
	            this.outboundDone = true;
	        }
	        // TODO: add payload size validation
	        if ((0, Fragmenter_1.isFragmentable)(payload, this.fragmentSize, Frames_1.FrameTypes.PAYLOAD)) {
	            try {
	                for (var _b = __values((0, Fragmenter_1.fragment)(this.streamId, payload, this.fragmentSize, Frames_1.FrameTypes.PAYLOAD, isCompletion)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var frame = _c.value;
	                    this.stream.send(frame);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	        }
	        else {
	            this.stream.send({
	                type: Frames_1.FrameTypes.PAYLOAD,
	                flags: Frames_1.Flags.NEXT |
	                    (isCompletion ? Frames_1.Flags.COMPLETE : Frames_1.Flags.NONE) |
	                    (payload.metadata ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE),
	                data: payload.data,
	                metadata: payload.metadata,
	                streamId: this.streamId,
	            });
	        }
	        if (isCompletion && this.inboundDone) {
	            this.stream.disconnect(this);
	        }
	    };
	    RequestChannelResponderStream.prototype.onComplete = function () {
	        if (this.outboundDone) {
	            return;
	        }
	        this.outboundDone = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.PAYLOAD,
	            flags: Frames_1.Flags.COMPLETE,
	            streamId: this.streamId,
	            data: null,
	            metadata: null,
	        });
	        if (this.inboundDone) {
	            this.stream.disconnect(this);
	        }
	    };
	    RequestChannelResponderStream.prototype.onExtension = function (extendedType, content, canBeIgnored) {
	        if (this.outboundDone && this.inboundDone) {
	            return;
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.EXT,
	            streamId: this.streamId,
	            flags: canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE,
	            extendedType: extendedType,
	            extendedContent: content,
	        });
	    };
	    RequestChannelResponderStream.prototype.request = function (n) {
	        if (this.inboundDone) {
	            return;
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.REQUEST_N,
	            flags: Frames_1.Flags.NONE,
	            streamId: this.streamId,
	            requestN: n,
	        });
	    };
	    RequestChannelResponderStream.prototype.cancel = function () {
	        if (this.inboundDone) {
	            return;
	        }
	        this.inboundDone = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.CANCEL,
	            flags: Frames_1.Flags.NONE,
	            streamId: this.streamId,
	        });
	        if (this.outboundDone) {
	            this.stream.disconnect(this);
	        }
	    };
	    RequestChannelResponderStream.prototype.close = function (error) {
	        if (this.inboundDone && this.outboundDone) {
	            console.warn("Trying to close for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        var inboundDone = this.inboundDone;
	        var outboundDone = this.outboundDone;
	        this.inboundDone = true;
	        this.outboundDone = true;
	        Reassembler.cancel(this);
	        var receiver = this.receiver;
	        if (!receiver) {
	            return;
	        }
	        if (!outboundDone) {
	            receiver.cancel();
	        }
	        if (!inboundDone) {
	            if (error) {
	                receiver.onError(error);
	            }
	            else {
	                receiver.onComplete();
	            }
	        }
	    };
	    return RequestChannelResponderStream;
	}());
	RequestChannelStream.RequestChannelResponderStream = RequestChannelResponderStream;
	
	return RequestChannelStream;
}

var RequestFnFStream = {};

var hasRequiredRequestFnFStream;

function requireRequestFnFStream () {
	if (hasRequiredRequestFnFStream) return RequestFnFStream;
	hasRequiredRequestFnFStream = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (RequestFnFStream && RequestFnFStream.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (RequestFnFStream && RequestFnFStream.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (RequestFnFStream && RequestFnFStream.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __values = (RequestFnFStream && RequestFnFStream.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(RequestFnFStream, "__esModule", { value: true });
	RequestFnFStream.RequestFnfResponderStream = RequestFnFStream.RequestFnFRequesterStream = void 0;
	var Errors_1 = requireErrors();
	var Fragmenter_1 = requireFragmenter();
	var Frames_1 = requireFrames();
	var Reassembler = __importStar(requireReassembler());
	var RequestFnFRequesterStream = /** @class */ (function () {
	    function RequestFnFRequesterStream(payload, receiver, fragmentSize, leaseManager) {
	        this.payload = payload;
	        this.receiver = receiver;
	        this.fragmentSize = fragmentSize;
	        this.leaseManager = leaseManager;
	        this.streamType = Frames_1.FrameTypes.REQUEST_FNF;
	    }
	    RequestFnFRequesterStream.prototype.handleReady = function (streamId, stream) {
	        var e_1, _a;
	        if (this.done) {
	            return false;
	        }
	        this.streamId = streamId;
	        if ((0, Fragmenter_1.isFragmentable)(this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_FNF)) {
	            try {
	                for (var _b = __values((0, Fragmenter_1.fragment)(streamId, this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_FNF)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var frame = _c.value;
	                    stream.send(frame);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            stream.send({
	                type: Frames_1.FrameTypes.REQUEST_FNF,
	                data: this.payload.data,
	                metadata: this.payload.metadata,
	                flags: this.payload.metadata ? Frames_1.Flags.METADATA : 0,
	                streamId: streamId,
	            });
	        }
	        this.done = true;
	        this.receiver.onComplete();
	        return true;
	    };
	    RequestFnFRequesterStream.prototype.handleReject = function (error) {
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        this.receiver.onError(error);
	    };
	    RequestFnFRequesterStream.prototype.cancel = function () {
	        var _a;
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        (_a = this.leaseManager) === null || _a === void 0 ? void 0 : _a.cancelRequest(this);
	    };
	    RequestFnFRequesterStream.prototype.handle = function (frame) {
	        if (frame.type == Frames_1.FrameTypes.ERROR) {
	            this.close(new Errors_1.RSocketError(frame.code, frame.message));
	            return;
	        }
	        this.close(new Errors_1.RSocketError(Errors_1.ErrorCodes.CANCELED, "Received invalid frame"));
	    };
	    RequestFnFRequesterStream.prototype.close = function (error) {
	        if (this.done) {
	            console.warn("Trying to close for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        if (error) {
	            this.receiver.onError(error);
	        }
	        else {
	            this.receiver.onComplete();
	        }
	    };
	    return RequestFnFRequesterStream;
	}());
	RequestFnFStream.RequestFnFRequesterStream = RequestFnFRequesterStream;
	var RequestFnfResponderStream = /** @class */ (function () {
	    function RequestFnfResponderStream(streamId, stream, handler, frame) {
	        this.streamId = streamId;
	        this.stream = stream;
	        this.handler = handler;
	        this.streamType = Frames_1.FrameTypes.REQUEST_FNF;
	        if (Frames_1.Flags.hasFollows(frame.flags)) {
	            Reassembler.add(this, frame.data, frame.metadata);
	            stream.connect(this);
	            return;
	        }
	        var payload = {
	            data: frame.data,
	            metadata: frame.metadata,
	        };
	        try {
	            this.cancellable = handler(payload, this);
	        }
	        catch (e) {
	            // do nothing
	        }
	    }
	    RequestFnfResponderStream.prototype.handle = function (frame) {
	        var errorMessage;
	        if (frame.type == Frames_1.FrameTypes.PAYLOAD) {
	            if (Frames_1.Flags.hasFollows(frame.flags)) {
	                if (Reassembler.add(this, frame.data, frame.metadata)) {
	                    return;
	                }
	                errorMessage = "Unexpected fragment size";
	            }
	            else {
	                this.stream.disconnect(this);
	                var payload = Reassembler.reassemble(this, frame.data, frame.metadata);
	                try {
	                    this.cancellable = this.handler(payload, this);
	                }
	                catch (e) {
	                    // do nothing
	                }
	                return;
	            }
	        }
	        else {
	            errorMessage = "Unexpected frame type [".concat(frame.type, "]");
	        }
	        this.done = true;
	        if (frame.type != Frames_1.FrameTypes.CANCEL && frame.type != Frames_1.FrameTypes.ERROR) {
	            this.stream.send({
	                type: Frames_1.FrameTypes.ERROR,
	                streamId: this.streamId,
	                flags: Frames_1.Flags.NONE,
	                code: Errors_1.ErrorCodes.CANCELED,
	                message: errorMessage,
	            });
	        }
	        this.stream.disconnect(this);
	        Reassembler.cancel(this);
	        // TODO: throws if strict
	    };
	    RequestFnfResponderStream.prototype.close = function (error) {
	        var _a;
	        if (this.done) {
	            console.warn("Trying to close for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        this.done = true;
	        Reassembler.cancel(this);
	        (_a = this.cancellable) === null || _a === void 0 ? void 0 : _a.cancel();
	    };
	    RequestFnfResponderStream.prototype.onError = function (error) { };
	    RequestFnfResponderStream.prototype.onComplete = function () { };
	    return RequestFnfResponderStream;
	}());
	RequestFnFStream.RequestFnfResponderStream = RequestFnfResponderStream;
	/*
	export function request(
	  payload: Payload,
	  responderStream: UnidirectionalStream
	): Handler<Cancellable> {
	  return {
	    create: (r) => {
	      const response = new RequestFnFRequesterHandler(
	        payload,
	        responderStream,
	        r
	      );

	      r.add(response);

	      return response;
	    },
	  };
	}

	export function response(
	  handler: (payload: Payload, responderStream: UnidirectionalStream,) => void
	): Handler<void> {
	  return {
	    create: (r) => new RequestFnfResponderHandler(),
	  };
	} */
	
	return RequestFnFStream;
}

var RequestResponseStream = {};

var hasRequiredRequestResponseStream;

function requireRequestResponseStream () {
	if (hasRequiredRequestResponseStream) return RequestResponseStream;
	hasRequiredRequestResponseStream = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (RequestResponseStream && RequestResponseStream.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (RequestResponseStream && RequestResponseStream.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (RequestResponseStream && RequestResponseStream.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __values = (RequestResponseStream && RequestResponseStream.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(RequestResponseStream, "__esModule", { value: true });
	RequestResponseStream.RequestResponseResponderStream = RequestResponseStream.RequestResponseRequesterStream = void 0;
	var Errors_1 = requireErrors();
	var Fragmenter_1 = requireFragmenter();
	var Frames_1 = requireFrames();
	var Reassembler = __importStar(requireReassembler());
	var RequestResponseRequesterStream = /** @class */ (function () {
	    function RequestResponseRequesterStream(payload, receiver, fragmentSize, leaseManager) {
	        this.payload = payload;
	        this.receiver = receiver;
	        this.fragmentSize = fragmentSize;
	        this.leaseManager = leaseManager;
	        this.streamType = Frames_1.FrameTypes.REQUEST_RESPONSE;
	    }
	    RequestResponseRequesterStream.prototype.handleReady = function (streamId, stream) {
	        var e_1, _a;
	        if (this.done) {
	            return false;
	        }
	        this.streamId = streamId;
	        this.stream = stream;
	        stream.connect(this);
	        if ((0, Fragmenter_1.isFragmentable)(this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_RESPONSE)) {
	            try {
	                for (var _b = __values((0, Fragmenter_1.fragment)(streamId, this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_RESPONSE)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var frame = _c.value;
	                    this.stream.send(frame);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this.stream.send({
	                type: Frames_1.FrameTypes.REQUEST_RESPONSE,
	                data: this.payload.data,
	                metadata: this.payload.metadata,
	                flags: this.payload.metadata ? Frames_1.Flags.METADATA : 0,
	                streamId: streamId,
	            });
	        }
	        if (this.hasExtension) {
	            this.stream.send({
	                type: Frames_1.FrameTypes.EXT,
	                streamId: streamId,
	                extendedContent: this.extendedContent,
	                extendedType: this.extendedType,
	                flags: this.flags,
	            });
	        }
	        return true;
	    };
	    RequestResponseRequesterStream.prototype.handleReject = function (error) {
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        this.receiver.onError(error);
	    };
	    RequestResponseRequesterStream.prototype.handle = function (frame) {
	        var errorMessage;
	        var frameType = frame.type;
	        switch (frameType) {
	            case Frames_1.FrameTypes.PAYLOAD: {
	                var hasComplete = Frames_1.Flags.hasComplete(frame.flags);
	                var hasPayload = Frames_1.Flags.hasNext(frame.flags);
	                if (hasComplete || !Frames_1.Flags.hasFollows(frame.flags)) {
	                    this.done = true;
	                    this.stream.disconnect(this);
	                    if (!hasPayload) {
	                        // TODO: add validation no frame in reassembly
	                        this.receiver.onComplete();
	                        return;
	                    }
	                    var payload = this.hasFragments
	                        ? Reassembler.reassemble(this, frame.data, frame.metadata)
	                        : {
	                            data: frame.data,
	                            metadata: frame.metadata,
	                        };
	                    this.receiver.onNext(payload, true);
	                    return;
	                }
	                if (!Reassembler.add(this, frame.data, frame.metadata)) {
	                    errorMessage = "Unexpected fragment size";
	                    break;
	                }
	                return;
	            }
	            case Frames_1.FrameTypes.ERROR: {
	                this.done = true;
	                this.stream.disconnect(this);
	                Reassembler.cancel(this);
	                this.receiver.onError(new Errors_1.RSocketError(frame.code, frame.message));
	                return;
	            }
	            case Frames_1.FrameTypes.EXT: {
	                if (this.hasFragments) {
	                    errorMessage = "Unexpected frame type [".concat(frameType, "] during reassembly");
	                    break;
	                }
	                this.receiver.onExtension(frame.extendedType, frame.extendedContent, Frames_1.Flags.hasIgnore(frame.flags));
	                return;
	            }
	            default: {
	                errorMessage = "Unexpected frame type [".concat(frameType, "]");
	            }
	        }
	        this.close(new Errors_1.RSocketError(Errors_1.ErrorCodes.CANCELED, errorMessage));
	        this.stream.send({
	            type: Frames_1.FrameTypes.CANCEL,
	            streamId: this.streamId,
	            flags: Frames_1.Flags.NONE,
	        });
	        this.stream.disconnect(this);
	        // TODO: throw an exception if strict frame handling mode
	    };
	    RequestResponseRequesterStream.prototype.cancel = function () {
	        var _a;
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        if (!this.streamId) {
	            (_a = this.leaseManager) === null || _a === void 0 ? void 0 : _a.cancelRequest(this);
	            return;
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.CANCEL,
	            flags: Frames_1.Flags.NONE,
	            streamId: this.streamId,
	        });
	        this.stream.disconnect(this);
	        Reassembler.cancel(this);
	    };
	    RequestResponseRequesterStream.prototype.onExtension = function (extendedType, content, canBeIgnored) {
	        if (this.done) {
	            return;
	        }
	        if (!this.streamId) {
	            this.hasExtension = true;
	            this.extendedType = extendedType;
	            this.extendedContent = content;
	            this.flags = canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE;
	            return;
	        }
	        this.stream.send({
	            streamId: this.streamId,
	            type: Frames_1.FrameTypes.EXT,
	            extendedType: extendedType,
	            extendedContent: content,
	            flags: canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE,
	        });
	    };
	    RequestResponseRequesterStream.prototype.close = function (error) {
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        Reassembler.cancel(this);
	        if (error) {
	            this.receiver.onError(error);
	        }
	        else {
	            this.receiver.onComplete();
	        }
	    };
	    return RequestResponseRequesterStream;
	}());
	RequestResponseStream.RequestResponseRequesterStream = RequestResponseRequesterStream;
	var RequestResponseResponderStream = /** @class */ (function () {
	    function RequestResponseResponderStream(streamId, stream, fragmentSize, handler, frame) {
	        this.streamId = streamId;
	        this.stream = stream;
	        this.fragmentSize = fragmentSize;
	        this.handler = handler;
	        this.streamType = Frames_1.FrameTypes.REQUEST_RESPONSE;
	        stream.connect(this);
	        if (Frames_1.Flags.hasFollows(frame.flags)) {
	            Reassembler.add(this, frame.data, frame.metadata);
	            return;
	        }
	        var payload = {
	            data: frame.data,
	            metadata: frame.metadata,
	        };
	        try {
	            this.receiver = handler(payload, this);
	        }
	        catch (error) {
	            this.onError(error);
	        }
	    }
	    RequestResponseResponderStream.prototype.handle = function (frame) {
	        var _a;
	        var errorMessage;
	        if (!this.receiver || this.hasFragments) {
	            if (frame.type === Frames_1.FrameTypes.PAYLOAD) {
	                if (Frames_1.Flags.hasFollows(frame.flags)) {
	                    if (Reassembler.add(this, frame.data, frame.metadata)) {
	                        return;
	                    }
	                    errorMessage = "Unexpected fragment size";
	                }
	                else {
	                    var payload = Reassembler.reassemble(this, frame.data, frame.metadata);
	                    try {
	                        this.receiver = this.handler(payload, this);
	                    }
	                    catch (error) {
	                        this.onError(error);
	                    }
	                    return;
	                }
	            }
	            else {
	                errorMessage = "Unexpected frame type [".concat(frame.type, "] during reassembly");
	            }
	        }
	        else if (frame.type === Frames_1.FrameTypes.EXT) {
	            this.receiver.onExtension(frame.extendedType, frame.extendedContent, Frames_1.Flags.hasIgnore(frame.flags));
	            return;
	        }
	        else {
	            errorMessage = "Unexpected frame type [".concat(frame.type, "]");
	        }
	        this.done = true;
	        (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.cancel();
	        if (frame.type !== Frames_1.FrameTypes.CANCEL && frame.type !== Frames_1.FrameTypes.ERROR) {
	            this.stream.send({
	                type: Frames_1.FrameTypes.ERROR,
	                flags: Frames_1.Flags.NONE,
	                code: Errors_1.ErrorCodes.CANCELED,
	                message: errorMessage,
	                streamId: this.streamId,
	            });
	        }
	        this.stream.disconnect(this);
	        Reassembler.cancel(this);
	        // TODO: throws if strict
	    };
	    RequestResponseResponderStream.prototype.onError = function (error) {
	        if (this.done) {
	            console.warn("Trying to error for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        this.done = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.ERROR,
	            flags: Frames_1.Flags.NONE,
	            code: error instanceof Errors_1.RSocketError
	                ? error.code
	                : Errors_1.ErrorCodes.APPLICATION_ERROR,
	            message: error.message,
	            streamId: this.streamId,
	        });
	        this.stream.disconnect(this);
	    };
	    RequestResponseResponderStream.prototype.onNext = function (payload, isCompletion) {
	        var e_2, _a;
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        // TODO: add payload size validation
	        if ((0, Fragmenter_1.isFragmentable)(payload, this.fragmentSize, Frames_1.FrameTypes.PAYLOAD)) {
	            try {
	                for (var _b = __values((0, Fragmenter_1.fragment)(this.streamId, payload, this.fragmentSize, Frames_1.FrameTypes.PAYLOAD, true)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var frame = _c.value;
	                    this.stream.send(frame);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this.stream.send({
	                type: Frames_1.FrameTypes.PAYLOAD,
	                flags: Frames_1.Flags.NEXT | Frames_1.Flags.COMPLETE | (payload.metadata ? Frames_1.Flags.METADATA : 0),
	                data: payload.data,
	                metadata: payload.metadata,
	                streamId: this.streamId,
	            });
	        }
	        this.stream.disconnect(this);
	    };
	    RequestResponseResponderStream.prototype.onComplete = function () {
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.PAYLOAD,
	            flags: Frames_1.Flags.COMPLETE,
	            streamId: this.streamId,
	            data: null,
	            metadata: null,
	        });
	        this.stream.disconnect(this);
	    };
	    RequestResponseResponderStream.prototype.onExtension = function (extendedType, content, canBeIgnored) {
	        if (this.done) {
	            return;
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.EXT,
	            streamId: this.streamId,
	            flags: canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE,
	            extendedType: extendedType,
	            extendedContent: content,
	        });
	    };
	    RequestResponseResponderStream.prototype.close = function (error) {
	        var _a;
	        if (this.done) {
	            console.warn("Trying to close for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        Reassembler.cancel(this);
	        (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.cancel();
	    };
	    return RequestResponseResponderStream;
	}());
	RequestResponseStream.RequestResponseResponderStream = RequestResponseResponderStream;
	
	return RequestResponseStream;
}

var RequestStreamStream = {};

var hasRequiredRequestStreamStream;

function requireRequestStreamStream () {
	if (hasRequiredRequestStreamStream) return RequestStreamStream;
	hasRequiredRequestStreamStream = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (RequestStreamStream && RequestStreamStream.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (RequestStreamStream && RequestStreamStream.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (RequestStreamStream && RequestStreamStream.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __values = (RequestStreamStream && RequestStreamStream.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(RequestStreamStream, "__esModule", { value: true });
	RequestStreamStream.RequestStreamResponderStream = RequestStreamStream.RequestStreamRequesterStream = void 0;
	var Errors_1 = requireErrors();
	var Fragmenter_1 = requireFragmenter();
	var Frames_1 = requireFrames();
	var Reassembler = __importStar(requireReassembler());
	var RequestStreamRequesterStream = /** @class */ (function () {
	    function RequestStreamRequesterStream(payload, receiver, fragmentSize, initialRequestN, leaseManager) {
	        this.payload = payload;
	        this.receiver = receiver;
	        this.fragmentSize = fragmentSize;
	        this.initialRequestN = initialRequestN;
	        this.leaseManager = leaseManager;
	        this.streamType = Frames_1.FrameTypes.REQUEST_STREAM;
	        // TODO: add payload size validation
	    }
	    RequestStreamRequesterStream.prototype.handleReady = function (streamId, stream) {
	        var e_1, _a;
	        if (this.done) {
	            return false;
	        }
	        this.streamId = streamId;
	        this.stream = stream;
	        stream.connect(this);
	        if ((0, Fragmenter_1.isFragmentable)(this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_STREAM)) {
	            try {
	                for (var _b = __values((0, Fragmenter_1.fragmentWithRequestN)(streamId, this.payload, this.fragmentSize, Frames_1.FrameTypes.REQUEST_STREAM, this.initialRequestN)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var frame = _c.value;
	                    this.stream.send(frame);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this.stream.send({
	                type: Frames_1.FrameTypes.REQUEST_STREAM,
	                data: this.payload.data,
	                metadata: this.payload.metadata,
	                requestN: this.initialRequestN,
	                flags: this.payload.metadata !== undefined ? Frames_1.Flags.METADATA : 0,
	                streamId: streamId,
	            });
	        }
	        if (this.hasExtension) {
	            this.stream.send({
	                type: Frames_1.FrameTypes.EXT,
	                streamId: streamId,
	                extendedContent: this.extendedContent,
	                extendedType: this.extendedType,
	                flags: this.flags,
	            });
	        }
	        return true;
	    };
	    RequestStreamRequesterStream.prototype.handleReject = function (error) {
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        this.receiver.onError(error);
	    };
	    RequestStreamRequesterStream.prototype.handle = function (frame) {
	        var errorMessage;
	        var frameType = frame.type;
	        switch (frameType) {
	            case Frames_1.FrameTypes.PAYLOAD: {
	                var hasComplete = Frames_1.Flags.hasComplete(frame.flags);
	                var hasNext = Frames_1.Flags.hasNext(frame.flags);
	                if (hasComplete || !Frames_1.Flags.hasFollows(frame.flags)) {
	                    if (hasComplete) {
	                        this.done = true;
	                        this.stream.disconnect(this);
	                        if (!hasNext) {
	                            // TODO: add validation no frame in reassembly
	                            this.receiver.onComplete();
	                            return;
	                        }
	                    }
	                    var payload = this.hasFragments
	                        ? Reassembler.reassemble(this, frame.data, frame.metadata)
	                        : {
	                            data: frame.data,
	                            metadata: frame.metadata,
	                        };
	                    this.receiver.onNext(payload, hasComplete);
	                    return;
	                }
	                if (!Reassembler.add(this, frame.data, frame.metadata)) {
	                    errorMessage = "Unexpected fragment size";
	                    break;
	                }
	                return;
	            }
	            case Frames_1.FrameTypes.ERROR: {
	                this.done = true;
	                this.stream.disconnect(this);
	                Reassembler.cancel(this);
	                this.receiver.onError(new Errors_1.RSocketError(frame.code, frame.message));
	                return;
	            }
	            case Frames_1.FrameTypes.EXT: {
	                if (this.hasFragments) {
	                    errorMessage = "Unexpected frame type [".concat(frameType, "] during reassembly");
	                    break;
	                }
	                this.receiver.onExtension(frame.extendedType, frame.extendedContent, Frames_1.Flags.hasIgnore(frame.flags));
	                return;
	            }
	            default: {
	                errorMessage = "Unexpected frame type [".concat(frameType, "]");
	            }
	        }
	        this.close(new Errors_1.RSocketError(Errors_1.ErrorCodes.CANCELED, errorMessage));
	        this.stream.send({
	            type: Frames_1.FrameTypes.CANCEL,
	            streamId: this.streamId,
	            flags: Frames_1.Flags.NONE,
	        });
	        this.stream.disconnect(this);
	        // TODO: throw an exception if strict frame handling mode
	    };
	    RequestStreamRequesterStream.prototype.request = function (n) {
	        if (this.done) {
	            return;
	        }
	        if (!this.streamId) {
	            this.initialRequestN += n;
	            return;
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.REQUEST_N,
	            flags: Frames_1.Flags.NONE,
	            requestN: n,
	            streamId: this.streamId,
	        });
	    };
	    RequestStreamRequesterStream.prototype.cancel = function () {
	        var _a;
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        if (!this.streamId) {
	            (_a = this.leaseManager) === null || _a === void 0 ? void 0 : _a.cancelRequest(this);
	            return;
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.CANCEL,
	            flags: Frames_1.Flags.NONE,
	            streamId: this.streamId,
	        });
	        this.stream.disconnect(this);
	        Reassembler.cancel(this);
	    };
	    RequestStreamRequesterStream.prototype.onExtension = function (extendedType, content, canBeIgnored) {
	        if (this.done) {
	            return;
	        }
	        if (!this.streamId) {
	            this.hasExtension = true;
	            this.extendedType = extendedType;
	            this.extendedContent = content;
	            this.flags = canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE;
	            return;
	        }
	        this.stream.send({
	            streamId: this.streamId,
	            type: Frames_1.FrameTypes.EXT,
	            extendedType: extendedType,
	            extendedContent: content,
	            flags: canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE,
	        });
	    };
	    RequestStreamRequesterStream.prototype.close = function (error) {
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        Reassembler.cancel(this);
	        if (error) {
	            this.receiver.onError(error);
	        }
	        else {
	            this.receiver.onComplete();
	        }
	    };
	    return RequestStreamRequesterStream;
	}());
	RequestStreamStream.RequestStreamRequesterStream = RequestStreamRequesterStream;
	var RequestStreamResponderStream = /** @class */ (function () {
	    function RequestStreamResponderStream(streamId, stream, fragmentSize, handler, frame) {
	        this.streamId = streamId;
	        this.stream = stream;
	        this.fragmentSize = fragmentSize;
	        this.handler = handler;
	        this.streamType = Frames_1.FrameTypes.REQUEST_STREAM;
	        stream.connect(this);
	        if (Frames_1.Flags.hasFollows(frame.flags)) {
	            this.initialRequestN = frame.requestN;
	            Reassembler.add(this, frame.data, frame.metadata);
	            return;
	        }
	        var payload = {
	            data: frame.data,
	            metadata: frame.metadata,
	        };
	        try {
	            this.receiver = handler(payload, frame.requestN, this);
	        }
	        catch (error) {
	            this.onError(error);
	        }
	    }
	    RequestStreamResponderStream.prototype.handle = function (frame) {
	        var _a;
	        var errorMessage;
	        if (!this.receiver || this.hasFragments) {
	            if (frame.type === Frames_1.FrameTypes.PAYLOAD) {
	                if (Frames_1.Flags.hasFollows(frame.flags)) {
	                    if (Reassembler.add(this, frame.data, frame.metadata)) {
	                        return;
	                    }
	                    errorMessage = "Unexpected frame size";
	                }
	                else {
	                    var payload = Reassembler.reassemble(this, frame.data, frame.metadata);
	                    try {
	                        this.receiver = this.handler(payload, this.initialRequestN, this);
	                    }
	                    catch (error) {
	                        this.onError(error);
	                    }
	                    return;
	                }
	            }
	            else {
	                errorMessage = "Unexpected frame type [".concat(frame.type, "] during reassembly");
	            }
	        }
	        else if (frame.type === Frames_1.FrameTypes.REQUEST_N) {
	            this.receiver.request(frame.requestN);
	            return;
	        }
	        else if (frame.type === Frames_1.FrameTypes.EXT) {
	            this.receiver.onExtension(frame.extendedType, frame.extendedContent, Frames_1.Flags.hasIgnore(frame.flags));
	            return;
	        }
	        else {
	            errorMessage = "Unexpected frame type [".concat(frame.type, "]");
	        }
	        this.done = true;
	        Reassembler.cancel(this);
	        (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.cancel();
	        if (frame.type !== Frames_1.FrameTypes.CANCEL && frame.type !== Frames_1.FrameTypes.ERROR) {
	            this.stream.send({
	                type: Frames_1.FrameTypes.ERROR,
	                flags: Frames_1.Flags.NONE,
	                code: Errors_1.ErrorCodes.CANCELED,
	                message: errorMessage,
	                streamId: this.streamId,
	            });
	        }
	        this.stream.disconnect(this);
	        // TODO: throws if strict
	    };
	    RequestStreamResponderStream.prototype.onError = function (error) {
	        if (this.done) {
	            console.warn("Trying to error for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        this.done = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.ERROR,
	            flags: Frames_1.Flags.NONE,
	            code: error instanceof Errors_1.RSocketError
	                ? error.code
	                : Errors_1.ErrorCodes.APPLICATION_ERROR,
	            message: error.message,
	            streamId: this.streamId,
	        });
	        this.stream.disconnect(this);
	    };
	    RequestStreamResponderStream.prototype.onNext = function (payload, isCompletion) {
	        var e_2, _a;
	        if (this.done) {
	            return;
	        }
	        if (isCompletion) {
	            this.done = true;
	        }
	        // TODO: add payload size validation
	        if ((0, Fragmenter_1.isFragmentable)(payload, this.fragmentSize, Frames_1.FrameTypes.PAYLOAD)) {
	            try {
	                for (var _b = __values((0, Fragmenter_1.fragment)(this.streamId, payload, this.fragmentSize, Frames_1.FrameTypes.PAYLOAD, isCompletion)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                    var frame = _c.value;
	                    this.stream.send(frame);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this.stream.send({
	                type: Frames_1.FrameTypes.PAYLOAD,
	                flags: Frames_1.Flags.NEXT |
	                    (isCompletion ? Frames_1.Flags.COMPLETE : Frames_1.Flags.NONE) |
	                    (payload.metadata ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE),
	                data: payload.data,
	                metadata: payload.metadata,
	                streamId: this.streamId,
	            });
	        }
	        if (isCompletion) {
	            this.stream.disconnect(this);
	        }
	    };
	    RequestStreamResponderStream.prototype.onComplete = function () {
	        if (this.done) {
	            return;
	        }
	        this.done = true;
	        this.stream.send({
	            type: Frames_1.FrameTypes.PAYLOAD,
	            flags: Frames_1.Flags.COMPLETE,
	            streamId: this.streamId,
	            data: null,
	            metadata: null,
	        });
	        this.stream.disconnect(this);
	    };
	    RequestStreamResponderStream.prototype.onExtension = function (extendedType, content, canBeIgnored) {
	        if (this.done) {
	            return;
	        }
	        this.stream.send({
	            type: Frames_1.FrameTypes.EXT,
	            streamId: this.streamId,
	            flags: canBeIgnored ? Frames_1.Flags.IGNORE : Frames_1.Flags.NONE,
	            extendedType: extendedType,
	            extendedContent: content,
	        });
	    };
	    RequestStreamResponderStream.prototype.close = function (error) {
	        var _a;
	        if (this.done) {
	            console.warn("Trying to close for the second time. ".concat(error ? "Dropping error [".concat(error, "].") : ""));
	            return;
	        }
	        Reassembler.cancel(this);
	        (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.cancel();
	    };
	    return RequestStreamResponderStream;
	}());
	RequestStreamStream.RequestStreamResponderStream = RequestStreamResponderStream;
	
	return RequestStreamStream;
}

var hasRequiredRSocketSupport;

function requireRSocketSupport () {
	if (hasRequiredRSocketSupport) return RSocketSupport;
	hasRequiredRSocketSupport = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(RSocketSupport, "__esModule", { value: true });
	RSocketSupport.KeepAliveSender = RSocketSupport.KeepAliveHandler = RSocketSupport.DefaultConnectionFrameHandler = RSocketSupport.DefaultStreamRequestHandler = RSocketSupport.LeaseHandler = RSocketSupport.RSocketRequester = void 0;
	var Errors_1 = requireErrors();
	var Frames_1 = requireFrames();
	var RequestChannelStream_1 = requireRequestChannelStream();
	var RequestFnFStream_1 = requireRequestFnFStream();
	var RequestResponseStream_1 = requireRequestResponseStream();
	var RequestStreamStream_1 = requireRequestStreamStream();
	var RSocketRequester = /** @class */ (function () {
	    function RSocketRequester(connection, fragmentSize, leaseManager) {
	        this.connection = connection;
	        this.fragmentSize = fragmentSize;
	        this.leaseManager = leaseManager;
	    }
	    RSocketRequester.prototype.fireAndForget = function (payload, responderStream) {
	        var handler = new RequestFnFStream_1.RequestFnFRequesterStream(payload, responderStream, this.fragmentSize, this.leaseManager);
	        if (this.leaseManager) {
	            this.leaseManager.requestLease(handler);
	        }
	        else {
	            this.connection.multiplexerDemultiplexer.createRequestStream(handler);
	        }
	        return handler;
	    };
	    RSocketRequester.prototype.requestResponse = function (payload, responderStream) {
	        var handler = new RequestResponseStream_1.RequestResponseRequesterStream(payload, responderStream, this.fragmentSize, this.leaseManager);
	        if (this.leaseManager) {
	            this.leaseManager.requestLease(handler);
	        }
	        else {
	            this.connection.multiplexerDemultiplexer.createRequestStream(handler);
	        }
	        return handler;
	    };
	    RSocketRequester.prototype.requestStream = function (payload, initialRequestN, responderStream) {
	        var handler = new RequestStreamStream_1.RequestStreamRequesterStream(payload, responderStream, this.fragmentSize, initialRequestN, this.leaseManager);
	        if (this.leaseManager) {
	            this.leaseManager.requestLease(handler);
	        }
	        else {
	            this.connection.multiplexerDemultiplexer.createRequestStream(handler);
	        }
	        return handler;
	    };
	    RSocketRequester.prototype.requestChannel = function (payload, initialRequestN, isCompleted, responderStream) {
	        var handler = new RequestChannelStream_1.RequestChannelRequesterStream(payload, isCompleted, responderStream, this.fragmentSize, initialRequestN, this.leaseManager);
	        if (this.leaseManager) {
	            this.leaseManager.requestLease(handler);
	        }
	        else {
	            this.connection.multiplexerDemultiplexer.createRequestStream(handler);
	        }
	        return handler;
	    };
	    RSocketRequester.prototype.metadataPush = function (metadata, responderStream) {
	        throw new Error("Method not implemented.");
	    };
	    RSocketRequester.prototype.close = function (error) {
	        this.connection.close(error);
	    };
	    RSocketRequester.prototype.onClose = function (callback) {
	        this.connection.onClose(callback);
	    };
	    return RSocketRequester;
	}());
	RSocketSupport.RSocketRequester = RSocketRequester;
	var LeaseHandler = /** @class */ (function () {
	    function LeaseHandler(maxPendingRequests, multiplexer) {
	        this.maxPendingRequests = maxPendingRequests;
	        this.multiplexer = multiplexer;
	        this.pendingRequests = [];
	        this.expirationTime = 0;
	        this.availableLease = 0;
	    }
	    LeaseHandler.prototype.handle = function (frame) {
	        this.expirationTime = frame.ttl + Date.now();
	        this.availableLease = frame.requestCount;
	        while (this.availableLease > 0 && this.pendingRequests.length > 0) {
	            var handler = this.pendingRequests.shift();
	            this.availableLease--;
	            this.multiplexer.createRequestStream(handler);
	        }
	    };
	    LeaseHandler.prototype.requestLease = function (handler) {
	        var availableLease = this.availableLease;
	        if (availableLease > 0 && Date.now() < this.expirationTime) {
	            this.availableLease = availableLease - 1;
	            this.multiplexer.createRequestStream(handler);
	            return;
	        }
	        if (this.pendingRequests.length >= this.maxPendingRequests) {
	            handler.handleReject(new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED, "No available lease given"));
	            return;
	        }
	        this.pendingRequests.push(handler);
	    };
	    LeaseHandler.prototype.cancelRequest = function (handler) {
	        var index = this.pendingRequests.indexOf(handler);
	        if (index > -1) {
	            this.pendingRequests.splice(index, 1);
	        }
	    };
	    return LeaseHandler;
	}());
	RSocketSupport.LeaseHandler = LeaseHandler;
	var DefaultStreamRequestHandler = /** @class */ (function () {
	    function DefaultStreamRequestHandler(rsocket, fragmentSize) {
	        this.rsocket = rsocket;
	        this.fragmentSize = fragmentSize;
	    }
	    DefaultStreamRequestHandler.prototype.handle = function (frame, stream) {
	        switch (frame.type) {
	            case Frames_1.FrameTypes.REQUEST_FNF:
	                if (this.rsocket.fireAndForget) {
	                    new RequestFnFStream_1.RequestFnfResponderStream(frame.streamId, stream, this.rsocket.fireAndForget.bind(this.rsocket), frame);
	                }
	                return;
	            case Frames_1.FrameTypes.REQUEST_RESPONSE:
	                if (this.rsocket.requestResponse) {
	                    new RequestResponseStream_1.RequestResponseResponderStream(frame.streamId, stream, this.fragmentSize, this.rsocket.requestResponse.bind(this.rsocket), frame);
	                    return;
	                }
	                this.rejectRequest(frame.streamId, stream);
	                return;
	            case Frames_1.FrameTypes.REQUEST_STREAM:
	                if (this.rsocket.requestStream) {
	                    new RequestStreamStream_1.RequestStreamResponderStream(frame.streamId, stream, this.fragmentSize, this.rsocket.requestStream.bind(this.rsocket), frame);
	                    return;
	                }
	                this.rejectRequest(frame.streamId, stream);
	                return;
	            case Frames_1.FrameTypes.REQUEST_CHANNEL:
	                if (this.rsocket.requestChannel) {
	                    new RequestChannelStream_1.RequestChannelResponderStream(frame.streamId, stream, this.fragmentSize, this.rsocket.requestChannel.bind(this.rsocket), frame);
	                    return;
	                }
	                this.rejectRequest(frame.streamId, stream);
	                return;
	        }
	    };
	    DefaultStreamRequestHandler.prototype.rejectRequest = function (streamId, stream) {
	        stream.send({
	            type: Frames_1.FrameTypes.ERROR,
	            streamId: streamId,
	            flags: Frames_1.Flags.NONE,
	            code: Errors_1.ErrorCodes.REJECTED,
	            message: "No available handler found",
	        });
	    };
	    DefaultStreamRequestHandler.prototype.close = function () { };
	    return DefaultStreamRequestHandler;
	}());
	RSocketSupport.DefaultStreamRequestHandler = DefaultStreamRequestHandler;
	var DefaultConnectionFrameHandler = /** @class */ (function () {
	    function DefaultConnectionFrameHandler(connection, keepAliveHandler, keepAliveSender, leaseHandler, rsocket) {
	        this.connection = connection;
	        this.keepAliveHandler = keepAliveHandler;
	        this.keepAliveSender = keepAliveSender;
	        this.leaseHandler = leaseHandler;
	        this.rsocket = rsocket;
	    }
	    DefaultConnectionFrameHandler.prototype.handle = function (frame) {
	        switch (frame.type) {
	            case Frames_1.FrameTypes.KEEPALIVE:
	                this.keepAliveHandler.handle(frame);
	                return;
	            case Frames_1.FrameTypes.LEASE:
	                if (this.leaseHandler) {
	                    this.leaseHandler.handle(frame);
	                    return;
	                }
	                // TODO throw exception and close connection
	                return;
	            case Frames_1.FrameTypes.ERROR:
	                // TODO: add code validation
	                this.connection.close(new Errors_1.RSocketError(frame.code, frame.message));
	                return;
	            case Frames_1.FrameTypes.METADATA_PUSH:
	                if (this.rsocket.metadataPush) ;
	                return;
	            default:
	                this.connection.multiplexerDemultiplexer.connectionOutbound.send({
	                    type: Frames_1.FrameTypes.ERROR,
	                    streamId: 0,
	                    flags: Frames_1.Flags.NONE,
	                    message: "Received unknown frame type",
	                    code: Errors_1.ErrorCodes.CONNECTION_ERROR,
	                });
	            // TODO: throw an exception and close connection
	        }
	    };
	    DefaultConnectionFrameHandler.prototype.pause = function () {
	        var _a;
	        this.keepAliveHandler.pause();
	        (_a = this.keepAliveSender) === null || _a === void 0 ? void 0 : _a.pause();
	    };
	    DefaultConnectionFrameHandler.prototype.resume = function () {
	        var _a;
	        this.keepAliveHandler.start();
	        (_a = this.keepAliveSender) === null || _a === void 0 ? void 0 : _a.start();
	    };
	    DefaultConnectionFrameHandler.prototype.close = function (error) {
	        var _a;
	        this.keepAliveHandler.close();
	        (_a = this.rsocket.close) === null || _a === void 0 ? void 0 : _a.call(this.rsocket, error);
	    };
	    return DefaultConnectionFrameHandler;
	}());
	RSocketSupport.DefaultConnectionFrameHandler = DefaultConnectionFrameHandler;
	var KeepAliveHandlerStates;
	(function (KeepAliveHandlerStates) {
	    KeepAliveHandlerStates[KeepAliveHandlerStates["Paused"] = 0] = "Paused";
	    KeepAliveHandlerStates[KeepAliveHandlerStates["Running"] = 1] = "Running";
	    KeepAliveHandlerStates[KeepAliveHandlerStates["Closed"] = 2] = "Closed";
	})(KeepAliveHandlerStates || (KeepAliveHandlerStates = {}));
	var KeepAliveHandler = /** @class */ (function () {
	    function KeepAliveHandler(connection, keepAliveTimeoutDuration) {
	        this.connection = connection;
	        this.keepAliveTimeoutDuration = keepAliveTimeoutDuration;
	        this.state = KeepAliveHandlerStates.Paused;
	        this.outbound = connection.multiplexerDemultiplexer.connectionOutbound;
	    }
	    KeepAliveHandler.prototype.handle = function (frame) {
	        this.keepAliveLastReceivedMillis = Date.now();
	        if (Frames_1.Flags.hasRespond(frame.flags)) {
	            this.outbound.send({
	                type: Frames_1.FrameTypes.KEEPALIVE,
	                streamId: 0,
	                data: frame.data,
	                flags: frame.flags ^ Frames_1.Flags.RESPOND,
	                lastReceivedPosition: 0,
	            });
	        }
	    };
	    KeepAliveHandler.prototype.start = function () {
	        if (this.state !== KeepAliveHandlerStates.Paused) {
	            return;
	        }
	        this.keepAliveLastReceivedMillis = Date.now();
	        this.state = KeepAliveHandlerStates.Running;
	        this.activeTimeout = setTimeout(this.timeoutCheck.bind(this), this.keepAliveTimeoutDuration);
	    };
	    KeepAliveHandler.prototype.pause = function () {
	        if (this.state !== KeepAliveHandlerStates.Running) {
	            return;
	        }
	        this.state = KeepAliveHandlerStates.Paused;
	        clearTimeout(this.activeTimeout);
	    };
	    KeepAliveHandler.prototype.close = function () {
	        this.state = KeepAliveHandlerStates.Closed;
	        clearTimeout(this.activeTimeout);
	    };
	    KeepAliveHandler.prototype.timeoutCheck = function () {
	        var now = Date.now();
	        var noKeepAliveDuration = now - this.keepAliveLastReceivedMillis;
	        if (noKeepAliveDuration >= this.keepAliveTimeoutDuration) {
	            this.connection.close(new Error("No keep-alive acks for ".concat(this.keepAliveTimeoutDuration, " millis")));
	        }
	        else {
	            this.activeTimeout = setTimeout(this.timeoutCheck.bind(this), Math.max(100, this.keepAliveTimeoutDuration - noKeepAliveDuration));
	        }
	    };
	    return KeepAliveHandler;
	}());
	RSocketSupport.KeepAliveHandler = KeepAliveHandler;
	var KeepAliveSenderStates;
	(function (KeepAliveSenderStates) {
	    KeepAliveSenderStates[KeepAliveSenderStates["Paused"] = 0] = "Paused";
	    KeepAliveSenderStates[KeepAliveSenderStates["Running"] = 1] = "Running";
	    KeepAliveSenderStates[KeepAliveSenderStates["Closed"] = 2] = "Closed";
	})(KeepAliveSenderStates || (KeepAliveSenderStates = {}));
	var KeepAliveSender = /** @class */ (function () {
	    function KeepAliveSender(outbound, keepAlivePeriodDuration) {
	        this.outbound = outbound;
	        this.keepAlivePeriodDuration = keepAlivePeriodDuration;
	        this.state = KeepAliveSenderStates.Paused;
	    }
	    KeepAliveSender.prototype.sendKeepAlive = function () {
	        this.outbound.send({
	            type: Frames_1.FrameTypes.KEEPALIVE,
	            streamId: 0,
	            data: undefined,
	            flags: Frames_1.Flags.RESPOND,
	            lastReceivedPosition: 0,
	        });
	    };
	    KeepAliveSender.prototype.start = function () {
	        if (this.state !== KeepAliveSenderStates.Paused) {
	            return;
	        }
	        this.state = KeepAliveSenderStates.Running;
	        this.activeInterval = setInterval(this.sendKeepAlive.bind(this), this.keepAlivePeriodDuration);
	    };
	    KeepAliveSender.prototype.pause = function () {
	        if (this.state !== KeepAliveSenderStates.Running) {
	            return;
	        }
	        this.state = KeepAliveSenderStates.Paused;
	        clearInterval(this.activeInterval);
	    };
	    KeepAliveSender.prototype.close = function () {
	        this.state = KeepAliveSenderStates.Closed;
	        clearInterval(this.activeInterval);
	    };
	    return KeepAliveSender;
	}());
	RSocketSupport.KeepAliveSender = KeepAliveSender;
	
	return RSocketSupport;
}

var Resume = {};

var hasRequiredResume;

function requireResume () {
	if (hasRequiredResume) return Resume;
	hasRequiredResume = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __values = (Resume && Resume.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(Resume, "__esModule", { value: true });
	Resume.FrameStore = void 0;
	var _1 = requireDist();
	var Codecs_1 = requireCodecs();
	var FrameStore = /** @class */ (function () {
	    function FrameStore() {
	        this.storedFrames = [];
	        this._lastReceivedFramePosition = 0;
	        this._firstAvailableFramePosition = 0;
	        this._lastSentFramePosition = 0;
	    }
	    Object.defineProperty(FrameStore.prototype, "lastReceivedFramePosition", {
	        get: function () {
	            return this._lastReceivedFramePosition;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FrameStore.prototype, "firstAvailableFramePosition", {
	        get: function () {
	            return this._firstAvailableFramePosition;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(FrameStore.prototype, "lastSentFramePosition", {
	        get: function () {
	            return this._lastSentFramePosition;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    FrameStore.prototype.store = function (frame) {
	        this._lastSentFramePosition += (0, Codecs_1.sizeOfFrame)(frame);
	        this.storedFrames.push(frame);
	    };
	    FrameStore.prototype.record = function (frame) {
	        this._lastReceivedFramePosition += (0, Codecs_1.sizeOfFrame)(frame);
	    };
	    FrameStore.prototype.dropTo = function (lastReceivedPosition) {
	        var bytesToDrop = lastReceivedPosition - this._firstAvailableFramePosition;
	        while (bytesToDrop > 0 && this.storedFrames.length > 0) {
	            var storedFrame = this.storedFrames.shift();
	            bytesToDrop -= (0, Codecs_1.sizeOfFrame)(storedFrame);
	        }
	        if (bytesToDrop !== 0) {
	            throw new _1.RSocketError(_1.ErrorCodes.CONNECTION_ERROR, "State inconsistency. Expected bytes to drop ".concat(lastReceivedPosition - this._firstAvailableFramePosition, " but actual ").concat(bytesToDrop));
	        }
	        this._firstAvailableFramePosition = lastReceivedPosition;
	    };
	    FrameStore.prototype.drain = function (consumer) {
	        var e_1, _a;
	        try {
	            for (var _b = __values(this.storedFrames), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var frame = _c.value;
	                consumer(frame);
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    return FrameStore;
	}());
	Resume.FrameStore = FrameStore;
	
	return Resume;
}

var hasRequiredRSocketConnector;

function requireRSocketConnector () {
	if (hasRequiredRSocketConnector) return RSocketConnector;
	hasRequiredRSocketConnector = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __awaiter = (RSocketConnector && RSocketConnector.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (RSocketConnector && RSocketConnector.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(RSocketConnector, "__esModule", { value: true });
	RSocketConnector.RSocketConnector = void 0;
	var ClientServerMultiplexerDemultiplexer_1 = requireClientServerMultiplexerDemultiplexer();
	var Frames_1 = requireFrames();
	var RSocketSupport_1 = requireRSocketSupport();
	var Resume_1 = requireResume();
	var RSocketConnector$1 = /** @class */ (function () {
	    function RSocketConnector(config) {
	        this.config = config;
	    }
	    RSocketConnector.prototype.connect = function () {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
	        return __awaiter(this, void 0, void 0, function () {
	            var config, setupFrame, connection, keepAliveSender, keepAliveHandler, leaseHandler, responder, connectionFrameHandler, streamsHandler;
	            var _this = this;
	            return __generator(this, function (_w) {
	                switch (_w.label) {
	                    case 0:
	                        config = this.config;
	                        setupFrame = {
	                            type: Frames_1.FrameTypes.SETUP,
	                            dataMimeType: (_b = (_a = config.setup) === null || _a === void 0 ? void 0 : _a.dataMimeType) !== null && _b !== void 0 ? _b : "application/octet-stream",
	                            metadataMimeType: (_d = (_c = config.setup) === null || _c === void 0 ? void 0 : _c.metadataMimeType) !== null && _d !== void 0 ? _d : "application/octet-stream",
	                            keepAlive: (_f = (_e = config.setup) === null || _e === void 0 ? void 0 : _e.keepAlive) !== null && _f !== void 0 ? _f : 60000,
	                            lifetime: (_h = (_g = config.setup) === null || _g === void 0 ? void 0 : _g.lifetime) !== null && _h !== void 0 ? _h : 300000,
	                            metadata: (_k = (_j = config.setup) === null || _j === void 0 ? void 0 : _j.payload) === null || _k === void 0 ? void 0 : _k.metadata,
	                            data: (_m = (_l = config.setup) === null || _l === void 0 ? void 0 : _l.payload) === null || _m === void 0 ? void 0 : _m.data,
	                            resumeToken: (_p = (_o = config.resume) === null || _o === void 0 ? void 0 : _o.tokenGenerator()) !== null && _p !== void 0 ? _p : null,
	                            streamId: 0,
	                            majorVersion: 1,
	                            minorVersion: 0,
	                            flags: (((_r = (_q = config.setup) === null || _q === void 0 ? void 0 : _q.payload) === null || _r === void 0 ? void 0 : _r.metadata) ? Frames_1.Flags.METADATA : Frames_1.Flags.NONE) |
	                                (config.lease ? Frames_1.Flags.LEASE : Frames_1.Flags.NONE) |
	                                (config.resume ? Frames_1.Flags.RESUME_ENABLE : Frames_1.Flags.NONE),
	                        };
	                        return [4 /*yield*/, config.transport.connect(function (outbound) {
	                                return config.resume
	                                    ? new ClientServerMultiplexerDemultiplexer_1.ResumableClientServerInputMultiplexerDemultiplexer(ClientServerMultiplexerDemultiplexer_1.StreamIdGenerator.create(-1), outbound, outbound, new Resume_1.FrameStore(), // TODO: add size control
	                                    setupFrame.resumeToken.toString(), function (self, frameStore) { return __awaiter(_this, void 0, void 0, function () {
	                                        var multiplexerDemultiplexerProvider, reconnectionAttempts, reconnector;
	                                        return __generator(this, function (_a) {
	                                            switch (_a.label) {
	                                                case 0:
	                                                    multiplexerDemultiplexerProvider = function (outbound) {
	                                                        outbound.send({
	                                                            type: Frames_1.FrameTypes.RESUME,
	                                                            streamId: 0,
	                                                            flags: Frames_1.Flags.NONE,
	                                                            clientPosition: frameStore.firstAvailableFramePosition,
	                                                            serverPosition: frameStore.lastReceivedFramePosition,
	                                                            majorVersion: setupFrame.minorVersion,
	                                                            minorVersion: setupFrame.majorVersion,
	                                                            resumeToken: setupFrame.resumeToken,
	                                                        });
	                                                        return new ClientServerMultiplexerDemultiplexer_1.ResumeOkAwaitingResumableClientServerInputMultiplexerDemultiplexer(outbound, outbound, self);
	                                                    };
	                                                    reconnectionAttempts = -1;
	                                                    reconnector = function () {
	                                                        reconnectionAttempts++;
	                                                        return config.resume
	                                                            .reconnectFunction(reconnectionAttempts)
	                                                            .then(function () {
	                                                            return config.transport
	                                                                .connect(multiplexerDemultiplexerProvider)
	                                                                .catch(reconnector);
	                                                        });
	                                                    };
	                                                    return [4 /*yield*/, reconnector()];
	                                                case 1:
	                                                    _a.sent();
	                                                    return [2 /*return*/];
	                                            }
	                                        });
	                                    }); })
	                                    : new ClientServerMultiplexerDemultiplexer_1.ClientServerInputMultiplexerDemultiplexer(ClientServerMultiplexerDemultiplexer_1.StreamIdGenerator.create(-1), outbound, outbound);
	                            })];
	                    case 1:
	                        connection = _w.sent();
	                        keepAliveSender = new RSocketSupport_1.KeepAliveSender(connection.multiplexerDemultiplexer.connectionOutbound, setupFrame.keepAlive);
	                        keepAliveHandler = new RSocketSupport_1.KeepAliveHandler(connection, setupFrame.lifetime);
	                        leaseHandler = config.lease
	                            ? new RSocketSupport_1.LeaseHandler((_s = config.lease.maxPendingRequests) !== null && _s !== void 0 ? _s : 256, connection.multiplexerDemultiplexer)
	                            : undefined;
	                        responder = (_t = config.responder) !== null && _t !== void 0 ? _t : {};
	                        connectionFrameHandler = new RSocketSupport_1.DefaultConnectionFrameHandler(connection, keepAliveHandler, keepAliveSender, leaseHandler, responder);
	                        streamsHandler = new RSocketSupport_1.DefaultStreamRequestHandler(responder, 0);
	                        connection.onClose(function (e) {
	                            keepAliveSender.close();
	                            keepAliveHandler.close();
	                            connectionFrameHandler.close(e);
	                        });
	                        connection.multiplexerDemultiplexer.connectionInbound(connectionFrameHandler);
	                        connection.multiplexerDemultiplexer.handleRequestStream(streamsHandler);
	                        connection.multiplexerDemultiplexer.connectionOutbound.send(setupFrame);
	                        keepAliveHandler.start();
	                        keepAliveSender.start();
	                        return [2 /*return*/, new RSocketSupport_1.RSocketRequester(connection, (_v = (_u = config.fragmentation) === null || _u === void 0 ? void 0 : _u.maxOutboundFragmentSize) !== null && _v !== void 0 ? _v : 0, leaseHandler)];
	                }
	            });
	        });
	    };
	    return RSocketConnector;
	}());
	RSocketConnector.RSocketConnector = RSocketConnector$1;
	
	return RSocketConnector;
}

var RSocketServer = {};

var hasRequiredRSocketServer;

function requireRSocketServer () {
	if (hasRequiredRSocketServer) return RSocketServer;
	hasRequiredRSocketServer = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __awaiter = (RSocketServer && RSocketServer.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (RSocketServer && RSocketServer.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(RSocketServer, "__esModule", { value: true });
	RSocketServer.RSocketServer = void 0;
	var ClientServerMultiplexerDemultiplexer_1 = requireClientServerMultiplexerDemultiplexer();
	var Errors_1 = requireErrors();
	var Frames_1 = requireFrames();
	var RSocketSupport_1 = requireRSocketSupport();
	var Resume_1 = requireResume();
	var RSocketServer$1 = /** @class */ (function () {
	    function RSocketServer(config) {
	        var _a, _b;
	        this.acceptor = config.acceptor;
	        this.transport = config.transport;
	        this.lease = config.lease;
	        this.serverSideKeepAlive = config.serverSideKeepAlive;
	        this.sessionStore = config.resume ? {} : undefined;
	        this.sessionTimeout = (_b = (_a = config.resume) === null || _a === void 0 ? void 0 : _a.sessionTimeout) !== null && _b !== void 0 ? _b : undefined;
	    }
	    RSocketServer.prototype.bind = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.transport.bind(function (frame, connection) { return __awaiter(_this, void 0, void 0, function () {
	                            var _a, error, error, leaseHandler, requester, responder, keepAliveHandler_1, keepAliveSender_1, connectionFrameHandler_1, streamsHandler, e_1;
	                            var _b, _c, _d, _e;
	                            return __generator(this, function (_f) {
	                                switch (_f.label) {
	                                    case 0:
	                                        _a = frame.type;
	                                        switch (_a) {
	                                            case Frames_1.FrameTypes.SETUP: return [3 /*break*/, 1];
	                                            case Frames_1.FrameTypes.RESUME: return [3 /*break*/, 5];
	                                        }
	                                        return [3 /*break*/, 6];
	                                    case 1:
	                                        _f.trys.push([1, 3, , 4]);
	                                        if (this.lease && !Frames_1.Flags.hasLease(frame.flags)) {
	                                            error = new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED_SETUP, "Lease has to be enabled");
	                                            connection.multiplexerDemultiplexer.connectionOutbound.send({
	                                                type: Frames_1.FrameTypes.ERROR,
	                                                streamId: 0,
	                                                flags: Frames_1.Flags.NONE,
	                                                code: error.code,
	                                                message: error.message,
	                                            });
	                                            connection.close(error);
	                                            return [2 /*return*/];
	                                        }
	                                        if (Frames_1.Flags.hasLease(frame.flags) && !this.lease) {
	                                            error = new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED_SETUP, "Lease has to be disabled");
	                                            connection.multiplexerDemultiplexer.connectionOutbound.send({
	                                                type: Frames_1.FrameTypes.ERROR,
	                                                streamId: 0,
	                                                flags: Frames_1.Flags.NONE,
	                                                code: error.code,
	                                                message: error.message,
	                                            });
	                                            connection.close(error);
	                                            return [2 /*return*/];
	                                        }
	                                        leaseHandler = Frames_1.Flags.hasLease(frame.flags)
	                                            ? new RSocketSupport_1.LeaseHandler((_b = this.lease.maxPendingRequests) !== null && _b !== void 0 ? _b : 256, connection.multiplexerDemultiplexer)
	                                            : undefined;
	                                        requester = new RSocketSupport_1.RSocketRequester(connection, (_d = (_c = this.fragmentation) === null || _c === void 0 ? void 0 : _c.maxOutboundFragmentSize) !== null && _d !== void 0 ? _d : 0, leaseHandler);
	                                        return [4 /*yield*/, this.acceptor.accept({
	                                                data: frame.data,
	                                                dataMimeType: frame.dataMimeType,
	                                                metadata: frame.metadata,
	                                                metadataMimeType: frame.metadataMimeType,
	                                                flags: frame.flags,
	                                                keepAliveMaxLifetime: frame.lifetime,
	                                                keepAliveInterval: frame.keepAlive,
	                                                resumeToken: frame.resumeToken,
	                                            }, requester)];
	                                    case 2:
	                                        responder = _f.sent();
	                                        keepAliveHandler_1 = new RSocketSupport_1.KeepAliveHandler(connection, frame.lifetime);
	                                        keepAliveSender_1 = this.serverSideKeepAlive
	                                            ? new RSocketSupport_1.KeepAliveSender(connection.multiplexerDemultiplexer.connectionOutbound, frame.keepAlive)
	                                            : undefined;
	                                        connectionFrameHandler_1 = new RSocketSupport_1.DefaultConnectionFrameHandler(connection, keepAliveHandler_1, keepAliveSender_1, leaseHandler, responder);
	                                        streamsHandler = new RSocketSupport_1.DefaultStreamRequestHandler(responder, 0);
	                                        connection.onClose(function (e) {
	                                            keepAliveSender_1 === null || keepAliveSender_1 === void 0 ? void 0 : keepAliveSender_1.close();
	                                            keepAliveHandler_1.close();
	                                            connectionFrameHandler_1.close(e);
	                                        });
	                                        connection.multiplexerDemultiplexer.connectionInbound(connectionFrameHandler_1);
	                                        connection.multiplexerDemultiplexer.handleRequestStream(streamsHandler);
	                                        keepAliveHandler_1.start();
	                                        keepAliveSender_1 === null || keepAliveSender_1 === void 0 ? void 0 : keepAliveSender_1.start();
	                                        return [3 /*break*/, 4];
	                                    case 3:
	                                        e_1 = _f.sent();
	                                        connection.multiplexerDemultiplexer.connectionOutbound.send({
	                                            type: Frames_1.FrameTypes.ERROR,
	                                            streamId: 0,
	                                            code: Errors_1.ErrorCodes.REJECTED_SETUP,
	                                            message: (_e = e_1.message) !== null && _e !== void 0 ? _e : "",
	                                            flags: Frames_1.Flags.NONE,
	                                        });
	                                        connection.close(e_1 instanceof Errors_1.RSocketError
	                                            ? e_1
	                                            : new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED_SETUP, e_1.message));
	                                        return [3 /*break*/, 4];
	                                    case 4: return [2 /*return*/];
	                                    case 5:
	                                        {
	                                            // frame should be handled earlier
	                                            return [2 /*return*/];
	                                        }
	                                    case 6:
	                                        {
	                                            connection.multiplexerDemultiplexer.connectionOutbound.send({
	                                                type: Frames_1.FrameTypes.ERROR,
	                                                streamId: 0,
	                                                code: Errors_1.ErrorCodes.UNSUPPORTED_SETUP,
	                                                message: "Unsupported setup",
	                                                flags: Frames_1.Flags.NONE,
	                                            });
	                                            connection.close(new Errors_1.RSocketError(Errors_1.ErrorCodes.UNSUPPORTED_SETUP));
	                                        }
	                                        _f.label = 7;
	                                    case 7: return [2 /*return*/];
	                                }
	                            });
	                        }); }, function (frame, outbound) {
	                            if (frame.type === Frames_1.FrameTypes.RESUME) {
	                                if (_this.sessionStore) {
	                                    var multiplexerDemultiplexer = _this.sessionStore[frame.resumeToken.toString()];
	                                    if (!multiplexerDemultiplexer) {
	                                        outbound.send({
	                                            type: Frames_1.FrameTypes.ERROR,
	                                            streamId: 0,
	                                            code: Errors_1.ErrorCodes.REJECTED_RESUME,
	                                            message: "No session found for the given resume token",
	                                            flags: Frames_1.Flags.NONE,
	                                        });
	                                        outbound.close();
	                                        return;
	                                    }
	                                    multiplexerDemultiplexer.resume(frame, outbound, outbound);
	                                    return multiplexerDemultiplexer;
	                                }
	                                outbound.send({
	                                    type: Frames_1.FrameTypes.ERROR,
	                                    streamId: 0,
	                                    code: Errors_1.ErrorCodes.REJECTED_RESUME,
	                                    message: "Resume is not enabled",
	                                    flags: Frames_1.Flags.NONE,
	                                });
	                                outbound.close();
	                                return;
	                            }
	                            else if (frame.type === Frames_1.FrameTypes.SETUP) {
	                                if (Frames_1.Flags.hasResume(frame.flags)) {
	                                    if (!_this.sessionStore) {
	                                        var error = new Errors_1.RSocketError(Errors_1.ErrorCodes.REJECTED_SETUP, "No resume support");
	                                        outbound.send({
	                                            type: Frames_1.FrameTypes.ERROR,
	                                            streamId: 0,
	                                            flags: Frames_1.Flags.NONE,
	                                            code: error.code,
	                                            message: error.message,
	                                        });
	                                        outbound.close(error);
	                                        return;
	                                    }
	                                    var multiplexerDumiltiplexer = new ClientServerMultiplexerDemultiplexer_1.ResumableClientServerInputMultiplexerDemultiplexer(ClientServerMultiplexerDemultiplexer_1.StreamIdGenerator.create(0), outbound, outbound, new Resume_1.FrameStore(), // TODO: add size parameter
	                                    frame.resumeToken.toString(), _this.sessionStore, _this.sessionTimeout);
	                                    _this.sessionStore[frame.resumeToken.toString()] =
	                                        multiplexerDumiltiplexer;
	                                    return multiplexerDumiltiplexer;
	                                }
	                            }
	                            return new ClientServerMultiplexerDemultiplexer_1.ClientServerInputMultiplexerDemultiplexer(ClientServerMultiplexerDemultiplexer_1.StreamIdGenerator.create(0), outbound, outbound);
	                        })];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    return RSocketServer;
	}());
	RSocketServer.RSocketServer = RSocketServer$1;
	
	return RSocketServer;
}

var Transport = {};

var hasRequiredTransport;

function requireTransport () {
	if (hasRequiredTransport) return Transport;
	hasRequiredTransport = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Transport, "__esModule", { value: true });
	
	return Transport;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function (exports) {
		/*
		 * Copyright 2021-2022 the original author or authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist && dist.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireCodecs(), exports);
		__exportStar(requireCommon(), exports);
		__exportStar(requireDeferred(), exports);
		__exportStar(requireErrors(), exports);
		__exportStar(requireFrames(), exports);
		__exportStar(requireRSocket(), exports);
		__exportStar(requireRSocketConnector(), exports);
		__exportStar(requireRSocketServer(), exports);
		__exportStar(requireTransport(), exports);
		
	} (dist));
	return dist;
}

var distExports = requireDist();

var version = "1.43.1";
var PACKAGE = {
	version: version};

const DEFAULT_PRESSURE_LIMITS = {
    highWater: 10,
    lowWater: 0
};
/**
 * A very basic implementation of a data stream with backpressure support which does not use
 * native JS streams or async iterators.
 * This is handy for environments such as React Native which need polyfills for the above.
 */
class DataStream extends BaseObserver {
    options;
    dataQueue;
    isClosed;
    processingPromise;
    notifyDataAdded;
    logger;
    mapLine;
    constructor(options) {
        super();
        this.options = options;
        this.processingPromise = null;
        this.isClosed = false;
        this.dataQueue = [];
        this.mapLine = options?.mapLine ?? ((line) => line);
        this.logger = options?.logger ?? Logger.get('DataStream');
        if (options?.closeOnError) {
            const l = this.registerListener({
                error: (ex) => {
                    l?.();
                    this.close();
                }
            });
        }
    }
    get highWatermark() {
        return this.options?.pressure?.highWaterMark ?? DEFAULT_PRESSURE_LIMITS.highWater;
    }
    get lowWatermark() {
        return this.options?.pressure?.lowWaterMark ?? DEFAULT_PRESSURE_LIMITS.lowWater;
    }
    get closed() {
        return this.isClosed;
    }
    async close() {
        this.isClosed = true;
        await this.processingPromise;
        this.iterateListeners((l) => l.closed?.());
        // Discard any data in the queue
        this.dataQueue = [];
        this.listeners.clear();
    }
    /**
     * Enqueues data for the consumers to read
     */
    enqueueData(data) {
        if (this.isClosed) {
            throw new Error('Cannot enqueue data into closed stream.');
        }
        this.dataQueue.push(data);
        this.notifyDataAdded?.();
        this.processQueue();
    }
    /**
     * Reads data once from the data stream
     * @returns a Data payload or Null if the stream closed.
     */
    async read() {
        if (this.closed) {
            return null;
        }
        return new Promise((resolve, reject) => {
            const l = this.registerListener({
                data: async (data) => {
                    resolve(data);
                    // Remove the listener
                    l?.();
                },
                closed: () => {
                    resolve(null);
                    l?.();
                },
                error: (ex) => {
                    reject(ex);
                    l?.();
                }
            });
            this.processQueue();
        });
    }
    /**
     * Executes a callback for each data item in the stream
     */
    forEach(callback) {
        if (this.dataQueue.length <= this.lowWatermark) {
            this.iterateAsyncErrored(async (l) => l.lowWater?.());
        }
        return this.registerListener({
            data: callback
        });
    }
    processQueue() {
        if (this.processingPromise) {
            return;
        }
        const promise = (this.processingPromise = this._processQueue());
        promise.finally(() => {
            return (this.processingPromise = null);
        });
        return promise;
    }
    hasDataReader() {
        return Array.from(this.listeners.values()).some((l) => !!l.data);
    }
    async _processQueue() {
        /**
         * Allow listeners to mutate the queue before processing.
         * This allows for operations such as dropping or compressing data
         * on high water or requesting more data on low water.
         */
        if (this.dataQueue.length >= this.highWatermark) {
            await this.iterateAsyncErrored(async (l) => l.highWater?.());
        }
        if (this.isClosed || !this.hasDataReader()) {
            return;
        }
        if (this.dataQueue.length) {
            const data = this.dataQueue.shift();
            const mapped = this.mapLine(data);
            await this.iterateAsyncErrored(async (l) => l.data?.(mapped));
        }
        if (this.dataQueue.length <= this.lowWatermark) {
            const dataAdded = new Promise((resolve) => {
                this.notifyDataAdded = resolve;
            });
            await Promise.race([this.iterateAsyncErrored(async (l) => l.lowWater?.()), dataAdded]);
            this.notifyDataAdded = null;
        }
        if (this.dataQueue.length > 0) {
            // Next tick
            setTimeout(() => this.processQueue());
        }
    }
    async iterateAsyncErrored(cb) {
        // Important: We need to copy the listeners, as calling a listener could result in adding another
        // listener, resulting in infinite loops.
        const listeners = Array.from(this.listeners.values());
        for (let i of listeners) {
            try {
                await cb(i);
            }
            catch (ex) {
                this.logger.error(ex);
                this.iterateListeners((l) => l.error?.(ex));
            }
        }
    }
}

var WebsocketDuplexConnection = {};

var hasRequiredWebsocketDuplexConnection;

function requireWebsocketDuplexConnection () {
	if (hasRequiredWebsocketDuplexConnection) return WebsocketDuplexConnection;
	hasRequiredWebsocketDuplexConnection = 1;
	/*
	 * Copyright 2021-2022 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __extends = (WebsocketDuplexConnection && WebsocketDuplexConnection.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(WebsocketDuplexConnection, "__esModule", { value: true });
	WebsocketDuplexConnection.WebsocketDuplexConnection = void 0;
	var rsocket_core_1 = requireDist();
	var WebsocketDuplexConnection$1 = /** @class */ (function (_super) {
	    __extends(WebsocketDuplexConnection, _super);
	    function WebsocketDuplexConnection(websocket, deserializer, multiplexerDemultiplexerFactory) {
	        var _this = _super.call(this) || this;
	        _this.websocket = websocket;
	        _this.deserializer = deserializer;
	        _this.handleClosed = function (e) {
	            _this.close(new Error(e.reason || "WebsocketDuplexConnection: Socket closed unexpectedly."));
	        };
	        _this.handleError = function (e) {
	            _this.close(e.error);
	        };
	        _this.handleMessage = function (message) {
	            try {
	                var buffer = bufferExports.Buffer.from(message.data);
	                var frame = _this.deserializer.deserializeFrame(buffer);
	                _this.multiplexerDemultiplexer.handle(frame);
	            }
	            catch (error) {
	                _this.close(error);
	            }
	        };
	        websocket.addEventListener("close", _this.handleClosed);
	        websocket.addEventListener("error", _this.handleError);
	        websocket.addEventListener("message", _this.handleMessage);
	        _this.multiplexerDemultiplexer = multiplexerDemultiplexerFactory(_this);
	        return _this;
	    }
	    Object.defineProperty(WebsocketDuplexConnection.prototype, "availability", {
	        get: function () {
	            return this.done ? 0 : 1;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    WebsocketDuplexConnection.prototype.close = function (error) {
	        if (this.done) {
	            _super.prototype.close.call(this, error);
	            return;
	        }
	        this.websocket.removeEventListener("close", this.handleClosed);
	        this.websocket.removeEventListener("error", this.handleError);
	        this.websocket.removeEventListener("message", this.handleMessage);
	        this.websocket.close();
	        delete this.websocket;
	        _super.prototype.close.call(this, error);
	    };
	    WebsocketDuplexConnection.prototype.send = function (frame) {
	        if (this.done) {
	            return;
	        }
	        var buffer = (0, rsocket_core_1.serializeFrame)(frame);
	        this.websocket.send(buffer);
	    };
	    return WebsocketDuplexConnection;
	}(rsocket_core_1.Deferred));
	WebsocketDuplexConnection.WebsocketDuplexConnection = WebsocketDuplexConnection$1;
	
	return WebsocketDuplexConnection;
}

var WebsocketDuplexConnectionExports = requireWebsocketDuplexConnection();

/**
 * Adapted from rsocket-websocket-client
 * https://github.com/rsocket/rsocket-js/blob/e224cf379e747c4f1ddc4f2fa111854626cc8575/packages/rsocket-websocket-client/src/WebsocketClientTransport.ts#L17
 * This adds additional error handling for React Native iOS.
 * This particularly adds a close listener to handle cases where the WebSocket
 * connection closes immediately after opening without emitting an error.
 */
class WebsocketClientTransport {
    url;
    factory;
    constructor(options) {
        this.url = options.url;
        this.factory = options.wsCreator ?? ((url) => new WebSocket(url));
    }
    connect(multiplexerDemultiplexerFactory) {
        return new Promise((resolve, reject) => {
            const websocket = this.factory(this.url);
            websocket.binaryType = 'arraybuffer';
            let removeListeners;
            const openListener = () => {
                removeListeners();
                resolve(new WebsocketDuplexConnectionExports.WebsocketDuplexConnection(websocket, new distExports.Deserializer(), multiplexerDemultiplexerFactory));
            };
            const errorListener = (ev) => {
                removeListeners();
                // We add a default error in that case.
                if (ev.error != null) {
                    // undici typically provides an error object
                    reject(ev.error);
                }
                else if (ev.message != null) {
                    // React Native typically does not provide an error object, but does provide a message
                    reject(new Error(`Failed to create websocket connection: ${ev.message}`));
                }
                else {
                    // Browsers often provide no details at all
                    reject(new Error(`Failed to create websocket connection to ${this.url}`));
                }
            };
            /**
             * In some cases, such as React Native iOS, the WebSocket connection may close immediately after opening
             * without and error. In such cases, we need to handle the close event to reject the promise.
             */
            const closeListener = () => {
                removeListeners();
                reject(new Error('WebSocket connection closed while opening'));
            };
            removeListeners = () => {
                websocket.removeEventListener('open', openListener);
                websocket.removeEventListener('error', errorListener);
                websocket.removeEventListener('close', closeListener);
            };
            websocket.addEventListener('open', openListener);
            websocket.addEventListener('error', errorListener);
            websocket.addEventListener('close', closeListener);
        });
    }
}

const POWERSYNC_TRAILING_SLASH_MATCH = /\/+$/;
const POWERSYNC_JS_VERSION = PACKAGE.version;
const SYNC_QUEUE_REQUEST_LOW_WATER = 5;
// Keep alive message is sent every period
const KEEP_ALIVE_MS = 20_000;
// One message of any type must be received in this period.
const SOCKET_TIMEOUT_MS = 30_000;
// One keepalive message must be received in this period.
// If there is a backlog of messages (for example on slow connections), keepalive messages could be delayed
// significantly. Therefore this is longer than the socket timeout.
const KEEP_ALIVE_LIFETIME_MS = 90_000;
const DEFAULT_REMOTE_LOGGER = Logger.get('PowerSyncRemote');
var FetchStrategy;
(function (FetchStrategy) {
    /**
     * Queues multiple sync events before processing, reducing round-trips.
     * This comes at the cost of more processing overhead, which may cause ACK timeouts on older/weaker devices for big enough datasets.
     */
    FetchStrategy["Buffered"] = "buffered";
    /**
     * Processes each sync event immediately before requesting the next.
     * This reduces processing overhead and improves real-time responsiveness.
     */
    FetchStrategy["Sequential"] = "sequential";
})(FetchStrategy || (FetchStrategy = {}));
/**
 * Class wrapper for providing a fetch implementation.
 * The class wrapper is used to distinguish the fetchImplementation
 * option in [AbstractRemoteOptions] from the general fetch method
 * which is typeof "function"
 */
class FetchImplementationProvider {
    getFetch() {
        throw new Error('Unspecified fetch implementation');
    }
}
const DEFAULT_REMOTE_OPTIONS = {
    socketUrlTransformer: (url) => url.replace(/^https?:\/\//, function (match) {
        return match === 'https://' ? 'wss://' : 'ws://';
    }),
    fetchImplementation: new FetchImplementationProvider(),
    fetchOptions: {}
};
class AbstractRemote {
    connector;
    logger;
    credentials = null;
    options;
    constructor(connector, logger = DEFAULT_REMOTE_LOGGER, options) {
        this.connector = connector;
        this.logger = logger;
        this.options = {
            ...DEFAULT_REMOTE_OPTIONS,
            ...(options ?? {})
        };
    }
    /**
     * @returns a fetch implementation (function)
     * which can be called to perform fetch requests
     */
    get fetch() {
        const { fetchImplementation } = this.options;
        return fetchImplementation instanceof FetchImplementationProvider
            ? fetchImplementation.getFetch()
            : fetchImplementation;
    }
    /**
     * Get credentials currently cached, or fetch new credentials if none are
     * available.
     *
     * These credentials may have expired already.
     */
    async getCredentials() {
        if (this.credentials) {
            return this.credentials;
        }
        return this.prefetchCredentials();
    }
    /**
     * Fetch a new set of credentials and cache it.
     *
     * Until this call succeeds, `getCredentials` will still return the
     * old credentials.
     *
     * This may be called before the current credentials have expired.
     */
    async prefetchCredentials() {
        this.credentials = await this.fetchCredentials();
        return this.credentials;
    }
    /**
     * Get credentials for PowerSync.
     *
     * This should always fetch a fresh set of credentials - don't use cached
     * values.
     */
    async fetchCredentials() {
        const credentials = await this.connector.fetchCredentials();
        if (credentials?.endpoint.match(POWERSYNC_TRAILING_SLASH_MATCH)) {
            throw new Error(`A trailing forward slash "/" was found in the fetchCredentials endpoint: "${credentials.endpoint}". Remove the trailing forward slash "/" to fix this error.`);
        }
        return credentials;
    }
    /***
     * Immediately invalidate credentials.
     *
     * This may be called when the current credentials have expired.
     */
    invalidateCredentials() {
        this.credentials = null;
        this.connector.invalidateCredentials?.();
    }
    getUserAgent() {
        return `powersync-js/${POWERSYNC_JS_VERSION}`;
    }
    async buildRequest(path) {
        const credentials = await this.getCredentials();
        if (credentials != null && (credentials.endpoint == null || credentials.endpoint == '')) {
            throw new Error('PowerSync endpoint not configured');
        }
        else if (credentials?.token == null || credentials?.token == '') {
            const error = new Error(`Not signed in`);
            error.status = 401;
            throw error;
        }
        const userAgent = this.getUserAgent();
        return {
            url: credentials.endpoint + path,
            headers: {
                'content-type': 'application/json',
                Authorization: `Token ${credentials.token}`,
                'x-user-agent': userAgent
            }
        };
    }
    async post(path, data, headers = {}) {
        const request = await this.buildRequest(path);
        const res = await this.fetch(request.url, {
            method: 'POST',
            headers: {
                ...headers,
                ...request.headers
            },
            body: JSON.stringify(data)
        });
        if (res.status === 401) {
            this.invalidateCredentials();
        }
        if (!res.ok) {
            throw new Error(`Received ${res.status} - ${res.statusText} when posting to ${path}: ${await res.text()}}`);
        }
        return res.json();
    }
    async get(path, headers) {
        const request = await this.buildRequest(path);
        const res = await this.fetch(request.url, {
            method: 'GET',
            headers: {
                ...headers,
                ...request.headers
            }
        });
        if (res.status === 401) {
            this.invalidateCredentials();
        }
        if (!res.ok) {
            throw new Error(`Received ${res.status} - ${res.statusText} when getting from ${path}: ${await res.text()}}`);
        }
        return res.json();
    }
    /**
     * @returns A text decoder decoding UTF-8. This is a method to allow patching it for Hermes which doesn't support the
     * builtin, without forcing us to bundle a polyfill with `@powersync/common`.
     */
    createTextDecoder() {
        return new TextDecoder();
    }
    createSocket(url) {
        return new WebSocket(url);
    }
    /**
     * Returns a data stream of sync line data.
     *
     * @param map Maps received payload frames to the typed event value.
     * @param bson A BSON encoder and decoder. When set, the data stream will be requested with a BSON payload
     * (required for compatibility with older sync services).
     */
    async socketStreamRaw(options, map, bson) {
        const { path, fetchStrategy = FetchStrategy.Buffered } = options;
        const mimeType = bson == null ? 'application/json' : 'application/bson';
        function toBuffer(js) {
            let contents;
            if (bson != null) {
                contents = bson.serialize(js);
            }
            else {
                contents = JSON.stringify(js);
            }
            return bufferExports$1.Buffer.from(contents);
        }
        const syncQueueRequestSize = fetchStrategy == FetchStrategy.Buffered ? 10 : 1;
        const request = await this.buildRequest(path);
        // Add the user agent in the setup payload - we can't set custom
        // headers with websockets on web. The browser userAgent is however added
        // automatically as a header.
        const userAgent = this.getUserAgent();
        const stream = new DataStream({
            logger: this.logger,
            pressure: {
                lowWaterMark: SYNC_QUEUE_REQUEST_LOW_WATER
            },
            mapLine: map
        });
        // Handle upstream abort
        if (options.abortSignal?.aborted) {
            throw new AbortOperation('Connection request aborted');
        }
        else {
            options.abortSignal?.addEventListener('abort', () => {
                stream.close();
            }, { once: true });
        }
        let keepAliveTimeout;
        const resetTimeout = () => {
            clearTimeout(keepAliveTimeout);
            keepAliveTimeout = setTimeout(() => {
                this.logger.error(`No data received on WebSocket in ${SOCKET_TIMEOUT_MS}ms, closing connection.`);
                stream.close();
            }, SOCKET_TIMEOUT_MS);
        };
        resetTimeout();
        // Typescript complains about this being `never` if it's not assigned here.
        // This is assigned in `wsCreator`.
        let disposeSocketConnectionTimeout = () => { };
        const url = this.options.socketUrlTransformer(request.url);
        const connector = new distExports.RSocketConnector({
            transport: new WebsocketClientTransport({
                url,
                wsCreator: (url) => {
                    const socket = this.createSocket(url);
                    disposeSocketConnectionTimeout = stream.registerListener({
                        closed: () => {
                            // Allow closing the underlying WebSocket if the stream was closed before the
                            // RSocket connect completed. This should effectively abort the request.
                            socket.close();
                        }
                    });
                    socket.addEventListener('message', (event) => {
                        resetTimeout();
                    });
                    return socket;
                }
            }),
            setup: {
                keepAlive: KEEP_ALIVE_MS,
                lifetime: KEEP_ALIVE_LIFETIME_MS,
                dataMimeType: mimeType,
                metadataMimeType: mimeType,
                payload: {
                    data: null,
                    metadata: toBuffer({
                        token: request.headers.Authorization,
                        user_agent: userAgent
                    })
                }
            }
        });
        let rsocket;
        try {
            rsocket = await connector.connect();
            // The connection is established, we no longer need to monitor the initial timeout
            disposeSocketConnectionTimeout();
        }
        catch (ex) {
            this.logger.error(`Failed to connect WebSocket`, ex);
            clearTimeout(keepAliveTimeout);
            if (!stream.closed) {
                await stream.close();
            }
            throw ex;
        }
        resetTimeout();
        let socketIsClosed = false;
        const closeSocket = () => {
            clearTimeout(keepAliveTimeout);
            if (socketIsClosed) {
                return;
            }
            socketIsClosed = true;
            rsocket.close();
        };
        // Helps to prevent double close scenarios
        rsocket.onClose(() => (socketIsClosed = true));
        // We initially request this amount and expect these to arrive eventually
        let pendingEventsCount = syncQueueRequestSize;
        const disposeClosedListener = stream.registerListener({
            closed: () => {
                closeSocket();
                disposeClosedListener();
            }
        });
        const socket = await new Promise((resolve, reject) => {
            let connectionEstablished = false;
            const res = rsocket.requestStream({
                data: toBuffer(options.data),
                metadata: toBuffer({
                    path
                })
            }, syncQueueRequestSize, // The initial N amount
            {
                onError: (e) => {
                    if (e.message.includes('PSYNC_')) {
                        if (e.message.includes('PSYNC_S21')) {
                            this.invalidateCredentials();
                        }
                    }
                    else {
                        // Possible that connection is with an older service, always invalidate to be safe
                        if (e.message !== 'Closed. ') {
                            this.invalidateCredentials();
                        }
                    }
                    // Don't log closed as an error
                    if (e.message !== 'Closed. ') {
                        this.logger.error(e);
                    }
                    // RSocket will close the RSocket stream automatically
                    // Close the downstream stream as well - this will close the RSocket connection and WebSocket
                    stream.close();
                    // Handles cases where the connection failed e.g. auth error or connection error
                    if (!connectionEstablished) {
                        reject(e);
                    }
                },
                onNext: (payload) => {
                    // The connection is active
                    if (!connectionEstablished) {
                        connectionEstablished = true;
                        resolve(res);
                    }
                    const { data } = payload;
                    // Less events are now pending
                    pendingEventsCount--;
                    if (!data) {
                        return;
                    }
                    stream.enqueueData(data);
                },
                onComplete: () => {
                    stream.close();
                },
                onExtension: () => { }
            });
        });
        const l = stream.registerListener({
            lowWater: async () => {
                // Request to fill up the queue
                const required = syncQueueRequestSize - pendingEventsCount;
                if (required > 0) {
                    socket.request(syncQueueRequestSize - pendingEventsCount);
                    pendingEventsCount = syncQueueRequestSize;
                }
            },
            closed: () => {
                l();
            }
        });
        return stream;
    }
    /**
     * Connects to the sync/stream http endpoint, mapping and emitting each received string line.
     */
    async postStreamRaw(options, mapLine) {
        const { data, path, headers, abortSignal } = options;
        const request = await this.buildRequest(path);
        /**
         * This abort controller will abort pending fetch requests.
         * If the request has resolved, it will be used to close the readable stream.
         * Which will cancel the network request.
         *
         * This nested controller is required since:
         *  Aborting the active fetch request while it is being consumed seems to throw
         *  an unhandled exception on the window level.
         */
        if (abortSignal?.aborted) {
            throw new AbortOperation('Abort request received before making postStreamRaw request');
        }
        const controller = new AbortController();
        let requestResolved = false;
        abortSignal?.addEventListener('abort', () => {
            if (!requestResolved) {
                // Only abort via the abort controller if the request has not resolved yet
                controller.abort(abortSignal.reason ??
                    new AbortOperation('Cancelling network request before it resolves. Abort signal has been received.'));
            }
        });
        const res = await this.fetch(request.url, {
            method: 'POST',
            headers: { ...headers, ...request.headers },
            body: JSON.stringify(data),
            signal: controller.signal,
            cache: 'no-store',
            ...(this.options.fetchOptions ?? {}),
            ...options.fetchOptions
        }).catch((ex) => {
            if (ex.name == 'AbortError') {
                throw new AbortOperation(`Pending fetch request to ${request.url} has been aborted.`);
            }
            throw ex;
        });
        if (!res) {
            throw new Error('Fetch request was aborted');
        }
        requestResolved = true;
        if (!res.ok || !res.body) {
            const text = await res.text();
            this.logger.error(`Could not POST streaming to ${path} - ${res.status} - ${res.statusText}: ${text}`);
            const error = new Error(`HTTP ${res.statusText}: ${text}`);
            error.status = res.status;
            throw error;
        }
        // Create a new stream splitting the response at line endings while also handling cancellations
        // by closing the reader.
        const reader = res.body.getReader();
        let readerReleased = false;
        // This will close the network request and read stream
        const closeReader = async () => {
            try {
                readerReleased = true;
                await reader.cancel();
            }
            catch (ex) {
                // an error will throw if the reader hasn't been used yet
            }
            reader.releaseLock();
        };
        const stream = new DataStream({
            logger: this.logger,
            mapLine: mapLine
        });
        abortSignal?.addEventListener('abort', () => {
            closeReader();
            stream.close();
        });
        const decoder = this.createTextDecoder();
        let buffer = '';
        const l = stream.registerListener({
            lowWater: async () => {
                if (stream.closed || abortSignal?.aborted || readerReleased) {
                    return;
                }
                try {
                    let didCompleteLine = false;
                    while (!didCompleteLine) {
                        const { done, value } = await reader.read();
                        if (done) {
                            const remaining = buffer.trim();
                            if (remaining.length != 0) {
                                stream.enqueueData(remaining);
                            }
                            stream.close();
                            await closeReader();
                            return;
                        }
                        const data = decoder.decode(value, { stream: true });
                        buffer += data;
                        const lines = buffer.split('\n');
                        for (var i = 0; i < lines.length - 1; i++) {
                            var l = lines[i].trim();
                            if (l.length > 0) {
                                stream.enqueueData(l);
                                didCompleteLine = true;
                            }
                        }
                        buffer = lines[lines.length - 1];
                    }
                }
                catch (ex) {
                    stream.close();
                    throw ex;
                }
            },
            closed: () => {
                closeReader();
                l?.();
            }
        });
        return stream;
    }
}

function priorityToJs(status) {
    return {
        priority: status.priority,
        hasSynced: status.has_synced ?? undefined,
        lastSyncedAt: status.last_synced_at != null ? new Date(status.last_synced_at * 1000) : undefined
    };
}
function coreStatusToJs(status) {
    const coreCompleteSync = status.priority_status.find((s) => s.priority == FULL_SYNC_PRIORITY);
    const completeSync = coreCompleteSync != null ? priorityToJs(coreCompleteSync) : null;
    return {
        connected: status.connected,
        connecting: status.connecting,
        dataFlow: {
            // We expose downloading as a boolean field, the core extension reports download information as a nullable
            // download status. When that status is non-null, a download is in progress.
            downloading: status.downloading != null,
            downloadProgress: status.downloading?.buckets,
            internalStreamSubscriptions: status.streams
        },
        lastSyncedAt: completeSync?.lastSyncedAt,
        hasSynced: completeSync?.hasSynced,
        priorityStatusEntries: status.priority_status.map(priorityToJs)
    };
}

function isStreamingSyncData(line) {
    return line.data != null;
}
function isStreamingKeepalive(line) {
    return line.token_expires_in != null;
}
function isStreamingSyncCheckpoint(line) {
    return line.checkpoint != null;
}
function isStreamingSyncCheckpointComplete(line) {
    return line.checkpoint_complete != null;
}
function isStreamingSyncCheckpointPartiallyComplete(line) {
    return line.partial_checkpoint_complete != null;
}
function isStreamingSyncCheckpointDiff(line) {
    return line.checkpoint_diff != null;
}
function isContinueCheckpointRequest(request) {
    return (Array.isArray(request.buckets) &&
        typeof request.checkpoint_token == 'string');
}
function isSyncNewCheckpointRequest(request) {
    return typeof request.request_checkpoint == 'object';
}

var LockType;
(function (LockType) {
    LockType["CRUD"] = "crud";
    LockType["SYNC"] = "sync";
})(LockType || (LockType = {}));
var SyncStreamConnectionMethod;
(function (SyncStreamConnectionMethod) {
    SyncStreamConnectionMethod["HTTP"] = "http";
    SyncStreamConnectionMethod["WEB_SOCKET"] = "web-socket";
})(SyncStreamConnectionMethod || (SyncStreamConnectionMethod = {}));
var SyncClientImplementation;
(function (SyncClientImplementation) {
    /**
     * Decodes and handles sync lines received from the sync service in JavaScript.
     *
     * This is the default option.
     *
     * @deprecated Don't use {@link SyncClientImplementation.JAVASCRIPT} directly. Instead, use
     * {@link DEFAULT_SYNC_CLIENT_IMPLEMENTATION} or omit the option. The explicit choice to use
     * the JavaScript-based sync implementation will be removed from a future version of the SDK.
     */
    SyncClientImplementation["JAVASCRIPT"] = "js";
    /**
     * This implementation offloads the sync line decoding and handling into the PowerSync
     * core extension.
     *
     * @experimental
     * While this implementation is more performant than {@link SyncClientImplementation.JAVASCRIPT},
     * it has seen less real-world testing and is marked as __experimental__ at the moment.
     *
     * ## Compatibility warning
     *
     * The Rust sync client stores sync data in a format that is slightly different than the one used
     * by the old {@link JAVASCRIPT} implementation. When adopting the {@link RUST} client on existing
     * databases, the PowerSync SDK will migrate the format automatically.
     * Further, the {@link JAVASCRIPT} client in recent versions of the PowerSync JS SDK (starting from
     * the version introducing {@link RUST} as an option) also supports the new format, so you can switch
     * back to {@link JAVASCRIPT} later.
     *
     * __However__: Upgrading the SDK version, then adopting {@link RUST} as a sync client and later
     * downgrading the SDK to an older version (necessarily using the JavaScript-based implementation then)
     * can lead to sync issues.
     */
    SyncClientImplementation["RUST"] = "rust";
})(SyncClientImplementation || (SyncClientImplementation = {}));
/**
 * The default {@link SyncClientImplementation} to use.
 *
 * Please use this field instead of {@link SyncClientImplementation.JAVASCRIPT} directly. A future version
 * of the PowerSync SDK will enable {@link SyncClientImplementation.RUST} by default and remove the JavaScript
 * option.
 */
const DEFAULT_SYNC_CLIENT_IMPLEMENTATION = SyncClientImplementation.JAVASCRIPT;
const DEFAULT_CRUD_UPLOAD_THROTTLE_MS = 1000;
const DEFAULT_RETRY_DELAY_MS = 5000;
const DEFAULT_STREAMING_SYNC_OPTIONS = {
    retryDelayMs: DEFAULT_RETRY_DELAY_MS,
    crudUploadThrottleMs: DEFAULT_CRUD_UPLOAD_THROTTLE_MS
};
const DEFAULT_STREAM_CONNECTION_OPTIONS = {
    connectionMethod: SyncStreamConnectionMethod.WEB_SOCKET,
    clientImplementation: DEFAULT_SYNC_CLIENT_IMPLEMENTATION,
    fetchStrategy: FetchStrategy.Buffered,
    params: {},
    serializedSchema: undefined,
    includeDefaultStreams: true
};
// The priority we assume when we receive checkpoint lines where no priority is set.
// This is the default priority used by the sync service, but can be set to an arbitrary
// value since sync services without priorities also won't send partial sync completion
// messages.
const FALLBACK_PRIORITY = 3;
class AbstractStreamingSyncImplementation extends BaseObserver {
    _lastSyncedAt;
    options;
    abortController;
    // In rare cases, mostly for tests, uploads can be triggered without being properly connected.
    // This allows ensuring that all upload processes can be aborted.
    uploadAbortController;
    crudUpdateListener;
    streamingSyncPromise;
    logger;
    activeStreams;
    isUploadingCrud = false;
    notifyCompletedUploads;
    handleActiveStreamsChange;
    syncStatus;
    triggerCrudUpload;
    constructor(options) {
        super();
        this.options = options;
        this.activeStreams = options.subscriptions;
        this.logger = options.logger ?? Logger.get('PowerSyncStream');
        this.syncStatus = new SyncStatus({
            connected: false,
            connecting: false,
            lastSyncedAt: undefined,
            dataFlow: {
                uploading: false,
                downloading: false
            }
        });
        this.abortController = null;
        this.triggerCrudUpload = throttleLeadingTrailing(() => {
            if (!this.syncStatus.connected || this.isUploadingCrud) {
                return;
            }
            this.isUploadingCrud = true;
            this._uploadAllCrud().finally(() => {
                this.notifyCompletedUploads?.();
                this.isUploadingCrud = false;
            });
        }, this.options.crudUploadThrottleMs);
    }
    async waitForReady() { }
    waitForStatus(status) {
        return this.waitUntilStatusMatches((currentStatus) => {
            /**
             * Match only the partial status options provided in the
             * matching status
             */
            const matchPartialObject = (compA, compB) => {
                return Object.entries(compA).every(([key, value]) => {
                    const comparisonBValue = compB[key];
                    if (typeof value == 'object' && typeof comparisonBValue == 'object') {
                        return matchPartialObject(value, comparisonBValue);
                    }
                    return value == comparisonBValue;
                });
            };
            return matchPartialObject(status, currentStatus);
        });
    }
    waitUntilStatusMatches(predicate) {
        return new Promise((resolve) => {
            if (predicate(this.syncStatus)) {
                resolve();
                return;
            }
            const l = this.registerListener({
                statusChanged: (updatedStatus) => {
                    if (predicate(updatedStatus)) {
                        resolve();
                        l?.();
                    }
                }
            });
        });
    }
    get lastSyncedAt() {
        const lastSynced = this.syncStatus.lastSyncedAt;
        return lastSynced && new Date(lastSynced);
    }
    get isConnected() {
        return this.syncStatus.connected;
    }
    async dispose() {
        super.dispose();
        this.crudUpdateListener?.();
        this.crudUpdateListener = undefined;
        this.uploadAbortController?.abort();
    }
    async hasCompletedSync() {
        return this.options.adapter.hasCompletedSync();
    }
    async getWriteCheckpoint() {
        const clientId = await this.options.adapter.getClientId();
        let path = `/write-checkpoint2.json?client_id=${clientId}`;
        const response = await this.options.remote.get(path);
        const checkpoint = response['data']['write_checkpoint'];
        this.logger.debug(`Created write checkpoint: ${checkpoint}`);
        return checkpoint;
    }
    async _uploadAllCrud() {
        return this.obtainLock({
            type: LockType.CRUD,
            callback: async () => {
                /**
                 * Keep track of the first item in the CRUD queue for the last `uploadCrud` iteration.
                 */
                let checkedCrudItem;
                const controller = new AbortController();
                this.uploadAbortController = controller;
                this.abortController?.signal.addEventListener('abort', () => {
                    controller.abort();
                }, { once: true });
                while (!controller.signal.aborted) {
                    try {
                        /**
                         * This is the first item in the FIFO CRUD queue.
                         */
                        const nextCrudItem = await this.options.adapter.nextCrudItem();
                        if (nextCrudItem) {
                            this.updateSyncStatus({
                                dataFlow: {
                                    uploading: true
                                }
                            });
                            if (nextCrudItem.clientId == checkedCrudItem?.clientId) {
                                // This will force a higher log level than exceptions which are caught here.
                                this.logger.warn(`Potentially previously uploaded CRUD entries are still present in the upload queue.
Make sure to handle uploads and complete CRUD transactions or batches by calling and awaiting their [.complete()] method.
The next upload iteration will be delayed.`);
                                throw new Error('Delaying due to previously encountered CRUD item.');
                            }
                            checkedCrudItem = nextCrudItem;
                            await this.options.uploadCrud();
                            this.updateSyncStatus({
                                dataFlow: {
                                    uploadError: undefined
                                }
                            });
                        }
                        else {
                            // Uploading is completed
                            const neededUpdate = await this.options.adapter.updateLocalTarget(() => this.getWriteCheckpoint());
                            if (neededUpdate == false && checkedCrudItem != null) {
                                // Only log this if there was something to upload
                                this.logger.debug('Upload complete, no write checkpoint needed.');
                            }
                            break;
                        }
                    }
                    catch (ex) {
                        checkedCrudItem = undefined;
                        this.updateSyncStatus({
                            dataFlow: {
                                uploading: false,
                                uploadError: ex
                            }
                        });
                        await this.delayRetry(controller.signal);
                        if (!this.isConnected) {
                            // Exit the upload loop if the sync stream is no longer connected
                            break;
                        }
                        this.logger.debug(`Caught exception when uploading. Upload will retry after a delay. Exception: ${ex.message}`);
                    }
                    finally {
                        this.updateSyncStatus({
                            dataFlow: {
                                uploading: false
                            }
                        });
                    }
                }
                this.uploadAbortController = null;
            }
        });
    }
    async connect(options) {
        if (this.abortController) {
            await this.disconnect();
        }
        const controller = new AbortController();
        this.abortController = controller;
        this.streamingSyncPromise = this.streamingSync(this.abortController.signal, options);
        // Return a promise that resolves when the connection status is updated to indicate that we're connected.
        return new Promise((resolve) => {
            const disposer = this.registerListener({
                statusChanged: (status) => {
                    if (status.dataFlowStatus.downloadError != null) {
                        this.logger.warn('Initial connect attempt did not successfully connect to server');
                    }
                    else if (status.connecting) {
                        // Still connecting.
                        return;
                    }
                    disposer();
                    resolve();
                }
            });
        });
    }
    async disconnect() {
        if (!this.abortController) {
            return;
        }
        // This might be called multiple times
        if (!this.abortController.signal.aborted) {
            this.abortController.abort(new AbortOperation('Disconnect has been requested'));
        }
        // Await any pending operations before completing the disconnect operation
        try {
            await this.streamingSyncPromise;
        }
        catch (ex) {
            // The operation might have failed, all we care about is if it has completed
            this.logger.warn(ex);
        }
        this.streamingSyncPromise = undefined;
        this.abortController = null;
        this.updateSyncStatus({ connected: false, connecting: false });
    }
    /**
     * @deprecated use [connect instead]
     */
    async streamingSync(signal, options) {
        if (!signal) {
            this.abortController = new AbortController();
            signal = this.abortController.signal;
        }
        /**
         * Listen for CRUD updates and trigger upstream uploads
         */
        this.crudUpdateListener = this.options.adapter.registerListener({
            crudUpdate: () => this.triggerCrudUpload()
        });
        /**
         * Create a new abort controller which aborts items downstream.
         * This is needed to close any previous connections on exception.
         */
        let nestedAbortController = new AbortController();
        signal.addEventListener('abort', () => {
            /**
             * A request for disconnect was received upstream. Relay the request
             * to the nested abort controller.
             */
            nestedAbortController.abort(signal?.reason ?? new AbortOperation('Received command to disconnect from upstream'));
            this.crudUpdateListener?.();
            this.crudUpdateListener = undefined;
            this.updateSyncStatus({
                connected: false,
                connecting: false,
                dataFlow: {
                    downloading: false,
                    downloadProgress: null
                }
            });
        });
        /**
         * This loops runs until [retry] is false or the abort signal is set to aborted.
         * Aborting the nestedAbortController will:
         *  - Abort any pending fetch requests
         *  - Close any sync stream ReadableStreams (which will also close any established network requests)
         */
        while (true) {
            this.updateSyncStatus({ connecting: true });
            let shouldDelayRetry = true;
            let result = null;
            try {
                if (signal?.aborted) {
                    break;
                }
                result = await this.streamingSyncIteration(nestedAbortController.signal, options);
                // Continue immediately, streamingSyncIteration will wait before completing if necessary.
            }
            catch (ex) {
                /**
                 * Either:
                 *  - A network request failed with a failed connection or not OKAY response code.
                 *  - There was a sync processing error.
                 *  - The connection was aborted.
                 * This loop will retry after a delay if the connection was not aborted.
                 * The nested abort controller will cleanup any open network requests and streams.
                 * The WebRemote should only abort pending fetch requests or close active Readable streams.
                 */
                if (ex instanceof AbortOperation) {
                    this.logger.warn(ex);
                    shouldDelayRetry = false;
                    // A disconnect was requested, we should not delay since there is no explicit retry
                }
                else {
                    this.logger.error(ex);
                }
                this.updateSyncStatus({
                    dataFlow: {
                        downloadError: ex
                    }
                });
            }
            finally {
                this.notifyCompletedUploads = undefined;
                if (!signal.aborted) {
                    nestedAbortController.abort(new AbortOperation('Closing sync stream network requests before retry.'));
                    nestedAbortController = new AbortController();
                }
                if (result?.immediateRestart != true) {
                    this.updateSyncStatus({
                        connected: false,
                        connecting: true // May be unnecessary
                    });
                    // On error, wait a little before retrying
                    if (shouldDelayRetry) {
                        await this.delayRetry(nestedAbortController.signal);
                    }
                }
            }
        }
        // Mark as disconnected if here
        this.updateSyncStatus({ connected: false, connecting: false });
    }
    async collectLocalBucketState() {
        const bucketEntries = await this.options.adapter.getBucketStates();
        const req = bucketEntries.map((entry) => ({
            name: entry.bucket,
            after: entry.op_id
        }));
        const localDescriptions = new Map();
        for (const entry of bucketEntries) {
            localDescriptions.set(entry.bucket, null);
        }
        return [req, localDescriptions];
    }
    /**
     * Older versions of the JS SDK used to encode subkeys as JSON in {@link OplogEntry.toJSON}.
     * Because subkeys are always strings, this leads to quotes being added around them in `ps_oplog`.
     * While this is not a problem as long as it's done consistently, it causes issues when a database
     * created by the JS SDK is used with other SDKs, or (more likely) when the new Rust sync client
     * is enabled.
     *
     * So, we add a migration from the old key format (with quotes) to the new one (no quotes). The
     * migration is only triggered when necessary (for now). The function returns whether the new format
     * should be used, so that the JS SDK is able to write to updated databases.
     *
     * @param requireFixedKeyFormat Whether we require the new format or also support the old one.
     *        The Rust client requires the new subkey format.
     * @returns Whether the database is now using the new, fixed subkey format.
     */
    async requireKeyFormat(requireFixedKeyFormat) {
        const hasMigrated = await this.options.adapter.hasMigratedSubkeys();
        if (requireFixedKeyFormat && !hasMigrated) {
            await this.options.adapter.migrateToFixedSubkeys();
            return true;
        }
        else {
            return hasMigrated;
        }
    }
    streamingSyncIteration(signal, options) {
        return this.obtainLock({
            type: LockType.SYNC,
            signal,
            callback: async () => {
                const resolvedOptions = {
                    ...DEFAULT_STREAM_CONNECTION_OPTIONS,
                    ...(options ?? {})
                };
                const clientImplementation = resolvedOptions.clientImplementation;
                this.updateSyncStatus({ clientImplementation });
                if (clientImplementation == SyncClientImplementation.JAVASCRIPT) {
                    await this.legacyStreamingSyncIteration(signal, resolvedOptions);
                    return null;
                }
                else {
                    await this.requireKeyFormat(true);
                    return await this.rustSyncIteration(signal, resolvedOptions);
                }
            }
        });
    }
    async legacyStreamingSyncIteration(signal, resolvedOptions) {
        const rawTables = resolvedOptions.serializedSchema?.raw_tables;
        if (rawTables != null && rawTables.length) {
            this.logger.warn('Raw tables require the Rust-based sync client. The JS client will ignore them.');
        }
        this.logger.debug('Streaming sync iteration started');
        this.options.adapter.startSession();
        let [req, bucketMap] = await this.collectLocalBucketState();
        let targetCheckpoint = null;
        // A checkpoint that has been validated but not applied (e.g. due to pending local writes)
        let pendingValidatedCheckpoint = null;
        const clientId = await this.options.adapter.getClientId();
        const usingFixedKeyFormat = await this.requireKeyFormat(false);
        this.logger.debug('Requesting stream from server');
        const syncOptions = {
            path: '/sync/stream',
            abortSignal: signal,
            data: {
                buckets: req,
                include_checksum: true,
                raw_data: true,
                parameters: resolvedOptions.params,
                client_id: clientId
            }
        };
        let stream;
        if (resolvedOptions?.connectionMethod == SyncStreamConnectionMethod.HTTP) {
            stream = await this.options.remote.postStreamRaw(syncOptions, (line) => {
                if (typeof line == 'string') {
                    return JSON.parse(line);
                }
                else {
                    // Directly enqueued by us
                    return line;
                }
            });
        }
        else {
            const bson = await this.options.remote.getBSON();
            stream = await this.options.remote.socketStreamRaw({
                ...syncOptions,
                ...{ fetchStrategy: resolvedOptions.fetchStrategy }
            }, (payload) => {
                if (payload instanceof Uint8Array) {
                    return bson.deserialize(payload);
                }
                else {
                    // Directly enqueued by us
                    return payload;
                }
            }, bson);
        }
        this.logger.debug('Stream established. Processing events');
        this.notifyCompletedUploads = () => {
            if (!stream.closed) {
                stream.enqueueData({ crud_upload_completed: null });
            }
        };
        while (!stream.closed) {
            const line = await stream.read();
            if (!line) {
                // The stream has closed while waiting
                return;
            }
            if ('crud_upload_completed' in line) {
                if (pendingValidatedCheckpoint != null) {
                    const { applied, endIteration } = await this.applyCheckpoint(pendingValidatedCheckpoint);
                    if (applied) {
                        pendingValidatedCheckpoint = null;
                    }
                    else if (endIteration) {
                        break;
                    }
                }
                continue;
            }
            // A connection is active and messages are being received
            if (!this.syncStatus.connected) {
                // There is a connection now
                Promise.resolve().then(() => this.triggerCrudUpload());
                this.updateSyncStatus({
                    connected: true
                });
            }
            if (isStreamingSyncCheckpoint(line)) {
                targetCheckpoint = line.checkpoint;
                // New checkpoint - existing validated checkpoint is no longer valid
                pendingValidatedCheckpoint = null;
                const bucketsToDelete = new Set(bucketMap.keys());
                const newBuckets = new Map();
                for (const checksum of line.checkpoint.buckets) {
                    newBuckets.set(checksum.bucket, {
                        name: checksum.bucket,
                        priority: checksum.priority ?? FALLBACK_PRIORITY
                    });
                    bucketsToDelete.delete(checksum.bucket);
                }
                if (bucketsToDelete.size > 0) {
                    this.logger.debug('Removing buckets', [...bucketsToDelete]);
                }
                bucketMap = newBuckets;
                await this.options.adapter.removeBuckets([...bucketsToDelete]);
                await this.options.adapter.setTargetCheckpoint(targetCheckpoint);
                await this.updateSyncStatusForStartingCheckpoint(targetCheckpoint);
            }
            else if (isStreamingSyncCheckpointComplete(line)) {
                const result = await this.applyCheckpoint(targetCheckpoint);
                if (result.endIteration) {
                    return;
                }
                else if (!result.applied) {
                    // "Could not apply checkpoint due to local data". We need to retry after
                    // finishing uploads.
                    pendingValidatedCheckpoint = targetCheckpoint;
                }
                else {
                    // Nothing to retry later. This would likely already be null from the last
                    // checksum or checksum_diff operation, but we make sure.
                    pendingValidatedCheckpoint = null;
                }
            }
            else if (isStreamingSyncCheckpointPartiallyComplete(line)) {
                const priority = line.partial_checkpoint_complete.priority;
                this.logger.debug('Partial checkpoint complete', priority);
                const result = await this.options.adapter.syncLocalDatabase(targetCheckpoint, priority);
                if (!result.checkpointValid) {
                    // This means checksums failed. Start again with a new checkpoint.
                    // TODO: better back-off
                    await new Promise((resolve) => setTimeout(resolve, 50));
                    return;
                }
                else if (!result.ready) ;
                else {
                    // We'll keep on downloading, but can report that this priority is synced now.
                    this.logger.debug('partial checkpoint validation succeeded');
                    // All states with a higher priority can be deleted since this partial sync includes them.
                    const priorityStates = this.syncStatus.priorityStatusEntries.filter((s) => s.priority <= priority);
                    priorityStates.push({
                        priority,
                        lastSyncedAt: new Date(),
                        hasSynced: true
                    });
                    this.updateSyncStatus({
                        connected: true,
                        priorityStatusEntries: priorityStates
                    });
                }
            }
            else if (isStreamingSyncCheckpointDiff(line)) {
                // TODO: It may be faster to just keep track of the diff, instead of the entire checkpoint
                if (targetCheckpoint == null) {
                    throw new Error('Checkpoint diff without previous checkpoint');
                }
                // New checkpoint - existing validated checkpoint is no longer valid
                pendingValidatedCheckpoint = null;
                const diff = line.checkpoint_diff;
                const newBuckets = new Map();
                for (const checksum of targetCheckpoint.buckets) {
                    newBuckets.set(checksum.bucket, checksum);
                }
                for (const checksum of diff.updated_buckets) {
                    newBuckets.set(checksum.bucket, checksum);
                }
                for (const bucket of diff.removed_buckets) {
                    newBuckets.delete(bucket);
                }
                const newCheckpoint = {
                    last_op_id: diff.last_op_id,
                    buckets: [...newBuckets.values()],
                    write_checkpoint: diff.write_checkpoint
                };
                targetCheckpoint = newCheckpoint;
                await this.updateSyncStatusForStartingCheckpoint(targetCheckpoint);
                bucketMap = new Map();
                newBuckets.forEach((checksum, name) => bucketMap.set(name, {
                    name: checksum.bucket,
                    priority: checksum.priority ?? FALLBACK_PRIORITY
                }));
                const bucketsToDelete = diff.removed_buckets;
                if (bucketsToDelete.length > 0) {
                    this.logger.debug('Remove buckets', bucketsToDelete);
                }
                await this.options.adapter.removeBuckets(bucketsToDelete);
                await this.options.adapter.setTargetCheckpoint(targetCheckpoint);
            }
            else if (isStreamingSyncData(line)) {
                const { data } = line;
                const previousProgress = this.syncStatus.dataFlowStatus.downloadProgress;
                let updatedProgress = null;
                if (previousProgress) {
                    updatedProgress = { ...previousProgress };
                    const progressForBucket = updatedProgress[data.bucket];
                    if (progressForBucket) {
                        updatedProgress[data.bucket] = {
                            ...progressForBucket,
                            since_last: progressForBucket.since_last + data.data.length
                        };
                    }
                }
                this.updateSyncStatus({
                    dataFlow: {
                        downloading: true,
                        downloadProgress: updatedProgress
                    }
                });
                await this.options.adapter.saveSyncData({ buckets: [SyncDataBucket.fromRow(data)] }, usingFixedKeyFormat);
            }
            else if (isStreamingKeepalive(line)) {
                const remaining_seconds = line.token_expires_in;
                if (remaining_seconds == 0) {
                    // Connection would be closed automatically right after this
                    this.logger.debug('Token expiring; reconnect');
                    /**
                     * For a rare case where the backend connector does not update the token
                     * (uses the same one), this should have some delay.
                     */
                    await this.delayRetry();
                    return;
                }
                else if (remaining_seconds < 30) {
                    this.logger.debug('Token will expire soon; reconnect');
                    // Pre-emptively refresh the token
                    this.options.remote.invalidateCredentials();
                    return;
                }
                this.triggerCrudUpload();
            }
            else {
                this.logger.debug('Received unknown sync line', line);
            }
        }
        this.logger.debug('Stream input empty');
        // Connection closed. Likely due to auth issue.
        return;
    }
    async rustSyncIteration(signal, resolvedOptions) {
        const syncImplementation = this;
        const adapter = this.options.adapter;
        const remote = this.options.remote;
        let receivingLines = null;
        let hadSyncLine = false;
        let hideDisconnectOnRestart = false;
        if (signal.aborted) {
            throw new AbortOperation('Connection request has been aborted');
        }
        const abortController = new AbortController();
        signal.addEventListener('abort', () => abortController.abort());
        // Pending sync lines received from the service, as well as local events that trigger a powersync_control
        // invocation (local events include refreshed tokens and completed uploads).
        // This is a single data stream so that we can handle all control calls from a single place.
        let controlInvocations = null;
        async function connect(instr) {
            const syncOptions = {
                path: '/sync/stream',
                abortSignal: abortController.signal,
                data: instr.request
            };
            if (resolvedOptions.connectionMethod == SyncStreamConnectionMethod.HTTP) {
                controlInvocations = await remote.postStreamRaw(syncOptions, (line) => {
                    if (typeof line == 'string') {
                        return {
                            command: PowerSyncControlCommand.PROCESS_TEXT_LINE,
                            payload: line
                        };
                    }
                    else {
                        // Directly enqueued by us
                        return line;
                    }
                });
            }
            else {
                controlInvocations = await remote.socketStreamRaw({
                    ...syncOptions,
                    fetchStrategy: resolvedOptions.fetchStrategy
                }, (payload) => {
                    if (payload instanceof Uint8Array) {
                        return {
                            command: PowerSyncControlCommand.PROCESS_BSON_LINE,
                            payload: payload
                        };
                    }
                    else {
                        // Directly enqueued by us
                        return payload;
                    }
                });
            }
            // The rust client will set connected: true after the first sync line because that's when it gets invoked, but
            // we're already connected here and can report that.
            syncImplementation.updateSyncStatus({ connected: true });
            try {
                while (!controlInvocations.closed) {
                    const line = await controlInvocations.read();
                    if (line == null) {
                        return;
                    }
                    await control(line.command, line.payload);
                    if (!hadSyncLine) {
                        syncImplementation.triggerCrudUpload();
                        hadSyncLine = true;
                    }
                }
            }
            finally {
                const activeInstructions = controlInvocations;
                // We concurrently add events to the active data stream when e.g. a CRUD upload is completed or a token is
                // refreshed. That would throw after closing (and we can't handle those events either way), so set this back
                // to null.
                controlInvocations = null;
                await activeInstructions.close();
            }
        }
        async function stop() {
            await control(PowerSyncControlCommand.STOP);
        }
        async function control(op, payload) {
            const rawResponse = await adapter.control(op, payload ?? null);
            const logger = syncImplementation.logger;
            logger.trace('powersync_control', op, payload == null || typeof payload == 'string' ? payload : '<bytes>', rawResponse);
            await handleInstructions(JSON.parse(rawResponse));
        }
        async function handleInstruction(instruction) {
            if ('LogLine' in instruction) {
                switch (instruction.LogLine.severity) {
                    case 'DEBUG':
                        syncImplementation.logger.debug(instruction.LogLine.line);
                        break;
                    case 'INFO':
                        syncImplementation.logger.info(instruction.LogLine.line);
                        break;
                    case 'WARNING':
                        syncImplementation.logger.warn(instruction.LogLine.line);
                        break;
                }
            }
            else if ('UpdateSyncStatus' in instruction) {
                syncImplementation.updateSyncStatus(coreStatusToJs(instruction.UpdateSyncStatus.status));
            }
            else if ('EstablishSyncStream' in instruction) {
                if (receivingLines != null) {
                    // Already connected, this shouldn't happen during a single iteration.
                    throw 'Unexpected request to establish sync stream, already connected';
                }
                receivingLines = connect(instruction.EstablishSyncStream);
            }
            else if ('FetchCredentials' in instruction) {
                if (instruction.FetchCredentials.did_expire) {
                    remote.invalidateCredentials();
                }
                else {
                    remote.invalidateCredentials();
                    // Restart iteration after the credentials have been refreshed.
                    remote.fetchCredentials().then((_) => {
                        controlInvocations?.enqueueData({ command: PowerSyncControlCommand.NOTIFY_TOKEN_REFRESHED });
                    }, (err) => {
                        syncImplementation.logger.warn('Could not prefetch credentials', err);
                    });
                }
            }
            else if ('CloseSyncStream' in instruction) {
                abortController.abort();
                hideDisconnectOnRestart = instruction.CloseSyncStream.hide_disconnect;
            }
            else if ('FlushFileSystem' in instruction) ;
            else if ('DidCompleteSync' in instruction) {
                syncImplementation.updateSyncStatus({
                    dataFlow: {
                        downloadError: undefined
                    }
                });
            }
        }
        async function handleInstructions(instructions) {
            for (const instr of instructions) {
                await handleInstruction(instr);
            }
        }
        try {
            const options = {
                parameters: resolvedOptions.params,
                active_streams: this.activeStreams,
                include_defaults: resolvedOptions.includeDefaultStreams
            };
            if (resolvedOptions.serializedSchema) {
                options.schema = resolvedOptions.serializedSchema;
            }
            await control(PowerSyncControlCommand.START, JSON.stringify(options));
            this.notifyCompletedUploads = () => {
                if (controlInvocations && !controlInvocations?.closed) {
                    controlInvocations.enqueueData({ command: PowerSyncControlCommand.NOTIFY_CRUD_UPLOAD_COMPLETED });
                }
            };
            this.handleActiveStreamsChange = () => {
                if (controlInvocations && !controlInvocations?.closed) {
                    controlInvocations.enqueueData({
                        command: PowerSyncControlCommand.UPDATE_SUBSCRIPTIONS,
                        payload: JSON.stringify(this.activeStreams)
                    });
                }
            };
            await receivingLines;
        }
        finally {
            this.notifyCompletedUploads = this.handleActiveStreamsChange = undefined;
            await stop();
        }
        return { immediateRestart: hideDisconnectOnRestart };
    }
    async updateSyncStatusForStartingCheckpoint(checkpoint) {
        const localProgress = await this.options.adapter.getBucketOperationProgress();
        const progress = {};
        let invalidated = false;
        for (const bucket of checkpoint.buckets) {
            const savedProgress = localProgress[bucket.bucket];
            const atLast = savedProgress?.atLast ?? 0;
            const sinceLast = savedProgress?.sinceLast ?? 0;
            progress[bucket.bucket] = {
                // The fallback priority doesn't matter here, but 3 is the one newer versions of the sync service
                // will use by default.
                priority: bucket.priority ?? 3,
                at_last: atLast,
                since_last: sinceLast,
                target_count: bucket.count ?? 0
            };
            if (bucket.count != null && bucket.count < atLast + sinceLast) {
                // Either due to a defrag / sync rule deploy or a compaction operation, the size
                // of the bucket shrank so much that the local ops exceed the ops in the updated
                // bucket. We can't prossibly report progress in this case (it would overshoot 100%).
                invalidated = true;
            }
        }
        if (invalidated) {
            for (const bucket in progress) {
                const bucketProgress = progress[bucket];
                bucketProgress.at_last = 0;
                bucketProgress.since_last = 0;
            }
        }
        this.updateSyncStatus({
            dataFlow: {
                downloading: true,
                downloadProgress: progress
            }
        });
    }
    async applyCheckpoint(checkpoint) {
        let result = await this.options.adapter.syncLocalDatabase(checkpoint);
        if (!result.checkpointValid) {
            this.logger.debug(`Checksum mismatch in checkpoint ${checkpoint.last_op_id}, will reconnect`);
            // This means checksums failed. Start again with a new checkpoint.
            // TODO: better back-off
            await new Promise((resolve) => setTimeout(resolve, 50));
            return { applied: false, endIteration: true };
        }
        else if (!result.ready) {
            this.logger.debug(`Could not apply checkpoint ${checkpoint.last_op_id} due to local data. We will retry applying the checkpoint after that upload is completed.`);
            return { applied: false, endIteration: false };
        }
        this.logger.debug(`Applied checkpoint ${checkpoint.last_op_id}`, checkpoint);
        this.updateSyncStatus({
            connected: true,
            lastSyncedAt: new Date(),
            dataFlow: {
                downloading: false,
                downloadProgress: null,
                downloadError: undefined
            }
        });
        return { applied: true, endIteration: false };
    }
    updateSyncStatus(options) {
        const updatedStatus = new SyncStatus({
            connected: options.connected ?? this.syncStatus.connected,
            connecting: !options.connected && (options.connecting ?? this.syncStatus.connecting),
            lastSyncedAt: options.lastSyncedAt ?? this.syncStatus.lastSyncedAt,
            dataFlow: {
                ...this.syncStatus.dataFlowStatus,
                ...options.dataFlow
            },
            priorityStatusEntries: options.priorityStatusEntries ?? this.syncStatus.priorityStatusEntries,
            clientImplementation: options.clientImplementation ?? this.syncStatus.clientImplementation
        });
        if (!this.syncStatus.isEqual(updatedStatus)) {
            this.syncStatus = updatedStatus;
            // Only trigger this is there was a change
            this.iterateListeners((cb) => cb.statusChanged?.(updatedStatus));
        }
        // trigger this for all updates
        this.iterateListeners((cb) => cb.statusUpdated?.(options));
    }
    async delayRetry(signal) {
        return new Promise((resolve) => {
            if (signal?.aborted) {
                // If the signal is already aborted, resolve immediately
                resolve();
                return;
            }
            const { retryDelayMs } = this.options;
            let timeoutId;
            const endDelay = () => {
                resolve();
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = undefined;
                }
                signal?.removeEventListener('abort', endDelay);
            };
            signal?.addEventListener('abort', endDelay, { once: true });
            timeoutId = setTimeout(endDelay, retryDelayMs);
        });
    }
    updateSubscriptions(subscriptions) {
        this.activeStreams = subscriptions;
        this.handleActiveStreamsChange?.();
    }
}

/**
 * SQLite operations to track changes for with {@link TriggerManager}
 * @experimental
 */
var DiffTriggerOperation;
(function (DiffTriggerOperation) {
    DiffTriggerOperation["INSERT"] = "INSERT";
    DiffTriggerOperation["UPDATE"] = "UPDATE";
    DiffTriggerOperation["DELETE"] = "DELETE";
})(DiffTriggerOperation || (DiffTriggerOperation = {}));

class TriggerManagerImpl {
    options;
    schema;
    constructor(options) {
        this.options = options;
        this.schema = options.schema;
        options.db.registerListener({
            schemaChanged: (schema) => {
                this.schema = schema;
            }
        });
    }
    get db() {
        return this.options.db;
    }
    async getUUID() {
        const { id: uuid } = await this.db.get(/* sql */ `
      SELECT
        uuid () as id
    `);
        // Replace dashes with underscores for SQLite table/trigger name compatibility
        return uuid.replace(/-/g, '_');
    }
    async removeTriggers(tx, triggerIds) {
        for (const triggerId of triggerIds) {
            await tx.execute(/* sql */ `DROP TRIGGER IF EXISTS ${triggerId}; `);
        }
    }
    async createDiffTrigger(options) {
        await this.db.waitForReady();
        const { source, destination, columns, when, hooks } = options;
        const operations = Object.keys(when);
        if (operations.length == 0) {
            throw new Error('At least one WHEN operation must be specified for the trigger.');
        }
        const whenClauses = Object.fromEntries(Object.entries(when).map(([operation, filter]) => [operation, `WHEN ${filter}`]));
        /**
         * Allow specifying the View name as the source.
         * We can lookup the internal table name from the schema.
         */
        const sourceDefinition = this.schema.tables.find((table) => table.viewName == source);
        if (!sourceDefinition) {
            throw new Error(`Source table or view "${source}" not found in the schema.`);
        }
        const replicatedColumns = columns ?? sourceDefinition.columns.map((col) => col.name);
        const internalSource = sourceDefinition.internalName;
        const triggerIds = [];
        const id = await this.getUUID();
        /**
         * We default to replicating all columns if no columns array is provided.
         */
        const jsonFragment = (source = 'NEW') => {
            if (columns == null) {
                // Track all columns
                return `${source}.data`;
            }
            else if (columns.length == 0) {
                // Don't track any columns except for the id
                return `'{}'`;
            }
            else {
                // Filter the data by the replicated columns
                return `json_object(${replicatedColumns.map((col) => `'${col}', json_extract(${source}.data, '$.${col}')`).join(', ')})`;
            }
        };
        const disposeWarningListener = this.db.registerListener({
            schemaChanged: () => {
                this.db.logger.warn(`The PowerSync schema has changed while previously configured triggers are still operational. This might cause unexpected results.`);
            }
        });
        /**
         * Declare the cleanup function early since if any of the init steps fail,
         * we need to ensure we can cleanup the created resources.
         * We unfortunately cannot rely on transaction rollback.
         */
        const cleanup = async () => {
            disposeWarningListener();
            return this.db.writeLock(async (tx) => {
                await this.removeTriggers(tx, triggerIds);
                await tx.execute(/* sql */ `DROP TABLE IF EXISTS ${destination};`);
            });
        };
        const setup = async (tx) => {
            // Allow user code to execute in this lock context before the trigger is created.
            await hooks?.beforeCreate?.(tx);
            await tx.execute(/* sql */ `
        CREATE TEMP TABLE ${destination} (
          operation_id INTEGER PRIMARY KEY AUTOINCREMENT,
          id TEXT,
          operation TEXT,
          timestamp TEXT,
          value TEXT,
          previous_value TEXT
        );
      `);
            if (operations.includes(DiffTriggerOperation.INSERT)) {
                const insertTriggerId = `ps_temp_trigger_insert_${id}`;
                triggerIds.push(insertTriggerId);
                await tx.execute(/* sql */ `
          CREATE TEMP TRIGGER ${insertTriggerId} AFTER INSERT ON ${internalSource} ${whenClauses[DiffTriggerOperation.INSERT]} BEGIN
          INSERT INTO
            ${destination} (id, operation, timestamp, value)
          VALUES
            (
              NEW.id,
              'INSERT',
              strftime ('%Y-%m-%dT%H:%M:%fZ', 'now'),
              ${jsonFragment('NEW')}
            );

          END;
        `);
            }
            if (operations.includes(DiffTriggerOperation.UPDATE)) {
                const updateTriggerId = `ps_temp_trigger_update_${id}`;
                triggerIds.push(updateTriggerId);
                await tx.execute(/* sql */ `
          CREATE TEMP TRIGGER ${updateTriggerId} AFTER
          UPDATE ON ${internalSource} ${whenClauses[DiffTriggerOperation.UPDATE]} BEGIN
          INSERT INTO
            ${destination} (id, operation, timestamp, value, previous_value)
          VALUES
            (
              NEW.id,
              'UPDATE',
              strftime ('%Y-%m-%dT%H:%M:%fZ', 'now'),
              ${jsonFragment('NEW')},
              ${jsonFragment('OLD')}
            );

          END;
        `);
            }
            if (operations.includes(DiffTriggerOperation.DELETE)) {
                const deleteTriggerId = `ps_temp_trigger_delete_${id}`;
                triggerIds.push(deleteTriggerId);
                // Create delete trigger for basic JSON
                await tx.execute(/* sql */ `
          CREATE TEMP TRIGGER ${deleteTriggerId} AFTER DELETE ON ${internalSource} ${whenClauses[DiffTriggerOperation.DELETE]} BEGIN
          INSERT INTO
            ${destination} (id, operation, timestamp, value)
          VALUES
            (
              OLD.id,
              'DELETE',
              strftime ('%Y-%m-%dT%H:%M:%fZ', 'now'),
              ${jsonFragment('OLD')}
            );

          END;
        `);
            }
        };
        try {
            await this.db.writeLock(setup);
            return cleanup;
        }
        catch (error) {
            try {
                await cleanup();
            }
            catch (cleanupError) {
                throw new AggregateError([error, cleanupError], 'Error during operation and cleanup');
            }
            throw error;
        }
    }
    async trackTableDiff(options) {
        const { source, when, columns, hooks, throttleMs = DEFAULT_WATCH_THROTTLE_MS } = options;
        await this.db.waitForReady();
        /**
         * Allow specifying the View name as the source.
         * We can lookup the internal table name from the schema.
         */
        const sourceDefinition = this.schema.tables.find((table) => table.viewName == source);
        if (!sourceDefinition) {
            throw new Error(`Source table or view "${source}" not found in the schema.`);
        }
        // The columns to present in the onChange context methods.
        // If no array is provided, we use all columns from the source table.
        const contextColumns = columns ?? sourceDefinition.columns.map((col) => col.name);
        const id = await this.getUUID();
        const destination = `ps_temp_track_${source}_${id}`;
        // register an onChange before the trigger is created
        const abortController = new AbortController();
        const abortOnChange = () => abortController.abort();
        this.db.onChange({
            // Note that the onChange events here have their execution scheduled.
            // Callbacks are throttled and are sequential.
            onChange: async () => {
                if (abortController.signal.aborted)
                    return;
                // Run the handler in a write lock to keep the state of the
                // destination table consistent.
                await this.db.writeTransaction(async (tx) => {
                    const callbackResult = await options.onChange({
                        ...tx,
                        destinationTable: destination,
                        withDiff: async (query, params, options) => {
                            // Wrap the query to expose the destination table
                            const operationIdSelect = options?.castOperationIdAsText
                                ? 'id, operation, CAST(operation_id AS TEXT) as operation_id, timestamp, value, previous_value'
                                : '*';
                            const wrappedQuery = /* sql */ `
                  WITH
                    DIFF AS (
                      SELECT
                        ${operationIdSelect}
                      FROM
                        ${destination}
                      ORDER BY
                        operation_id ASC
                    ) ${query}
                `;
                            return tx.getAll(wrappedQuery, params);
                        },
                        withExtractedDiff: async (query, params) => {
                            // Wrap the query to expose the destination table
                            const wrappedQuery = /* sql */ `
                  WITH
                    DIFF AS (
                      SELECT
                        id,
                        ${contextColumns.length > 0
                                ? `${contextColumns.map((col) => `json_extract(value, '$.${col}') as ${col}`).join(', ')},`
                                : ''} operation_id as __operation_id,
                        operation as __operation,
                        timestamp as __timestamp,
                        previous_value as __previous_value
                      FROM
                        ${destination}
                      ORDER BY
                        __operation_id ASC
                    ) ${query}
                `;
                            return tx.getAll(wrappedQuery, params);
                        }
                    });
                    // Clear the destination table after processing
                    await tx.execute(/* sql */ `DELETE FROM ${destination};`);
                    return callbackResult;
                });
            }
        }, { tables: [destination], signal: abortController.signal, throttleMs });
        try {
            const removeTrigger = await this.createDiffTrigger({
                source,
                destination,
                columns: contextColumns,
                when,
                hooks
            });
            return async () => {
                abortOnChange();
                await removeTrigger();
            };
        }
        catch (error) {
            try {
                abortOnChange();
            }
            catch (cleanupError) {
                throw new AggregateError([error, cleanupError], 'Error during operation and cleanup');
            }
            throw error;
        }
    }
}

const POWERSYNC_TABLE_MATCH = /(^ps_data__|^ps_data_local__)/;
const DEFAULT_DISCONNECT_CLEAR_OPTIONS = {
    clearLocal: true
};
const DEFAULT_POWERSYNC_CLOSE_OPTIONS = {
    disconnect: true
};
const DEFAULT_POWERSYNC_DB_OPTIONS = {
    retryDelayMs: 5000,
    crudUploadThrottleMs: DEFAULT_CRUD_UPLOAD_THROTTLE_MS
};
const DEFAULT_CRUD_BATCH_LIMIT = 100;
/**
 * Requesting nested or recursive locks can block the application in some circumstances.
 * This default lock timeout will act as a failsafe to throw an error if a lock cannot
 * be obtained.
 */
const DEFAULT_LOCK_TIMEOUT_MS = 120_000; // 2 mins
/**
 * Tests if the input is a {@link PowerSyncDatabaseOptionsWithSettings}
 * @internal
 */
const isPowerSyncDatabaseOptionsWithSettings = (test) => {
    return typeof test == 'object' && isSQLOpenOptions(test.database);
};
class AbstractPowerSyncDatabase extends BaseObserver {
    options;
    /**
     * Returns true if the connection is closed.
     */
    closed;
    ready;
    /**
     * Current connection status.
     */
    currentStatus;
    sdkVersion;
    bucketStorageAdapter;
    _isReadyPromise;
    connectionManager;
    subscriptions;
    get syncStreamImplementation() {
        return this.connectionManager.syncStreamImplementation;
    }
    /**
     * The connector used to connect to the PowerSync service.
     *
     * @returns The connector used to connect to the PowerSync service or null if `connect()` has not been called.
     */
    get connector() {
        return this.connectionManager.connector;
    }
    /**
     * The resolved connection options used to connect to the PowerSync service.
     *
     * @returns The resolved connection options used to connect to the PowerSync service or null if `connect()` has not been called.
     */
    get connectionOptions() {
        return this.connectionManager.connectionOptions;
    }
    _schema;
    _database;
    runExclusiveMutex;
    /**
     * @experimental
     * Allows creating SQLite triggers which can be used to track various operations on SQLite tables.
     */
    triggers;
    logger;
    constructor(options) {
        super();
        this.options = options;
        const { database, schema } = options;
        if (typeof schema?.toJSON != 'function') {
            throw new Error('The `schema` option should be provided and should be an instance of `Schema`.');
        }
        if (isDBAdapter(database)) {
            this._database = database;
        }
        else if (isSQLOpenFactory(database)) {
            this._database = database.openDB();
        }
        else if (isPowerSyncDatabaseOptionsWithSettings(options)) {
            this._database = this.openDBAdapter(options);
        }
        else {
            throw new Error('The provided `database` option is invalid.');
        }
        this.logger = options.logger ?? Logger.get(`PowerSyncDatabase[${this._database.name}]`);
        this.bucketStorageAdapter = this.generateBucketStorageAdapter();
        this.closed = false;
        this.currentStatus = new SyncStatus({});
        this.options = { ...DEFAULT_POWERSYNC_DB_OPTIONS, ...options };
        this._schema = schema;
        this.ready = false;
        this.sdkVersion = '';
        this.runExclusiveMutex = new async_mutex__WEBPACK_IMPORTED_MODULE_0__.Mutex();
        // Start async init
        this.subscriptions = {
            firstStatusMatching: (predicate, abort) => this.waitForStatus(predicate, abort),
            resolveOfflineSyncStatus: () => this.resolveOfflineSyncStatus(),
            rustSubscriptionsCommand: async (payload) => {
                await this.writeTransaction((tx) => {
                    return tx.execute('select powersync_control(?,?)', ['subscriptions', JSON.stringify(payload)]);
                });
            }
        };
        this.connectionManager = new ConnectionManager({
            createSyncImplementation: async (connector, options) => {
                await this.waitForReady();
                return this.runExclusive(async () => {
                    const sync = this.generateSyncStreamImplementation(connector, this.resolvedConnectionOptions(options));
                    const onDispose = sync.registerListener({
                        statusChanged: (status) => {
                            this.currentStatus = new SyncStatus({
                                ...status.toJSON(),
                                hasSynced: this.currentStatus?.hasSynced || !!status.lastSyncedAt
                            });
                            this.iterateListeners((cb) => cb.statusChanged?.(this.currentStatus));
                        }
                    });
                    await sync.waitForReady();
                    return {
                        sync,
                        onDispose
                    };
                });
            },
            logger: this.logger
        });
        this._isReadyPromise = this.initialize();
        this.triggers = new TriggerManagerImpl({
            db: this,
            schema: this.schema
        });
    }
    /**
     * Schema used for the local database.
     */
    get schema() {
        return this._schema;
    }
    /**
     * The underlying database.
     *
     * For the most part, behavior is the same whether querying on the underlying database, or on {@link AbstractPowerSyncDatabase}.
     */
    get database() {
        return this._database;
    }
    /**
     * Whether a connection to the PowerSync service is currently open.
     */
    get connected() {
        return this.currentStatus?.connected || false;
    }
    get connecting() {
        return this.currentStatus?.connecting || false;
    }
    /**
     * @returns A promise which will resolve once initialization is completed.
     */
    async waitForReady() {
        if (this.ready) {
            return;
        }
        await this._isReadyPromise;
    }
    /**
     * Wait for the first sync operation to complete.
     *
     * @param request Either an abort signal (after which the promise will complete regardless of
     * whether a full sync was completed) or an object providing an abort signal and a priority target.
     * When a priority target is set, the promise may complete when all buckets with the given (or higher)
     * priorities have been synchronized. This can be earlier than a complete sync.
     * @returns A promise which will resolve once the first full sync has completed.
     */
    async waitForFirstSync(request) {
        const signal = request instanceof AbortSignal ? request : request?.signal;
        const priority = request && 'priority' in request ? request.priority : undefined;
        const statusMatches = priority === undefined
            ? (status) => status.hasSynced
            : (status) => status.statusForPriority(priority).hasSynced;
        return this.waitForStatus(statusMatches, signal);
    }
    /**
     * Waits for the first sync status for which the `status` callback returns a truthy value.
     */
    async waitForStatus(predicate, signal) {
        if (predicate(this.currentStatus)) {
            return;
        }
        return new Promise((resolve) => {
            const dispose = this.registerListener({
                statusChanged: (status) => {
                    if (predicate(status)) {
                        abort();
                    }
                }
            });
            function abort() {
                dispose();
                resolve();
            }
            if (signal?.aborted) {
                abort();
            }
            else {
                signal?.addEventListener('abort', abort);
            }
        });
    }
    /**
     * Entry point for executing initialization logic.
     * This is to be automatically executed in the constructor.
     */
    async initialize() {
        await this._initialize();
        await this.bucketStorageAdapter.init();
        await this._loadVersion();
        await this.updateSchema(this.options.schema);
        await this.resolveOfflineSyncStatus();
        await this.database.execute('PRAGMA RECURSIVE_TRIGGERS=TRUE');
        this.ready = true;
        this.iterateListeners((cb) => cb.initialized?.());
    }
    async _loadVersion() {
        try {
            const { version } = await this.database.get('SELECT powersync_rs_version() as version');
            this.sdkVersion = version;
        }
        catch (e) {
            throw new Error(`The powersync extension is not loaded correctly. Details: ${e.message}`);
        }
        let versionInts;
        try {
            versionInts = this.sdkVersion.split(/[.\/]/)
                .slice(0, 3)
                .map((n) => parseInt(n));
        }
        catch (e) {
            throw new Error(`Unsupported powersync extension version. Need >=0.4.5 <1.0.0, got: ${this.sdkVersion}. Details: ${e.message}`);
        }
        // Validate >=0.4.5 <1.0.0
        if (versionInts[0] != 0 || versionInts[1] < 4 || (versionInts[1] == 4 && versionInts[2] < 5)) {
            throw new Error(`Unsupported powersync extension version. Need >=0.4.5 <1.0.0, got: ${this.sdkVersion}`);
        }
    }
    async resolveOfflineSyncStatus() {
        const result = await this.database.get('SELECT powersync_offline_sync_status() as r');
        const parsed = JSON.parse(result.r);
        const updatedStatus = new SyncStatus({
            ...this.currentStatus.toJSON(),
            ...coreStatusToJs(parsed)
        });
        if (!updatedStatus.isEqual(this.currentStatus)) {
            this.currentStatus = updatedStatus;
            this.iterateListeners((l) => l.statusChanged?.(this.currentStatus));
        }
    }
    /**
     * Replace the schema with a new version. This is for advanced use cases - typically the schema should just be specified once in the constructor.
     *
     * Cannot be used while connected - this should only be called before {@link AbstractPowerSyncDatabase.connect}.
     */
    async updateSchema(schema) {
        if (this.syncStreamImplementation) {
            throw new Error('Cannot update schema while connected');
        }
        /**
         * TODO
         * Validations only show a warning for now.
         * The next major release should throw an exception.
         */
        try {
            schema.validate();
        }
        catch (ex) {
            this.logger.warn('Schema validation failed. Unexpected behaviour could occur', ex);
        }
        this._schema = schema;
        await this.database.execute('SELECT powersync_replace_schema(?)', [JSON.stringify(this.schema.toJSON())]);
        await this.database.refreshSchema();
        this.iterateListeners(async (cb) => cb.schemaChanged?.(schema));
    }
    /**
     * Wait for initialization to complete.
     * While initializing is automatic, this helps to catch and report initialization errors.
     */
    async init() {
        return this.waitForReady();
    }
    // Use the options passed in during connect, or fallback to the options set during database creation or fallback to the default options
    resolvedConnectionOptions(options) {
        return {
            ...options,
            retryDelayMs: options?.retryDelayMs ?? this.options.retryDelayMs ?? this.options.retryDelay ?? DEFAULT_RETRY_DELAY_MS,
            crudUploadThrottleMs: options?.crudUploadThrottleMs ?? this.options.crudUploadThrottleMs ?? DEFAULT_CRUD_UPLOAD_THROTTLE_MS
        };
    }
    /**
     * @deprecated Use {@link AbstractPowerSyncDatabase#close} instead.
     * Clears all listeners registered by {@link AbstractPowerSyncDatabase#registerListener}.
     */
    dispose() {
        return super.dispose();
    }
    /**
     * Locking mechanism for exclusively running critical portions of connect/disconnect operations.
     * Locking here is mostly only important on web for multiple tab scenarios.
     */
    runExclusive(callback) {
        return this.runExclusiveMutex.runExclusive(callback);
    }
    /**
     * Connects to stream of events from the PowerSync instance.
     */
    async connect(connector, options) {
        const resolvedOptions = options ?? {};
        resolvedOptions.serializedSchema = this.schema.toJSON();
        return this.connectionManager.connect(connector, resolvedOptions);
    }
    /**
     * Close the sync connection.
     *
     * Use {@link connect} to connect again.
     */
    async disconnect() {
        return this.connectionManager.disconnect();
    }
    /**
     *  Disconnect and clear the database.
     *  Use this when logging out.
     *  The database can still be queried after this is called, but the tables
     *  would be empty.
     *
     * To preserve data in local-only tables, set clearLocal to false.
     */
    async disconnectAndClear(options = DEFAULT_DISCONNECT_CLEAR_OPTIONS) {
        await this.disconnect();
        await this.waitForReady();
        const { clearLocal } = options;
        // TODO DB name, verify this is necessary with extension
        await this.database.writeTransaction(async (tx) => {
            await tx.execute('SELECT powersync_clear(?)', [clearLocal ? 1 : 0]);
        });
        // The data has been deleted - reset the sync status
        this.currentStatus = new SyncStatus({});
        this.iterateListeners((l) => l.statusChanged?.(this.currentStatus));
    }
    /**
     * Create a sync stream to query its status or to subscribe to it.
     *
     * @param name The name of the stream to subscribe to.
     * @param params Optional parameters for the stream subscription.
     * @returns A {@link SyncStream} instance that can be subscribed to.
     * @experimental Sync streams are currently in alpha.
     */
    syncStream(name, params) {
        return this.connectionManager.stream(this.subscriptions, name, params ?? null);
    }
    /**
     * Close the database, releasing resources.
     *
     * Also disconnects any active connection.
     *
     * Once close is called, this connection cannot be used again - a new one
     * must be constructed.
     */
    async close(options = DEFAULT_POWERSYNC_CLOSE_OPTIONS) {
        await this.waitForReady();
        if (this.closed) {
            return;
        }
        await this.iterateAsyncListeners(async (cb) => cb.closing?.());
        const { disconnect } = options;
        if (disconnect) {
            await this.disconnect();
        }
        await this.connectionManager.close();
        await this.database.close();
        this.closed = true;
        await this.iterateAsyncListeners(async (cb) => cb.closed?.());
    }
    /**
     * Get upload queue size estimate and count.
     */
    async getUploadQueueStats(includeSize) {
        return this.readTransaction(async (tx) => {
            if (includeSize) {
                const result = await tx.execute(`SELECT SUM(cast(data as blob) + 20) as size, count(*) as count FROM ${PSInternalTable.CRUD}`);
                const row = result.rows.item(0);
                return new UploadQueueStats(row?.count ?? 0, row?.size ?? 0);
            }
            else {
                const result = await tx.execute(`SELECT count(*) as count FROM ${PSInternalTable.CRUD}`);
                const row = result.rows.item(0);
                return new UploadQueueStats(row?.count ?? 0);
            }
        });
    }
    /**
     * Get a batch of CRUD data to upload.
     *
     * Returns null if there is no data to upload.
     *
     * Use this from the {@link PowerSyncBackendConnector.uploadData} callback.
     *
     * Once the data have been successfully uploaded, call {@link CrudBatch.complete} before
     * requesting the next batch.
     *
     * Use {@link limit} to specify the maximum number of updates to return in a single
     * batch.
     *
     * This method does include transaction ids in the result, but does not group
     * data by transaction. One batch may contain data from multiple transactions,
     * and a single transaction may be split over multiple batches.
     *
     * @param limit Maximum number of CRUD entries to include in the batch
     * @returns A batch of CRUD operations to upload, or null if there are none
     */
    async getCrudBatch(limit = DEFAULT_CRUD_BATCH_LIMIT) {
        const result = await this.getAll(`SELECT id, tx_id, data FROM ${PSInternalTable.CRUD} ORDER BY id ASC LIMIT ?`, [limit + 1]);
        const all = result.map((row) => CrudEntry.fromRow(row)) ?? [];
        let haveMore = false;
        if (all.length > limit) {
            all.pop();
            haveMore = true;
        }
        if (all.length == 0) {
            return null;
        }
        const last = all[all.length - 1];
        return new CrudBatch(all, haveMore, async (writeCheckpoint) => this.handleCrudCheckpoint(last.clientId, writeCheckpoint));
    }
    /**
     * Get the next recorded transaction to upload.
     *
     * Returns null if there is no data to upload.
     *
     * Use this from the {@link PowerSyncBackendConnector.uploadData} callback.
     *
     * Once the data have been successfully uploaded, call {@link CrudTransaction.complete} before
     * requesting the next transaction.
     *
     * Unlike {@link getCrudBatch}, this only returns data from a single transaction at a time.
     * All data for the transaction is loaded into memory.
     *
     * @returns A transaction of CRUD operations to upload, or null if there are none
     */
    async getNextCrudTransaction() {
        const iterator = this.getCrudTransactions()[symbolAsyncIterator]();
        return (await iterator.next()).value;
    }
    /**
     * Returns an async iterator of completed transactions with local writes against the database.
     *
     * This is typically used from the {@link PowerSyncBackendConnector.uploadData} callback. Each entry emitted by the
     * returned iterator is a full transaction containing all local writes made while that transaction was active.
     *
     * Unlike {@link getNextCrudTransaction}, which always returns the oldest transaction that hasn't been
     * {@link CrudTransaction.complete}d yet, this iterator can be used to receive multiple transactions. Calling
     * {@link CrudTransaction.complete} will mark that and all prior transactions emitted by the iterator as completed.
     *
     * This can be used to upload multiple transactions in a single batch, e.g with:
     *
     * ```JavaScript
     * let lastTransaction = null;
     * let batch = [];
     *
     * for await (const transaction of database.getCrudTransactions()) {
     *   batch.push(...transaction.crud);
     *   lastTransaction = transaction;
     *
     *   if (batch.length > 10) {
     *     break;
     *    }
     * }
     * ```
     *
     * If there is no local data to upload, the async iterator complete without emitting any items.
     *
     * Note that iterating over async iterables requires a [polyfill](https://github.com/powersync-ja/powersync-js/tree/main/packages/react-native#babel-plugins-watched-queries)
     * for React Native.
     */
    getCrudTransactions() {
        return {
            [symbolAsyncIterator]: () => {
                let lastCrudItemId = -1;
                const sql = `
WITH RECURSIVE crud_entries AS (
  SELECT id, tx_id, data FROM ps_crud WHERE id = (SELECT min(id) FROM ps_crud WHERE id > ?)
  UNION ALL
  SELECT ps_crud.id, ps_crud.tx_id, ps_crud.data FROM ps_crud
    INNER JOIN crud_entries ON crud_entries.id + 1 = rowid
  WHERE crud_entries.tx_id = ps_crud.tx_id
)
SELECT * FROM crud_entries;
    `;
                return {
                    next: async () => {
                        const nextTransaction = await this.database.getAll(sql, [lastCrudItemId]);
                        if (nextTransaction.length == 0) {
                            return { done: true, value: null };
                        }
                        const items = nextTransaction.map((row) => CrudEntry.fromRow(row));
                        const last = items[items.length - 1];
                        const txId = last.transactionId;
                        lastCrudItemId = last.clientId;
                        return {
                            done: false,
                            value: new CrudTransaction(items, async (writeCheckpoint) => this.handleCrudCheckpoint(last.clientId, writeCheckpoint), txId)
                        };
                    }
                };
            }
        };
    }
    /**
     * Get an unique client id for this database.
     *
     * The id is not reset when the database is cleared, only when the database is deleted.
     *
     * @returns A unique identifier for the database instance
     */
    async getClientId() {
        return this.bucketStorageAdapter.getClientId();
    }
    async handleCrudCheckpoint(lastClientId, writeCheckpoint) {
        return this.writeTransaction(async (tx) => {
            await tx.execute(`DELETE FROM ${PSInternalTable.CRUD} WHERE id <= ?`, [lastClientId]);
            if (writeCheckpoint) {
                const check = await tx.execute(`SELECT 1 FROM ${PSInternalTable.CRUD} LIMIT 1`);
                if (!check.rows?.length) {
                    await tx.execute(`UPDATE ${PSInternalTable.BUCKETS} SET target_op = CAST(? as INTEGER) WHERE name='$local'`, [
                        writeCheckpoint
                    ]);
                }
            }
            else {
                await tx.execute(`UPDATE ${PSInternalTable.BUCKETS} SET target_op = CAST(? as INTEGER) WHERE name='$local'`, [
                    this.bucketStorageAdapter.getMaxOpId()
                ]);
            }
        });
    }
    /**
     * Execute a SQL write (INSERT/UPDATE/DELETE) query
     * and optionally return results.
     *
     * @param sql The SQL query to execute
     * @param parameters Optional array of parameters to bind to the query
     * @returns The query result as an object with structured key-value pairs
     */
    async execute(sql, parameters) {
        return this.writeLock((tx) => tx.execute(sql, parameters));
    }
    /**
     * Execute a SQL write (INSERT/UPDATE/DELETE) query directly on the database without any PowerSync processing.
     * This bypasses certain PowerSync abstractions and is useful for accessing the raw database results.
     *
     * @param sql The SQL query to execute
     * @param parameters Optional array of parameters to bind to the query
     * @returns The raw query result from the underlying database as a nested array of raw values, where each row is
     * represented as an array of column values without field names.
     */
    async executeRaw(sql, parameters) {
        await this.waitForReady();
        return this.database.executeRaw(sql, parameters);
    }
    /**
     * Execute a write query (INSERT/UPDATE/DELETE) multiple times with each parameter set
     * and optionally return results.
     * This is faster than executing separately with each parameter set.
     *
     * @param sql The SQL query to execute
     * @param parameters Optional 2D array of parameter sets, where each inner array is a set of parameters for one execution
     * @returns The query result
     */
    async executeBatch(sql, parameters) {
        await this.waitForReady();
        return this.database.executeBatch(sql, parameters);
    }
    /**
     *  Execute a read-only query and return results.
     *
     * @param sql The SQL query to execute
     * @param parameters Optional array of parameters to bind to the query
     * @returns An array of results
     */
    async getAll(sql, parameters) {
        await this.waitForReady();
        return this.database.getAll(sql, parameters);
    }
    /**
     * Execute a read-only query and return the first result, or null if the ResultSet is empty.
     *
     * @param sql The SQL query to execute
     * @param parameters Optional array of parameters to bind to the query
     * @returns The first result if found, or null if no results are returned
     */
    async getOptional(sql, parameters) {
        await this.waitForReady();
        return this.database.getOptional(sql, parameters);
    }
    /**
     * Execute a read-only query and return the first result, error if the ResultSet is empty.
     *
     * @param sql The SQL query to execute
     * @param parameters Optional array of parameters to bind to the query
     * @returns The first result matching the query
     * @throws Error if no rows are returned
     */
    async get(sql, parameters) {
        await this.waitForReady();
        return this.database.get(sql, parameters);
    }
    /**
     * Takes a read lock, without starting a transaction.
     * In most cases, {@link readTransaction} should be used instead.
     */
    async readLock(callback) {
        await this.waitForReady();
        return this.database.readLock(callback);
    }
    /**
     * Takes a global lock, without starting a transaction.
     * In most cases, {@link writeTransaction} should be used instead.
     */
    async writeLock(callback) {
        await this.waitForReady();
        return this.database.writeLock(callback);
    }
    /**
     * Open a read-only transaction.
     * Read transactions can run concurrently to a write transaction.
     * Changes from any write transaction are not visible to read transactions started before it.
     *
     * @param callback Function to execute within the transaction
     * @param lockTimeout Time in milliseconds to wait for a lock before throwing an error
     * @returns The result of the callback
     * @throws Error if the lock cannot be obtained within the timeout period
     */
    async readTransaction(callback, lockTimeout = DEFAULT_LOCK_TIMEOUT_MS) {
        await this.waitForReady();
        return this.database.readTransaction(async (tx) => {
            const res = await callback({ ...tx });
            await tx.rollback();
            return res;
        }, { timeoutMs: lockTimeout });
    }
    /**
     * Open a read-write transaction.
     * This takes a global lock - only one write transaction can execute against the database at a time.
     * Statements within the transaction must be done on the provided {@link Transaction} interface.
     *
     * @param callback Function to execute within the transaction
     * @param lockTimeout Time in milliseconds to wait for a lock before throwing an error
     * @returns The result of the callback
     * @throws Error if the lock cannot be obtained within the timeout period
     */
    async writeTransaction(callback, lockTimeout = DEFAULT_LOCK_TIMEOUT_MS) {
        await this.waitForReady();
        return this.database.writeTransaction(async (tx) => {
            const res = await callback(tx);
            await tx.commit();
            return res;
        }, { timeoutMs: lockTimeout });
    }
    watch(sql, parameters, handlerOrOptions, maybeOptions) {
        if (handlerOrOptions && typeof handlerOrOptions === 'object' && 'onResult' in handlerOrOptions) {
            const handler = handlerOrOptions;
            const options = maybeOptions;
            return this.watchWithCallback(sql, parameters, handler, options);
        }
        const options = handlerOrOptions;
        return this.watchWithAsyncGenerator(sql, parameters, options);
    }
    /**
     * Allows defining a query which can be used to build a {@link WatchedQuery}.
     * The defined query will be executed with {@link AbstractPowerSyncDatabase#getAll}.
     * An optional mapper function can be provided to transform the results.
     *
     * @example
     * ```javascript
     * const watchedTodos = powersync.query({
     *  sql: `SELECT photo_id as id FROM todos WHERE photo_id IS NOT NULL`,
     *  parameters: [],
     *  mapper: (row) => ({
     *    ...row,
     *    created_at: new Date(row.created_at as string)
     *  })
     * })
     * .watch()
     * // OR use .differentialWatch() for fine-grained watches.
     * ```
     */
    query(query) {
        const { sql, parameters = [], mapper } = query;
        const compatibleQuery = {
            compile: () => ({
                sql,
                parameters
            }),
            execute: async ({ sql, parameters }) => {
                const result = await this.getAll(sql, parameters);
                return mapper ? result.map(mapper) : result;
            }
        };
        return this.customQuery(compatibleQuery);
    }
    /**
     * Allows building a {@link WatchedQuery} using an existing {@link WatchCompatibleQuery}.
     * The watched query will use the provided {@link WatchCompatibleQuery.execute} method to query results.
     *
     * @example
     * ```javascript
     *
     * // Potentially a query from an ORM like Drizzle
     * const query = db.select().from(lists);
     *
     * const watchedTodos = powersync.customQuery(query)
     * .watch()
     * // OR use .differentialWatch() for fine-grained watches.
     * ```
     */
    customQuery(query) {
        return new CustomQuery({
            db: this,
            query
        });
    }
    /**
     * Execute a read query every time the source tables are modified.
     * Use {@link SQLWatchOptions.throttleMs} to specify the minimum interval between queries.
     * Source tables are automatically detected using `EXPLAIN QUERY PLAN`.
     *
     * Note that the `onChange` callback member of the handler is required.
     *
     * @param sql The SQL query to execute
     * @param parameters Optional array of parameters to bind to the query
     * @param handler Callbacks for handling results and errors
     * @param options Options for configuring watch behavior
     */
    watchWithCallback(sql, parameters, handler, options) {
        const { onResult, onError = (e) => this.logger.error(e) } = handler ?? {};
        if (!onResult) {
            throw new Error('onResult is required');
        }
        const { comparator } = options ?? {};
        // This API yields a QueryResult type.
        // This is not a standard Array result, which makes it incompatible with the .query API.
        const watchedQuery = new OnChangeQueryProcessor({
            db: this,
            comparator,
            placeholderData: null,
            watchOptions: {
                query: {
                    compile: () => ({
                        sql: sql,
                        parameters: parameters ?? []
                    }),
                    execute: () => this.executeReadOnly(sql, parameters)
                },
                reportFetching: false,
                throttleMs: options?.throttleMs ?? DEFAULT_WATCH_THROTTLE_MS,
                triggerOnTables: options?.tables
            }
        });
        const dispose = watchedQuery.registerListener({
            onData: (data) => {
                if (!data) {
                    // This should not happen. We only use null for the initial data.
                    return;
                }
                onResult(data);
            },
            onError: (error) => {
                onError(error);
            }
        });
        options?.signal?.addEventListener('abort', () => {
            dispose();
            watchedQuery.close();
        });
    }
    /**
     * Execute a read query every time the source tables are modified.
     * Use {@link SQLWatchOptions.throttleMs} to specify the minimum interval between queries.
     * Source tables are automatically detected using `EXPLAIN QUERY PLAN`.
     *
     * @param sql The SQL query to execute
     * @param parameters Optional array of parameters to bind to the query
     * @param options Options for configuring watch behavior
     * @returns An AsyncIterable that yields QueryResults whenever the data changes
     */
    watchWithAsyncGenerator(sql, parameters, options) {
        return new domExports.EventIterator((eventOptions) => {
            const handler = {
                onResult: (result) => {
                    eventOptions.push(result);
                },
                onError: (error) => {
                    eventOptions.fail(error);
                }
            };
            this.watchWithCallback(sql, parameters, handler, options);
            options?.signal?.addEventListener('abort', () => {
                eventOptions.stop();
            });
        });
    }
    /**
     * Resolves the list of tables that are used in a SQL query.
     * If tables are specified in the options, those are used directly.
     * Otherwise, analyzes the query using EXPLAIN to determine which tables are accessed.
     *
     * @param sql The SQL query to analyze
     * @param parameters Optional parameters for the SQL query
     * @param options Optional watch options that may contain explicit table list
     * @returns Array of table names that the query depends on
     */
    async resolveTables(sql, parameters, options) {
        const resolvedTables = options?.tables ? [...options.tables] : [];
        if (!options?.tables) {
            const explained = await this.getAll(`EXPLAIN ${sql}`, parameters);
            const rootPages = explained
                .filter((row) => row.opcode == 'OpenRead' && row.p3 == 0 && typeof row.p2 == 'number')
                .map((row) => row.p2);
            const tables = await this.getAll(`SELECT DISTINCT tbl_name FROM sqlite_master WHERE rootpage IN (SELECT json_each.value FROM json_each(?))`, [JSON.stringify(rootPages)]);
            for (const table of tables) {
                resolvedTables.push(table.tbl_name.replace(POWERSYNC_TABLE_MATCH, ''));
            }
        }
        return resolvedTables;
    }
    onChange(handlerOrOptions, maybeOptions) {
        if (handlerOrOptions && typeof handlerOrOptions === 'object' && 'onChange' in handlerOrOptions) {
            const handler = handlerOrOptions;
            const options = maybeOptions;
            return this.onChangeWithCallback(handler, options);
        }
        const options = handlerOrOptions;
        return this.onChangeWithAsyncGenerator(options);
    }
    /**
     * Invoke the provided callback on any changes to any of the specified tables.
     *
     * This is preferred over {@link watchWithCallback} when multiple queries need to be performed
     * together when data is changed.
     *
     * Note that the `onChange` callback member of the handler is required.
     *
     * @param handler Callbacks for handling change events and errors
     * @param options Options for configuring watch behavior
     * @returns A dispose function to stop watching for changes
     */
    onChangeWithCallback(handler, options) {
        const { onChange, onError = (e) => this.logger.error(e) } = handler ?? {};
        if (!onChange) {
            throw new Error('onChange is required');
        }
        const resolvedOptions = options ?? {};
        const watchedTables = new Set((resolvedOptions?.tables ?? []).flatMap((table) => [table, `ps_data__${table}`, `ps_data_local__${table}`]));
        const changedTables = new Set();
        const throttleMs = resolvedOptions.throttleMs ?? DEFAULT_WATCH_THROTTLE_MS;
        const executor = new ControlledExecutor(async (e) => {
            await onChange(e);
        });
        const flushTableUpdates = throttleTrailing(() => this.handleTableChanges(changedTables, watchedTables, (intersection) => {
            if (resolvedOptions?.signal?.aborted)
                return;
            executor.schedule({ changedTables: intersection });
        }), throttleMs);
        if (options?.triggerImmediate) {
            executor.schedule({ changedTables: [] });
        }
        const dispose = this.database.registerListener({
            tablesUpdated: async (update) => {
                try {
                    this.processTableUpdates(update, changedTables);
                    flushTableUpdates();
                }
                catch (error) {
                    onError?.(error);
                }
            }
        });
        resolvedOptions.signal?.addEventListener('abort', () => {
            executor.dispose();
            dispose();
        });
        return () => dispose();
    }
    /**
     * Create a Stream of changes to any of the specified tables.
     *
     * This is preferred over {@link watchWithAsyncGenerator} when multiple queries need to be performed
     * together when data is changed.
     *
     * Note: do not declare this as `async *onChange` as it will not work in React Native.
     *
     * @param options Options for configuring watch behavior
     * @returns An AsyncIterable that yields change events whenever the specified tables change
     */
    onChangeWithAsyncGenerator(options) {
        const resolvedOptions = options ?? {};
        return new domExports.EventIterator((eventOptions) => {
            const dispose = this.onChangeWithCallback({
                onChange: (event) => {
                    eventOptions.push(event);
                },
                onError: (error) => {
                    eventOptions.fail(error);
                }
            }, options);
            resolvedOptions.signal?.addEventListener('abort', () => {
                eventOptions.stop();
                // Maybe fail?
            });
            return () => dispose();
        });
    }
    handleTableChanges(changedTables, watchedTables, onDetectedChanges) {
        if (changedTables.size > 0) {
            const intersection = Array.from(changedTables.values()).filter((change) => watchedTables.has(change));
            if (intersection.length) {
                onDetectedChanges(intersection);
            }
        }
        changedTables.clear();
    }
    processTableUpdates(updateNotification, changedTables) {
        const tables = isBatchedUpdateNotification(updateNotification)
            ? updateNotification.tables
            : [updateNotification.table];
        for (const table of tables) {
            changedTables.add(table);
        }
    }
    /**
     * @ignore
     */
    async executeReadOnly(sql, params) {
        await this.waitForReady();
        return this.database.readLock((tx) => tx.execute(sql, params));
    }
}

class AbstractPowerSyncDatabaseOpenFactory {
    options;
    constructor(options) {
        this.options = options;
        options.logger = options.logger ?? Logger.get(`PowerSync ${this.options.dbFilename}`);
    }
    /**
     * Schema used for the local database.
     */
    get schema() {
        return this.options.schema;
    }
    generateOptions() {
        return {
            database: this.openDB(),
            ...this.options
        };
    }
    getInstance() {
        const options = this.generateOptions();
        return this.generateInstance(options);
    }
}

function runOnSchemaChange(callback, db, options) {
    const triggerWatchedQuery = () => {
        const abortController = new AbortController();
        let disposeSchemaListener = null;
        const stopWatching = () => {
            abortController.abort('Abort triggered');
            disposeSchemaListener?.();
            disposeSchemaListener = null;
            // Stop listening to upstream abort for this watch
            options?.signal?.removeEventListener('abort', stopWatching);
        };
        options?.signal?.addEventListener('abort', stopWatching);
        disposeSchemaListener = db.registerListener({
            schemaChanged: async () => {
                stopWatching();
                // Re trigger the watched query (recursively), setTimeout ensures that we don't modify the list of listeners while iterating through them
                setTimeout(() => triggerWatchedQuery(), 0);
            }
        });
        callback(abortController.signal);
    };
    triggerWatchedQuery();
}

function compilableQueryWatch(db, query, handler, options) {
    const { onResult, onError = (e) => { } } = handler ?? {};
    if (!onResult) {
        throw new Error('onResult is required');
    }
    const watchQuery = async (abortSignal) => {
        try {
            const toSql = query.compile();
            const resolvedTables = await db.resolveTables(toSql.sql, toSql.parameters, options);
            // Fetch initial data
            const result = await query.execute();
            onResult(result);
            db.onChangeWithCallback({
                onChange: async () => {
                    try {
                        const result = await query.execute();
                        onResult(result);
                    }
                    catch (error) {
                        onError(error);
                    }
                },
                onError
            }, {
                ...(options ?? {}),
                tables: resolvedTables,
                // Override the abort signal since we intercept it
                signal: abortSignal
            });
        }
        catch (error) {
            onError(error);
        }
    };
    runOnSchemaChange(watchQuery, db, options);
}

const MAX_OP_ID = '9223372036854775807';

class SqliteBucketStorage extends BaseObserver {
    db;
    logger;
    tableNames;
    _hasCompletedSync;
    updateListener;
    _clientId;
    constructor(db, logger = Logger.get('SqliteBucketStorage')) {
        super();
        this.db = db;
        this.logger = logger;
        this._hasCompletedSync = false;
        this.tableNames = new Set();
        this.updateListener = db.registerListener({
            tablesUpdated: (update) => {
                const tables = extractTableUpdates(update);
                if (tables.includes(PSInternalTable.CRUD)) {
                    this.iterateListeners((l) => l.crudUpdate?.());
                }
            }
        });
    }
    async init() {
        this._hasCompletedSync = false;
        const existingTableRows = await this.db.getAll(`SELECT name FROM sqlite_master WHERE type='table' AND name GLOB 'ps_data_*'`);
        for (const row of existingTableRows ?? []) {
            this.tableNames.add(row.name);
        }
    }
    async dispose() {
        this.updateListener?.();
    }
    async _getClientId() {
        const row = await this.db.get('SELECT powersync_client_id() as client_id');
        return row['client_id'];
    }
    getClientId() {
        if (this._clientId == null) {
            this._clientId = this._getClientId();
        }
        return this._clientId;
    }
    getMaxOpId() {
        return MAX_OP_ID;
    }
    /**
     * Reset any caches.
     */
    startSession() { }
    async getBucketStates() {
        const result = await this.db.getAll("SELECT name as bucket, cast(last_op as TEXT) as op_id FROM ps_buckets WHERE pending_delete = 0 AND name != '$local'");
        return result;
    }
    async getBucketOperationProgress() {
        const rows = await this.db.getAll('SELECT name, count_at_last, count_since_last FROM ps_buckets');
        return Object.fromEntries(rows.map((r) => [r.name, { atLast: r.count_at_last, sinceLast: r.count_since_last }]));
    }
    async saveSyncData(batch, fixedKeyFormat = false) {
        await this.writeTransaction(async (tx) => {
            for (const b of batch.buckets) {
                await tx.execute('INSERT INTO powersync_operations(op, data) VALUES(?, ?)', [
                    'save',
                    JSON.stringify({ buckets: [b.toJSON(fixedKeyFormat)] })
                ]);
                this.logger.debug(`Saved batch of data for  bucket: ${b.bucket}, operations: ${b.data.length}`);
            }
        });
    }
    async removeBuckets(buckets) {
        for (const bucket of buckets) {
            await this.deleteBucket(bucket);
        }
    }
    /**
     * Mark a bucket for deletion.
     */
    async deleteBucket(bucket) {
        await this.writeTransaction(async (tx) => {
            await tx.execute('INSERT INTO powersync_operations(op, data) VALUES(?, ?)', ['delete_bucket', bucket]);
        });
        this.logger.debug(`Done deleting bucket ${bucket}`);
    }
    async hasCompletedSync() {
        if (this._hasCompletedSync) {
            return true;
        }
        const r = await this.db.get(`SELECT powersync_last_synced_at() as synced_at`);
        const completed = r.synced_at != null;
        if (completed) {
            this._hasCompletedSync = true;
        }
        return completed;
    }
    async syncLocalDatabase(checkpoint, priority) {
        const r = await this.validateChecksums(checkpoint, priority);
        if (!r.checkpointValid) {
            this.logger.error('Checksums failed for', r.checkpointFailures);
            for (const b of r.checkpointFailures ?? []) {
                await this.deleteBucket(b);
            }
            return { ready: false, checkpointValid: false, checkpointFailures: r.checkpointFailures };
        }
        if (priority == null) {
            this.logger.debug(`Validated checksums checkpoint ${checkpoint.last_op_id}`);
        }
        else {
            this.logger.debug(`Validated checksums for partial checkpoint ${checkpoint.last_op_id}, priority ${priority}`);
        }
        let buckets = checkpoint.buckets;
        if (priority !== undefined) {
            buckets = buckets.filter((b) => hasMatchingPriority(priority, b));
        }
        const bucketNames = buckets.map((b) => b.bucket);
        await this.writeTransaction(async (tx) => {
            await tx.execute(`UPDATE ps_buckets SET last_op = ? WHERE name IN (SELECT json_each.value FROM json_each(?))`, [
                checkpoint.last_op_id,
                JSON.stringify(bucketNames)
            ]);
            if (priority == null && checkpoint.write_checkpoint) {
                await tx.execute("UPDATE ps_buckets SET last_op = ? WHERE name = '$local'", [checkpoint.write_checkpoint]);
            }
        });
        const valid = await this.updateObjectsFromBuckets(checkpoint, priority);
        if (!valid) {
            return { ready: false, checkpointValid: true };
        }
        return {
            ready: true,
            checkpointValid: true
        };
    }
    /**
     * Atomically update the local state to the current checkpoint.
     *
     * This includes creating new tables, dropping old tables, and copying data over from the oplog.
     */
    async updateObjectsFromBuckets(checkpoint, priority) {
        let arg = '';
        if (priority !== undefined) {
            const affectedBuckets = [];
            for (const desc of checkpoint.buckets) {
                if (hasMatchingPriority(priority, desc)) {
                    affectedBuckets.push(desc.bucket);
                }
            }
            arg = JSON.stringify({ priority, buckets: affectedBuckets });
        }
        return this.writeTransaction(async (tx) => {
            const { insertId: result } = await tx.execute('INSERT INTO powersync_operations(op, data) VALUES(?, ?)', [
                'sync_local',
                arg
            ]);
            if (result == 1) {
                if (priority == null) {
                    const bucketToCount = Object.fromEntries(checkpoint.buckets.map((b) => [b.bucket, b.count]));
                    // The two parameters could be replaced with one, but: https://github.com/powersync-ja/better-sqlite3/pull/6
                    const jsonBucketCount = JSON.stringify(bucketToCount);
                    await tx.execute("UPDATE ps_buckets SET count_since_last = 0, count_at_last = ?->name WHERE name != '$local' AND ?->name IS NOT NULL", [jsonBucketCount, jsonBucketCount]);
                }
                return true;
            }
            else {
                return false;
            }
        });
    }
    async validateChecksums(checkpoint, priority) {
        if (priority !== undefined) {
            // Only validate the buckets within the priority we care about
            const newBuckets = checkpoint.buckets.filter((cs) => hasMatchingPriority(priority, cs));
            checkpoint = { ...checkpoint, buckets: newBuckets };
        }
        const rs = await this.db.execute('SELECT powersync_validate_checkpoint(?) as result', [
            JSON.stringify({ ...checkpoint })
        ]);
        const resultItem = rs.rows?.item(0);
        if (!resultItem) {
            return {
                checkpointValid: false,
                ready: false,
                checkpointFailures: []
            };
        }
        const result = JSON.parse(resultItem['result']);
        if (result['valid']) {
            return { ready: true, checkpointValid: true };
        }
        else {
            return {
                checkpointValid: false,
                ready: false,
                checkpointFailures: result['failed_buckets']
            };
        }
    }
    async updateLocalTarget(cb) {
        const rs1 = await this.db.getAll("SELECT target_op FROM ps_buckets WHERE name = '$local' AND target_op = CAST(? as INTEGER)", [MAX_OP_ID]);
        if (!rs1.length) {
            // Nothing to update
            return false;
        }
        const rs = await this.db.getAll("SELECT seq FROM main.sqlite_sequence WHERE name = 'ps_crud'");
        if (!rs.length) {
            // Nothing to update
            return false;
        }
        const seqBefore = rs[0]['seq'];
        const opId = await cb();
        return this.writeTransaction(async (tx) => {
            const anyData = await tx.execute('SELECT 1 FROM ps_crud LIMIT 1');
            if (anyData.rows?.length) {
                // if isNotEmpty
                this.logger.debug(`New data uploaded since write checkpoint ${opId} - need new write checkpoint`);
                return false;
            }
            const rs = await tx.execute("SELECT seq FROM main.sqlite_sequence WHERE name = 'ps_crud'");
            if (!rs.rows?.length) {
                // assert isNotEmpty
                throw new Error('SQLite Sequence should not be empty');
            }
            const seqAfter = rs.rows?.item(0)['seq'];
            if (seqAfter != seqBefore) {
                this.logger.debug(`New data uploaded since write checpoint ${opId} - need new write checkpoint (sequence updated)`);
                // New crud data may have been uploaded since we got the checkpoint. Abort.
                return false;
            }
            this.logger.debug(`Updating target write checkpoint to ${opId}`);
            await tx.execute("UPDATE ps_buckets SET target_op = CAST(? as INTEGER) WHERE name='$local'", [opId]);
            return true;
        });
    }
    async nextCrudItem() {
        const next = await this.db.getOptional('SELECT * FROM ps_crud ORDER BY id ASC LIMIT 1');
        if (!next) {
            return;
        }
        return CrudEntry.fromRow(next);
    }
    async hasCrud() {
        const anyData = await this.db.getOptional('SELECT 1 FROM ps_crud LIMIT 1');
        return !!anyData;
    }
    /**
     * Get a batch of objects to send to the server.
     * When the objects are successfully sent to the server, call .complete()
     */
    async getCrudBatch(limit = 100) {
        if (!(await this.hasCrud())) {
            return null;
        }
        const crudResult = await this.db.getAll('SELECT * FROM ps_crud ORDER BY id ASC LIMIT ?', [limit]);
        const all = [];
        for (const row of crudResult) {
            all.push(CrudEntry.fromRow(row));
        }
        if (all.length === 0) {
            return null;
        }
        const last = all[all.length - 1];
        return {
            crud: all,
            haveMore: true,
            complete: async (writeCheckpoint) => {
                return this.writeTransaction(async (tx) => {
                    await tx.execute('DELETE FROM ps_crud WHERE id <= ?', [last.clientId]);
                    if (writeCheckpoint) {
                        const crudResult = await tx.execute('SELECT 1 FROM ps_crud LIMIT 1');
                        if (crudResult.rows?.length) {
                            await tx.execute("UPDATE ps_buckets SET target_op = CAST(? as INTEGER) WHERE name='$local'", [
                                writeCheckpoint
                            ]);
                        }
                    }
                    else {
                        await tx.execute("UPDATE ps_buckets SET target_op = CAST(? as INTEGER) WHERE name='$local'", [
                            this.getMaxOpId()
                        ]);
                    }
                });
            }
        };
    }
    async writeTransaction(callback, options) {
        return this.db.writeTransaction(callback, options);
    }
    /**
     * Set a target checkpoint.
     */
    async setTargetCheckpoint(checkpoint) {
        // No-op for now
    }
    async control(op, payload) {
        return await this.writeTransaction(async (tx) => {
            const [[raw]] = await tx.executeRaw('SELECT powersync_control(?, ?)', [op, payload]);
            return raw;
        });
    }
    async hasMigratedSubkeys() {
        const { r } = await this.db.get('SELECT EXISTS(SELECT * FROM ps_kv WHERE key = ?) as r', [
            SqliteBucketStorage._subkeyMigrationKey
        ]);
        return r != 0;
    }
    async migrateToFixedSubkeys() {
        await this.writeTransaction(async (tx) => {
            await tx.execute('UPDATE ps_oplog SET key = powersync_remove_duplicate_key_encoding(key);');
            await tx.execute('INSERT OR REPLACE INTO ps_kv (key, value) VALUES (?, ?);', [
                SqliteBucketStorage._subkeyMigrationKey,
                '1'
            ]);
        });
    }
    static _subkeyMigrationKey = 'powersync_js_migrated_subkeys';
}
function hasMatchingPriority(priority, bucket) {
    return bucket.priority != null && bucket.priority <= priority;
}

// TODO JSON
class SyncDataBatch {
    buckets;
    static fromJSON(json) {
        return new SyncDataBatch(json.buckets.map((bucket) => SyncDataBucket.fromRow(bucket)));
    }
    constructor(buckets) {
        this.buckets = buckets;
    }
}

// https://www.sqlite.org/lang_expr.html#castexpr
var ColumnType;
(function (ColumnType) {
    ColumnType["TEXT"] = "TEXT";
    ColumnType["INTEGER"] = "INTEGER";
    ColumnType["REAL"] = "REAL";
})(ColumnType || (ColumnType = {}));
const text = {
    type: ColumnType.TEXT
};
const integer = {
    type: ColumnType.INTEGER
};
const real = {
    type: ColumnType.REAL
};
// powersync-sqlite-core limits the number of column per table to 1999, due to internal SQLite limits.
// In earlier versions this was limited to 63.
const MAX_AMOUNT_OF_COLUMNS = 1999;
const column = {
    text,
    integer,
    real
};
class Column {
    options;
    constructor(options) {
        this.options = options;
    }
    get name() {
        return this.options.name;
    }
    get type() {
        return this.options.type;
    }
    toJSON() {
        return {
            name: this.name,
            type: this.type
        };
    }
}

const DEFAULT_INDEX_COLUMN_OPTIONS = {
    ascending: true
};
class IndexedColumn {
    options;
    static createAscending(column) {
        return new IndexedColumn({
            name: column,
            ascending: true
        });
    }
    constructor(options) {
        this.options = { ...DEFAULT_INDEX_COLUMN_OPTIONS, ...options };
    }
    get name() {
        return this.options.name;
    }
    get ascending() {
        return this.options.ascending;
    }
    toJSON(table) {
        return {
            name: this.name,
            ascending: this.ascending,
            type: table.columns.find((column) => column.name === this.name)?.type ?? ColumnType.TEXT
        };
    }
}

const DEFAULT_INDEX_OPTIONS = {
    columns: []
};
class Index {
    options;
    static createAscending(options, columnNames) {
        return new Index({
            ...options,
            columns: columnNames.map((name) => IndexedColumn.createAscending(name))
        });
    }
    constructor(options) {
        this.options = options;
        this.options = { ...DEFAULT_INDEX_OPTIONS, ...options };
    }
    get name() {
        return this.options.name;
    }
    get columns() {
        return this.options.columns ?? [];
    }
    toJSON(table) {
        return {
            name: this.name,
            columns: this.columns.map((c) => c.toJSON(table))
        };
    }
}

/**
 * Instructs PowerSync to sync data into a "raw" table.
 *
 * Since raw tables are not backed by JSON, running complex queries on them may be more efficient. Further, they allow
 * using client-side table and column constraints.
 *
 * To collect local writes to raw tables with PowerSync, custom triggers are required. See
 * {@link https://docs.powersync.com/usage/use-case-examples/raw-tables the documentation} for details and an example on
 * using raw tables.
 *
 * Note that raw tables are only supported when using the new `SyncClientImplementation.rust` sync client.
 *
 * @experimental Please note that this feature is experimental at the moment, and not covered by PowerSync semver or
 * stability guarantees.
 */
class RawTable {
    /**
     * The name of the table.
     *
     * This does not have to match the actual table name in the schema - {@link put} and {@link delete} are free to use
     * another table. Instead, this name is used by the sync client to recognize that operations on this table (as it
     * appears in the source / backend database) are to be handled specially.
     */
    name;
    put;
    delete;
    constructor(name, type) {
        this.name = name;
        this.put = type.put;
        this.delete = type.delete;
    }
}

/**
 * A schema is a collection of tables. It is used to define the structure of a database.
 */
class Schema {
    /*
      Only available when constructing with mapped typed definition columns
    */
    types;
    props;
    tables;
    rawTables;
    constructor(tables) {
        if (Array.isArray(tables)) {
            /*
              We need to validate that the tables have a name here because a user could pass in an array
              of Tables that don't have a name because they are using the V2 syntax.
              Therefore, 'convertToClassicTables' won't be called on the tables resulting in a runtime error.
            */
            for (const table of tables) {
                if (table.name === '') {
                    throw new Error("It appears you are trying to create a new Schema with an array instead of an object. Passing in an object instead of an array into 'new Schema()' may resolve your issue.");
                }
            }
            this.tables = tables;
        }
        else {
            // Update the table entries with the provided table name key
            this.props = Object.fromEntries(Object.entries(tables).map(([tableName, table]) => [tableName, table.copyWithName(tableName)]));
            this.tables = Object.values(this.props);
        }
        this.rawTables = [];
    }
    /**
     * Adds raw tables to this schema. Raw tables are identified by their name, but entirely managed by the application
     * developer instead of automatically by PowerSync.
     * Since raw tables are not backed by JSON, running complex queries on them may be more efficient. Further, they allow
     * using client-side table and column constraints.
     * Note that raw tables are only supported when using the new `SyncClientImplementation.rust` sync client.
     *
     * @param tables An object of (table name, raw table definition) entries.
     * @experimental Note that the raw tables API is still experimental and may change in the future.
     */
    withRawTables(tables) {
        for (const [name, rawTableDefinition] of Object.entries(tables)) {
            this.rawTables.push(new RawTable(name, rawTableDefinition));
        }
    }
    validate() {
        for (const table of this.tables) {
            table.validate();
        }
    }
    toJSON() {
        return {
            tables: this.tables.map((t) => t.toJSON()),
            raw_tables: this.rawTables
        };
    }
}

const DEFAULT_TABLE_OPTIONS = {
    indexes: [],
    insertOnly: false,
    localOnly: false,
    trackPrevious: false,
    trackMetadata: false,
    ignoreEmptyUpdates: false
};
const InvalidSQLCharacters = /["'%,.#\s[\]]/;
class Table {
    options;
    _mappedColumns;
    static createLocalOnly(options) {
        return new Table({ ...options, localOnly: true, insertOnly: false });
    }
    static createInsertOnly(options) {
        return new Table({ ...options, localOnly: false, insertOnly: true });
    }
    /**
     * Create a table.
     * @deprecated This was only only included for TableV2 and is no longer necessary.
     * Prefer to use new Table() directly.
     *
     * TODO remove in the next major release.
     */
    static createTable(name, table) {
        return new Table({
            name,
            columns: table.columns,
            indexes: table.indexes,
            localOnly: table.options.localOnly,
            insertOnly: table.options.insertOnly,
            viewName: table.options.viewName
        });
    }
    constructor(optionsOrColumns, v2Options) {
        if (this.isTableV1(optionsOrColumns)) {
            this.initTableV1(optionsOrColumns);
        }
        else {
            this.initTableV2(optionsOrColumns, v2Options);
        }
    }
    copyWithName(name) {
        return new Table({
            ...this.options,
            name
        });
    }
    isTableV1(arg) {
        return 'columns' in arg && Array.isArray(arg.columns);
    }
    initTableV1(options) {
        this.options = {
            ...options,
            indexes: options.indexes || []
        };
        this.applyDefaultOptions();
    }
    initTableV2(columns, options) {
        const convertedColumns = Object.entries(columns).map(([name, columnInfo]) => new Column({ name, type: columnInfo.type }));
        const convertedIndexes = Object.entries(options?.indexes ?? {}).map(([name, columnNames]) => new Index({
            name,
            columns: columnNames.map((name) => new IndexedColumn({
                name: name.replace(/^-/, ''),
                ascending: !name.startsWith('-')
            }))
        }));
        this.options = {
            name: '',
            columns: convertedColumns,
            indexes: convertedIndexes,
            viewName: options?.viewName,
            insertOnly: options?.insertOnly,
            localOnly: options?.localOnly,
            trackPrevious: options?.trackPrevious,
            trackMetadata: options?.trackMetadata,
            ignoreEmptyUpdates: options?.ignoreEmptyUpdates
        };
        this.applyDefaultOptions();
        this._mappedColumns = columns;
    }
    applyDefaultOptions() {
        this.options.insertOnly ??= DEFAULT_TABLE_OPTIONS.insertOnly;
        this.options.localOnly ??= DEFAULT_TABLE_OPTIONS.localOnly;
        this.options.trackPrevious ??= DEFAULT_TABLE_OPTIONS.trackPrevious;
        this.options.trackMetadata ??= DEFAULT_TABLE_OPTIONS.trackMetadata;
        this.options.ignoreEmptyUpdates ??= DEFAULT_TABLE_OPTIONS.ignoreEmptyUpdates;
    }
    get name() {
        return this.options.name;
    }
    get viewNameOverride() {
        return this.options.viewName;
    }
    get viewName() {
        return this.viewNameOverride ?? this.name;
    }
    get columns() {
        return this.options.columns;
    }
    get columnMap() {
        return (this._mappedColumns ??
            this.columns.reduce((hash, column) => {
                hash[column.name] = { type: column.type ?? ColumnType.TEXT };
                return hash;
            }, {}));
    }
    get indexes() {
        return this.options.indexes ?? [];
    }
    get localOnly() {
        return this.options.localOnly;
    }
    get insertOnly() {
        return this.options.insertOnly;
    }
    get trackPrevious() {
        return this.options.trackPrevious;
    }
    get trackMetadata() {
        return this.options.trackMetadata;
    }
    get ignoreEmptyUpdates() {
        return this.options.ignoreEmptyUpdates;
    }
    get internalName() {
        if (this.options.localOnly) {
            return `ps_data_local__${this.name}`;
        }
        return `ps_data__${this.name}`;
    }
    get validName() {
        if (InvalidSQLCharacters.test(this.name)) {
            return false;
        }
        if (this.viewNameOverride != null && InvalidSQLCharacters.test(this.viewNameOverride)) {
            return false;
        }
        return true;
    }
    validate() {
        if (InvalidSQLCharacters.test(this.name)) {
            throw new Error(`Invalid characters in table name: ${this.name}`);
        }
        if (this.viewNameOverride && InvalidSQLCharacters.test(this.viewNameOverride)) {
            throw new Error(`Invalid characters in view name: ${this.viewNameOverride}`);
        }
        if (this.columns.length > MAX_AMOUNT_OF_COLUMNS) {
            throw new Error(`Table has too many columns. The maximum number of columns is ${MAX_AMOUNT_OF_COLUMNS}.`);
        }
        if (this.trackMetadata && this.localOnly) {
            throw new Error(`Can't include metadata for local-only tables.`);
        }
        if (this.trackPrevious != false && this.localOnly) {
            throw new Error(`Can't include old values for local-only tables.`);
        }
        const columnNames = new Set();
        columnNames.add('id');
        for (const column of this.columns) {
            const { name: columnName } = column;
            if (column.name === 'id') {
                throw new Error(`An id column is automatically added, custom id columns are not supported`);
            }
            if (columnNames.has(columnName)) {
                throw new Error(`Duplicate column ${columnName}`);
            }
            if (InvalidSQLCharacters.test(columnName)) {
                throw new Error(`Invalid characters in column name: ${column.name}`);
            }
            columnNames.add(columnName);
        }
        const indexNames = new Set();
        for (const index of this.indexes) {
            if (indexNames.has(index.name)) {
                throw new Error(`Duplicate index ${index.name}`);
            }
            if (InvalidSQLCharacters.test(index.name)) {
                throw new Error(`Invalid characters in index name: ${index.name}`);
            }
            for (const column of index.columns) {
                if (!columnNames.has(column.name)) {
                    throw new Error(`Column ${column.name} not found for index ${index.name}`);
                }
            }
            indexNames.add(index.name);
        }
    }
    toJSON() {
        const trackPrevious = this.trackPrevious;
        return {
            name: this.name,
            view_name: this.viewName,
            local_only: this.localOnly,
            insert_only: this.insertOnly,
            include_old: trackPrevious && (trackPrevious.columns ?? true),
            include_old_only_when_changed: typeof trackPrevious == 'object' && trackPrevious.onlyWhenChanged == true,
            include_metadata: this.trackMetadata,
            ignore_empty_update: this.ignoreEmptyUpdates,
            columns: this.columns.map((c) => c.toJSON()),
            indexes: this.indexes.map((e) => e.toJSON(this))
        };
    }
}

/**
  Generate a new table from the columns and indexes
  @deprecated You should use {@link Table} instead as it now allows TableV2 syntax.
  This will be removed in the next major release.
*/
class TableV2 extends Table {
}

function sanitizeString(input) {
    return `'${input.replace(/'/g, "''")}'`;
}
/**
 * Helper function for sanitizing UUID input strings.
 * Typically used with {@link sanitizeSQL}.
 */
function sanitizeUUID(uuid) {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    const isValid = uuidRegex.test(uuid);
    if (!isValid) {
        throw new Error(`${uuid} is not a valid UUID`);
    }
    return uuid;
}
/**
 * SQL string template function for {@link TrackDiffOptions#when} and {@link CreateDiffTriggerOptions#when}.
 *
 * This function performs basic string interpolation for SQLite WHEN clauses.
 *
 * **String placeholders:**
 * - All string values passed as placeholders are automatically wrapped in single quotes (`'`).
 * - Do not manually wrap placeholders in single quotes in your template string; the function will handle quoting and escaping for you.
 * - Any single quotes within the string value are escaped by doubling them (`''`), as required by SQL syntax.
 *
 * **Other types:**
 * - `null` and `undefined` are converted to SQL `NULL`.
 * - Objects are stringified using `JSON.stringify()` and wrapped in single quotes, with any single quotes inside the stringified value escaped.
 * - Numbers and other primitive types are inserted directly.
 *
 * **Usage example:**
 * ```typescript
 * const myID = "O'Reilly";
 * const clause = sanitizeSQL`New.id = ${myID}`;
 * // Result: "New.id = 'O''Reilly'"
 * ```
 *
 * Avoid manually quoting placeholders:
 * ```typescript
 * // Incorrect:
 * sanitizeSQL`New.id = '${myID}'` // Produces double quotes: New.id = ''O''Reilly''
 * ```
 */
function sanitizeSQL(strings, ...values) {
    let result = '';
    strings.forEach((str, i) => {
        result += str;
        if (i < values.length) {
            // For SQL, escape single quotes in string values
            const value = values[i];
            if (typeof value == 'string') {
                result += sanitizeString(value);
            }
            else if (value == null) {
                result += 'NULL';
            }
            else if (typeof value == 'object') {
                // Stringify the object and escape single quotes in the result
                const stringified = JSON.stringify(value);
                result += sanitizeString(stringified);
            }
            else {
                result += value;
            }
        }
    });
    return result;
}

/**
 * Performs a {@link AbstractPowerSyncDatabase.getAll} operation for a watched query.
 */
class GetAllQuery {
    options;
    constructor(options) {
        this.options = options;
    }
    compile() {
        return {
            sql: this.options.sql,
            parameters: this.options.parameters ?? []
        };
    }
    async execute(options) {
        const { db } = options;
        const { sql, parameters = [] } = this.compile();
        const rawResult = await db.getAll(sql, [...parameters]);
        if (this.options.mapper) {
            return rawResult.map(this.options.mapper);
        }
        return rawResult;
    }
}

const TypedLogger = Logger;
const LogLevel = {
    TRACE: TypedLogger.TRACE,
    DEBUG: TypedLogger.DEBUG,
    INFO: TypedLogger.INFO,
    TIME: TypedLogger.TIME,
    WARN: TypedLogger.WARN,
    ERROR: TypedLogger.ERROR,
    OFF: TypedLogger.OFF
};
/**
 * Retrieves the base (default) logger instance.
 *
 * This base logger controls the default logging configuration and is shared
 * across all loggers created with `createLogger`. Adjusting settings on this
 * base logger affects all loggers derived from it unless explicitly overridden.
 *
 */
function createBaseLogger() {
    return Logger;
}
/**
 * Creates and configures a new named logger based on the base logger.
 *
 * Named loggers allow specific modules or areas of your application to have
 * their own logging levels and behaviors. These loggers inherit configuration
 * from the base logger by default but can override settings independently.
 */
function createLogger(name, options = {}) {
    const logger = Logger.get(name);
    if (options.logLevel) {
        logger.setLevel(options.logLevel);
    }
    return logger;
}

const parseQuery = (query, parameters) => {
    let sqlStatement;
    if (typeof query == 'string') {
        sqlStatement = query;
    }
    else {
        const hasAdditionalParameters = parameters.length > 0;
        if (hasAdditionalParameters) {
            throw new Error('You cannot pass parameters to a compiled query.');
        }
        const compiled = query.compile();
        sqlStatement = compiled.sql;
        parameters = compiled.parameters;
    }
    return { sqlStatement, parameters: parameters };
};


//# sourceMappingURL=bundle.mjs.map


/***/ }),

/***/ "./lib/src/db/adapters/wa-sqlite/WASQLiteConnection.js":
/*!*************************************************************!*\
  !*** ./lib/src/db/adapters/wa-sqlite/WASQLiteConnection.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncWASQLiteModuleFactory: () => (/* binding */ AsyncWASQLiteModuleFactory),
/* harmony export */   DEFAULT_MODULE_FACTORIES: () => (/* binding */ DEFAULT_MODULE_FACTORIES),
/* harmony export */   MultiCipherAsyncWASQLiteModuleFactory: () => (/* binding */ MultiCipherAsyncWASQLiteModuleFactory),
/* harmony export */   MultiCipherSyncWASQLiteModuleFactory: () => (/* binding */ MultiCipherSyncWASQLiteModuleFactory),
/* harmony export */   SyncWASQLiteModuleFactory: () => (/* binding */ SyncWASQLiteModuleFactory),
/* harmony export */   WASQLiteVFS: () => (/* binding */ WASQLiteVFS),
/* harmony export */   WASqliteConnection: () => (/* binding */ WASqliteConnection)
/* harmony export */ });
/* harmony import */ var _journeyapps_wa_sqlite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @journeyapps/wa-sqlite */ "../../node_modules/@journeyapps/wa-sqlite/src/sqlite-api.js");
/* harmony import */ var _powersync_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @powersync/common */ "../common/dist/bundle.mjs");
/* harmony import */ var async_mutex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async-mutex */ "../../node_modules/async-mutex/index.mjs");



/**
 * List of currently tested virtual filesystems
 */
var WASQLiteVFS;
(function (WASQLiteVFS) {
    WASQLiteVFS["IDBBatchAtomicVFS"] = "IDBBatchAtomicVFS";
    WASQLiteVFS["OPFSCoopSyncVFS"] = "OPFSCoopSyncVFS";
    WASQLiteVFS["AccessHandlePoolVFS"] = "AccessHandlePoolVFS";
})(WASQLiteVFS || (WASQLiteVFS = {}));
/**
 * @internal
 */
const AsyncWASQLiteModuleFactory = async () => {
    const { default: factory } = await __webpack_require__.e(/*! import() */ "node_modules_journeyapps_wa-sqlite_dist_wa-sqlite-async_mjs").then(__webpack_require__.bind(__webpack_require__, /*! @journeyapps/wa-sqlite/dist/wa-sqlite-async.mjs */ "../../node_modules/@journeyapps/wa-sqlite/dist/wa-sqlite-async.mjs"));
    return factory();
};
/**
 * @internal
 */
const MultiCipherAsyncWASQLiteModuleFactory = async () => {
    const { default: factory } = await __webpack_require__.e(/*! import() */ "node_modules_journeyapps_wa-sqlite_dist_mc-wa-sqlite-async_mjs").then(__webpack_require__.bind(__webpack_require__, /*! @journeyapps/wa-sqlite/dist/mc-wa-sqlite-async.mjs */ "../../node_modules/@journeyapps/wa-sqlite/dist/mc-wa-sqlite-async.mjs"));
    return factory();
};
/**
 * @internal
 */
const SyncWASQLiteModuleFactory = async () => {
    const { default: factory } = await __webpack_require__.e(/*! import() */ "node_modules_journeyapps_wa-sqlite_dist_wa-sqlite_mjs").then(__webpack_require__.bind(__webpack_require__, /*! @journeyapps/wa-sqlite/dist/wa-sqlite.mjs */ "../../node_modules/@journeyapps/wa-sqlite/dist/wa-sqlite.mjs"));
    return factory();
};
/**
 * @internal
 */
const MultiCipherSyncWASQLiteModuleFactory = async () => {
    const { default: factory } = await __webpack_require__.e(/*! import() */ "node_modules_journeyapps_wa-sqlite_dist_mc-wa-sqlite_mjs").then(__webpack_require__.bind(__webpack_require__, /*! @journeyapps/wa-sqlite/dist/mc-wa-sqlite.mjs */ "../../node_modules/@journeyapps/wa-sqlite/dist/mc-wa-sqlite.mjs"));
    return factory();
};
/**
 * @internal
 */
const DEFAULT_MODULE_FACTORIES = {
    [WASQLiteVFS.IDBBatchAtomicVFS]: async (options) => {
        let module;
        if (options.encryptionKey) {
            module = await MultiCipherAsyncWASQLiteModuleFactory();
        }
        else {
            module = await AsyncWASQLiteModuleFactory();
        }
        const { IDBBatchAtomicVFS } = await __webpack_require__.e(/*! import() */ "node_modules_journeyapps_wa-sqlite_src_examples_IDBBatchAtomicVFS_js").then(__webpack_require__.bind(__webpack_require__, /*! @journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js */ "../../node_modules/@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js"));
        return {
            module,
            // @ts-expect-error The types for this static method are missing upstream
            vfs: await IDBBatchAtomicVFS.create(options.dbFileName, module, { lockPolicy: 'exclusive' })
        };
    },
    [WASQLiteVFS.AccessHandlePoolVFS]: async (options) => {
        let module;
        if (options.encryptionKey) {
            module = await MultiCipherSyncWASQLiteModuleFactory();
        }
        else {
            module = await SyncWASQLiteModuleFactory();
        }
        // @ts-expect-error The types for this static method are missing upstream
        const { AccessHandlePoolVFS } = await __webpack_require__.e(/*! import() */ "node_modules_journeyapps_wa-sqlite_src_examples_AccessHandlePoolVFS_js").then(__webpack_require__.bind(__webpack_require__, /*! @journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js */ "../../node_modules/@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js"));
        return {
            module,
            vfs: await AccessHandlePoolVFS.create(options.dbFileName, module)
        };
    },
    [WASQLiteVFS.OPFSCoopSyncVFS]: async (options) => {
        let module;
        if (options.encryptionKey) {
            module = await MultiCipherSyncWASQLiteModuleFactory();
        }
        else {
            module = await SyncWASQLiteModuleFactory();
        }
        // @ts-expect-error The types for this static method are missing upstream
        const { OPFSCoopSyncVFS } = await __webpack_require__.e(/*! import() */ "node_modules_journeyapps_wa-sqlite_src_examples_OPFSCoopSyncVFS_js").then(__webpack_require__.bind(__webpack_require__, /*! @journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js */ "../../node_modules/@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js"));
        return {
            module,
            vfs: await OPFSCoopSyncVFS.create(options.dbFileName, module)
        };
    }
};
/**
 * @internal
 * WA-SQLite connection which directly interfaces with WA-SQLite.
 * This is usually instantiated inside a worker.
 */
class WASqliteConnection extends _powersync_common__WEBPACK_IMPORTED_MODULE_1__.BaseObserver {
    options;
    _sqliteAPI = null;
    _dbP = null;
    _moduleFactory;
    updatedTables;
    updateTimer;
    statementMutex;
    broadcastChannel;
    /**
     * Unique id for this specific connection. This is used to prevent broadcast table change
     * notification loops.
     */
    connectionId;
    _holdCounter;
    _holdId;
    constructor(options) {
        super();
        this.options = options;
        this.updatedTables = new Set();
        this.updateTimer = null;
        this.broadcastChannel = null;
        this.connectionId = new Date().valueOf() + Math.random();
        this.statementMutex = new async_mutex__WEBPACK_IMPORTED_MODULE_2__.Mutex();
        this._moduleFactory = DEFAULT_MODULE_FACTORIES[this.options.vfs];
        this._holdCounter = 0;
        this._holdId = null;
    }
    /**
     * Gets the id for the current hold.
     * This can be used to check for invalid states.
     */
    get currentHoldId() {
        return this._holdId;
    }
    get sqliteAPI() {
        if (!this._sqliteAPI) {
            throw new Error(`Initialization has not completed`);
        }
        return this._sqliteAPI;
    }
    get dbP() {
        if (!this._dbP) {
            throw new Error(`Initialization has not completed`);
        }
        return this._dbP;
    }
    /**
     * Checks if the database connection is in autocommit mode.
     * @returns true if in autocommit mode, false if in a transaction
     */
    async isAutoCommit() {
        return this.sqliteAPI.get_autocommit(this.dbP) != 0;
    }
    async markHold() {
        const previousHoldId = this._holdId;
        this._holdId = `${++this._holdCounter}`;
        if (previousHoldId) {
            await this.iterateAsyncListeners(async (cb) => cb.holdOverwritten?.(previousHoldId));
        }
        return this._holdId;
    }
    async releaseHold(holdId) {
        if (holdId != this._holdId) {
            throw new Error(`Invalid hold state, expected ${this._holdId} but got ${holdId}`);
        }
        this._holdId = null;
    }
    async openDB() {
        this._dbP = await this.sqliteAPI.open_v2(this.options.dbFilename);
        return this._dbP;
    }
    async executeEncryptionPragma() {
        if (this.options.encryptionKey) {
            await this.executeSingleStatement(`PRAGMA key = "${this.options.encryptionKey}"`);
        }
        return;
    }
    async openSQLiteAPI() {
        const { module, vfs } = await this._moduleFactory({
            dbFileName: this.options.dbFilename,
            encryptionKey: this.options.encryptionKey
        });
        const sqlite3 = _journeyapps_wa_sqlite__WEBPACK_IMPORTED_MODULE_0__.Factory(module);
        sqlite3.vfs_register(vfs, true);
        /**
         * Register the PowerSync core SQLite extension
         */
        module.ccall('powersync_init_static', 'int', []);
        /**
         * Create the multiple cipher vfs if an encryption key is provided
         */
        if (this.options.encryptionKey) {
            const createResult = module.ccall('sqlite3mc_vfs_create', 'int', ['string', 'int'], [this.options.dbFilename, 1]);
            if (createResult !== 0) {
                throw new Error('Failed to create multiple cipher vfs, Database encryption will not work');
            }
        }
        return sqlite3;
    }
    registerBroadcastListeners() {
        this.broadcastChannel = new BroadcastChannel(`${this.options.dbFilename}-table-updates`);
        this.broadcastChannel.addEventListener('message', (event) => {
            const data = event.data;
            if (this.connectionId == data.connectionId) {
                // Ignore messages from the same connection
                return;
            }
            // Ensuring that we don't rebroadcast the same message
            this.queueTableUpdate(data.changedTables, false);
        });
    }
    queueTableUpdate(tableNames, shouldBroadcast = true) {
        tableNames.forEach((tableName) => this.updatedTables.add(tableName));
        if (this.updateTimer == null) {
            this.updateTimer = setTimeout(() => this.fireUpdates(shouldBroadcast), 0);
        }
    }
    async init() {
        this._sqliteAPI = await this.openSQLiteAPI();
        await this.openDB();
        this.registerBroadcastListeners();
        await this.executeSingleStatement(`PRAGMA temp_store = ${this.options.temporaryStorage};`);
        await this.executeEncryptionPragma();
        await this.executeSingleStatement(`PRAGMA cache_size = -${this.options.cacheSizeKb};`);
        this.sqliteAPI.update_hook(this.dbP, (updateType, dbName, tableName) => {
            if (!tableName) {
                return;
            }
            const changedTables = new Set([tableName]);
            this.queueTableUpdate(changedTables);
        });
    }
    async getConfig() {
        return this.options;
    }
    fireUpdates(shouldBroadcast = true) {
        this.updateTimer = null;
        const event = { tables: [...this.updatedTables], groupedUpdates: {}, rawUpdates: [] };
        // Share to other connections
        if (shouldBroadcast) {
            this.broadcastChannel.postMessage({
                changedTables: this.updatedTables,
                connectionId: this.connectionId
            });
        }
        this.updatedTables.clear();
        this.iterateListeners((cb) => cb.tablesUpdated?.(event));
    }
    /**
     * This executes SQL statements in a batch.
     */
    async executeBatch(sql, bindings) {
        return this.acquireExecuteLock(async () => {
            let affectedRows = 0;
            try {
                await this.executeSingleStatement('BEGIN TRANSACTION');
                const wrappedBindings = bindings ? bindings : [];
                for await (const stmt of this.sqliteAPI.statements(this.dbP, sql)) {
                    if (stmt === null) {
                        return {
                            rowsAffected: 0,
                            rows: { _array: [], length: 0 }
                        };
                    }
                    //Prepare statement once
                    for (const binding of wrappedBindings) {
                        // TODO not sure why this is needed currently, but booleans break
                        for (let i = 0; i < binding.length; i++) {
                            const b = binding[i];
                            if (typeof b == 'boolean') {
                                binding[i] = b ? 1 : 0;
                            }
                        }
                        if (bindings) {
                            this.sqliteAPI.bind_collection(stmt, binding);
                        }
                        const result = await this.sqliteAPI.step(stmt);
                        if (result === _journeyapps_wa_sqlite__WEBPACK_IMPORTED_MODULE_0__.SQLITE_DONE) {
                            //The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero.
                            affectedRows += this.sqliteAPI.changes(this.dbP);
                        }
                        this.sqliteAPI.reset(stmt);
                    }
                }
                await this.executeSingleStatement('COMMIT');
            }
            catch (err) {
                await this.executeSingleStatement('ROLLBACK');
                return {
                    rowsAffected: 0,
                    rows: { _array: [], length: 0 }
                };
            }
            const result = {
                rowsAffected: affectedRows,
                rows: { _array: [], length: 0 }
            };
            return result;
        });
    }
    /**
     * This executes single SQL statements inside a requested lock.
     */
    async execute(sql, bindings) {
        // Running multiple statements on the same connection concurrently should not be allowed
        return this.acquireExecuteLock(async () => {
            return this.executeSingleStatement(sql, bindings);
        });
    }
    async executeRaw(sql, bindings) {
        return this.acquireExecuteLock(async () => {
            return this.executeSingleStatementRaw(sql, bindings);
        });
    }
    async close() {
        this.broadcastChannel?.close();
        await this.sqliteAPI.close(this.dbP);
    }
    async registerOnTableChange(callback) {
        return this.registerListener({
            tablesUpdated: (event) => callback(event)
        });
    }
    /**
     * This requests a lock for executing statements.
     * Should only be used internally.
     */
    acquireExecuteLock = (callback) => {
        return this.statementMutex.runExclusive(callback);
    };
    /**
     * This executes a single statement using SQLite3.
     */
    async executeSingleStatement(sql, bindings) {
        const results = await this._execute(sql, bindings);
        const rows = [];
        for (const resultSet of results) {
            for (const row of resultSet.rows) {
                const outRow = {};
                resultSet.columns.forEach((key, index) => {
                    outRow[key] = row[index];
                });
                rows.push(outRow);
            }
        }
        const result = {
            insertId: this.sqliteAPI.last_insert_id(this.dbP),
            rowsAffected: this.sqliteAPI.changes(this.dbP),
            rows: {
                _array: rows,
                length: rows.length
            }
        };
        return result;
    }
    /**
     * This executes a single statement using SQLite3 and returns the results as an array of arrays.
     */
    async executeSingleStatementRaw(sql, bindings) {
        const results = await this._execute(sql, bindings);
        return results.flatMap((resultset) => resultset.rows.map((row) => resultset.columns.map((_, index) => row[index])));
    }
    async _execute(sql, bindings) {
        const results = [];
        for await (const stmt of this.sqliteAPI.statements(this.dbP, sql)) {
            let columns;
            const wrappedBindings = bindings ? [bindings] : [[]];
            for (const binding of wrappedBindings) {
                // TODO not sure why this is needed currently, but booleans break
                binding.forEach((b, index, arr) => {
                    if (typeof b == 'boolean') {
                        arr[index] = b ? 1 : 0;
                    }
                });
                this.sqliteAPI.reset(stmt);
                if (bindings) {
                    this.sqliteAPI.bind_collection(stmt, binding);
                }
                const rows = [];
                while ((await this.sqliteAPI.step(stmt)) === _journeyapps_wa_sqlite__WEBPACK_IMPORTED_MODULE_0__.SQLITE_ROW) {
                    const row = this.sqliteAPI.row(stmt);
                    rows.push(row);
                }
                columns = columns ?? this.sqliteAPI.column_names(stmt);
                if (columns.length) {
                    results.push({ columns, rows });
                }
            }
            // When binding parameters, only a single statement is executed.
            if (bindings) {
                break;
            }
        }
        return results;
    }
}


/***/ }),

/***/ "./lib/src/shared/navigator.js":
/*!*************************************!*\
  !*** ./lib/src/shared/navigator.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNavigatorLocks: () => (/* binding */ getNavigatorLocks)
/* harmony export */ });
const getNavigatorLocks = () => {
    if ('locks' in navigator && navigator.locks) {
        return navigator.locks;
    }
    throw new Error('Navigator locks are not available in an insecure context. Use a secure context such as HTTPS or http://localhost.');
};


/***/ }),

/***/ "./lib/src/worker/db/SharedWASQLiteConnection.js":
/*!*******************************************************!*\
  !*** ./lib/src/worker/db/SharedWASQLiteConnection.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SharedWASQLiteConnection: () => (/* binding */ SharedWASQLiteConnection)
/* harmony export */ });
class SharedWASQLiteConnection {
    options;
    isClosing;
    // Keeps track if this current hold if the shared connection has a hold
    activeHoldId;
    constructor(options) {
        this.options = options;
        // Add this client ID to the set of known clients
        this.clientIds.add(options.clientId);
        this.isClosing = false;
        this.activeHoldId = null;
    }
    get logger() {
        return this.options.logger;
    }
    get dbEntry() {
        return this.options.dbMap.get(this.options.dbFilename);
    }
    get connection() {
        return this.dbEntry.db;
    }
    get clientIds() {
        return this.dbEntry.clientIds;
    }
    async init() {
        // No-op since the connection is already initialized when it was created
    }
    async markHold() {
        this.activeHoldId = await this.connection.markHold();
        return this.activeHoldId;
    }
    async releaseHold(id) {
        try {
            await this.connection.releaseHold(id);
        }
        finally {
            this.activeHoldId = null;
        }
    }
    async isAutoCommit() {
        return this.connection.isAutoCommit();
    }
    /**
     * Handles closing of a shared connection.
     * The connection is only closed if there are no active clients using it.
     */
    async close() {
        // This prevents further statements on this connection from being executed
        this.isClosing = true;
        const { clientIds, logger } = this;
        const { clientId, dbFilename, dbMap } = this.options;
        logger.debug(`Close requested from client ${clientId} of ${[...clientIds]}`);
        clientIds.delete(clientId);
        if (this.activeHoldId) {
            // We can't cleanup here since we're not in a lock context.
            // The cleanup will occur once a new hold is acquired.
            this.logger.info(`Hold ${this.activeHoldId} was still active when the connection was closed. Cleanup will occur once a new hold is acquired.`);
        }
        if (clientIds.size == 0) {
            logger.debug(`Closing connection to ${this.options}.`);
            const connection = this.connection;
            dbMap.delete(dbFilename);
            await connection.close();
            return;
        }
        logger.debug(`Connection to ${dbFilename} not closed yet due to active clients.`);
        return;
    }
    async withClosing(action) {
        if (this.isClosing) {
            throw new Error('Connection is closing');
        }
        return action();
    }
    async execute(sql, params) {
        return this.withClosing(() => this.connection.execute(sql, params));
    }
    async executeRaw(sql, params) {
        return this.withClosing(() => this.connection.executeRaw(sql, params));
    }
    executeBatch(sql, params) {
        return this.withClosing(() => this.connection.executeBatch(sql, params));
    }
    registerOnTableChange(callback) {
        return this.connection.registerOnTableChange(callback);
    }
    getConfig() {
        return this.connection.getConfig();
    }
}


/***/ }),

/***/ "./lib/src/worker/db/WorkerWASQLiteConnection.js":
/*!*******************************************************!*\
  !*** ./lib/src/worker/db/WorkerWASQLiteConnection.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkerWASQLiteConnection: () => (/* binding */ WorkerWASQLiteConnection)
/* harmony export */ });
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! comlink */ "../../node_modules/comlink/dist/esm/comlink.mjs");
/* harmony import */ var _db_adapters_wa_sqlite_WASQLiteConnection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../db/adapters/wa-sqlite/WASQLiteConnection */ "./lib/src/db/adapters/wa-sqlite/WASQLiteConnection.js");


/**
 * A Small proxy wrapper around the WASqliteConnection.
 * This ensures that certain return types are properly proxied.
 */
class WorkerWASQLiteConnection extends _db_adapters_wa_sqlite_WASQLiteConnection__WEBPACK_IMPORTED_MODULE_0__.WASqliteConnection {
    async registerOnTableChange(callback) {
        // Proxy the callback remove function
        return comlink__WEBPACK_IMPORTED_MODULE_1__.proxy(await super.registerOnTableChange(callback));
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "worker/" + chunkId + ".umd.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "/../../";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"WASQLiteDB": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunksdk_web"] = self["webpackChunksdk_web"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!************************************************!*\
  !*** ./lib/src/worker/db/WASQLiteDB.worker.js ***!
  \************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _journeyapps_wa_sqlite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @journeyapps/wa-sqlite */ "../../node_modules/@journeyapps/wa-sqlite/src/sqlite-api.js");
/* harmony import */ var _powersync_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @powersync/common */ "../common/dist/bundle.mjs");
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! comlink */ "../../node_modules/comlink/dist/esm/comlink.mjs");
/* harmony import */ var _shared_navigator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/navigator */ "./lib/src/shared/navigator.js");
/* harmony import */ var _SharedWASQLiteConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SharedWASQLiteConnection */ "./lib/src/worker/db/SharedWASQLiteConnection.js");
/* harmony import */ var _WorkerWASQLiteConnection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WorkerWASQLiteConnection */ "./lib/src/worker/db/WorkerWASQLiteConnection.js");
/**
 * Supports both shared and dedicated workers, based on how the worker is constructed (new SharedWorker vs new Worker()).
 */






const baseLogger = (0,_powersync_common__WEBPACK_IMPORTED_MODULE_1__.createBaseLogger)();
baseLogger.useDefaults();
const logger = (0,_powersync_common__WEBPACK_IMPORTED_MODULE_1__.createLogger)('db-worker');
const DBMap = new Map();
const OPEN_DB_LOCK = 'open-wasqlite-db';
let nextClientId = 1;
const openDBShared = async (options) => {
    // Prevent multiple simultaneous opens from causing race conditions
    return (0,_shared_navigator__WEBPACK_IMPORTED_MODULE_2__.getNavigatorLocks)().request(OPEN_DB_LOCK, async () => {
        const clientId = nextClientId++;
        const { dbFilename, logLevel } = options;
        logger.setLevel(logLevel);
        if (!DBMap.has(dbFilename)) {
            const clientIds = new Set();
            // This format returns proxy objects for function callbacks
            const connection = new _WorkerWASQLiteConnection__WEBPACK_IMPORTED_MODULE_4__.WorkerWASQLiteConnection(options);
            await connection.init();
            connection.registerListener({
                holdOverwritten: async () => {
                    /**
                     * The previous hold has been overwritten, without being released.
                     * we need to cleanup any resources associated with it.
                     * We can perform a rollback to release any potential transactions that were started.
                     */
                    await connection.execute('ROLLBACK').catch(() => { });
                }
            });
            DBMap.set(dbFilename, {
                clientIds,
                db: connection
            });
        }
        // Associates this clientId with the shared connection entry
        const sharedConnection = new _SharedWASQLiteConnection__WEBPACK_IMPORTED_MODULE_3__.SharedWASQLiteConnection({
            dbMap: DBMap,
            dbFilename,
            clientId,
            logger
        });
        return comlink__WEBPACK_IMPORTED_MODULE_5__.proxy(sharedConnection);
    });
};
// Check if we're in a SharedWorker context
if (typeof SharedWorkerGlobalScope !== 'undefined') {
    const _self = self;
    _self.onconnect = function (event) {
        const port = event.ports[0];
        comlink__WEBPACK_IMPORTED_MODULE_5__.expose(openDBShared, port);
    };
}
else {
    // A dedicated worker can be shared externally
    comlink__WEBPACK_IMPORTED_MODULE_5__.expose(openDBShared);
}
addEventListener('unload', () => {
    Array.from(DBMap.values()).forEach(async (dbConnection) => {
        const { db } = dbConnection;
        db.close?.();
    });
});

})();

sdk_web = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=WASQLiteDB.umd.js.map
</file>

<file path="PWA_SETUP.md">
# Nile IVF Center - Offline-First PWA Setup

## Overview
The Nile IVF Center app has been upgraded to a fully functional **Offline-First Progressive Web App (PWA)** that works seamlessly without internet connectivity and automatically syncs data when online.

## ğŸš€ Features Implemented

### 1. **PWA Configuration**
- **Service Worker**: Caches all static assets and implements network-first strategy for API calls
- **Web App Manifest**: Defines app metadata, icons, and installation behavior
- **Offline Support**: App loads and functions completely offline
- **Auto-Updates**: Automatically updates when new versions are available

### 2. **Local Database (Dexie)**
- **IndexedDB Wrapper**: Fast, reliable local storage using Dexie
- **Schema Mirroring**: Local database structure matches Supabase tables
- **Sync Status Tracking**: Each record tracks sync status (pending/synced/error)

### 3. **Sync Engine**
- **Offline-First**: Data saved locally first, then synced to server
- **Background Sync**: Automatically syncs pending data when back online
- **Conflict Resolution**: Handles data conflicts gracefully
- **Retry Logic**: Failed syncs are retried with exponential backoff

### 4. **User Experience**
- **Instant Loading**: Data loads instantly from local cache
- **Offline Indicator**: Visual indicators for online/offline status
- **Sync Status**: Shows pending syncs and sync progress
- **Error Handling**: Graceful fallbacks when sync fails

## ğŸ“ File Structure

```
src/
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ localDb.ts          # Dexie database configuration
â”‚   â”œâ”€â”€ pwa.ts             # PWA registration and utilities
â”‚   â””â”€â”€ syncService.ts     # Sync manager implementation
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ syncService.ts     # Sync manager singleton
â”‚   â””â”€â”€ [existing services] # Modified to use sync manager
public/
â”œâ”€â”€ manifest.json          # PWA manifest
â”œâ”€â”€ sw.js                 # Service worker
â””â”€â”€ pwa-*.png            # App icons (see below)
```

## ğŸ–¼ï¸ Required App Icons

Place these icon files in the `public/` directory:

- `pwa-192x192.png` - 192x192px (required)
- `pwa-512x512.png` - 512x512px (required)
- `apple-touch-icon.png` - 180x180px (optional, for iOS)

**Icon Generation**: Use a tool like [PWA Asset Generator](https://github.com/elegantapp/pwa-asset-generator) or [RealFaviconGenerator](https://realfavicongenerator.net/) to generate these from your app logo.

## ğŸ”§ Installation & Setup

### 1. Install Dependencies
```bash
npm install dexie vite-plugin-pwa
```

### 2. Build for Production
```bash
npm run build
```

### 3. Deploy
The PWA will be automatically configured during the build process.

## ğŸ“± Installation Instructions

### For Users:
1. **Chrome/Edge**: Click the install icon in the address bar or use the "Install" menu
2. **Firefox**: Use the "Install This Site as an App" option in the page menu
3. **Safari (iOS)**: Use "Add to Home Screen" from the share menu
4. **Android**: Use "Add to Home Screen" from the browser menu

## ğŸ”„ How Offline Sync Works

### Data Flow:
1. **User Action**: User enters data (e.g., saves a patient)
2. **Local Save**: Data saved to IndexedDB immediately
3. **UI Update**: App shows data instantly (no loading)
4. **Background Sync**: When online, data synced to Supabase
5. **Status Update**: Local record marked as "synced"

### Conflict Resolution:
- **Server Wins**: If server data is newer, it overwrites local
- **Manual Merge**: Conflicts shown to user for resolution
- **Retry Failed**: Failed syncs automatically retried

## ğŸ› ï¸ Development Notes

### Testing Offline Mode:
1. Open DevTools â†’ Network tab
2. Check "Offline" to simulate no internet
3. Test all app functionality
4. Uncheck "Offline" to test sync

### Database Inspection:
- Chrome DevTools â†’ Application â†’ IndexedDB â†’ ClinicDB
- View local data and sync status

### Service Worker Debugging:
- Chrome DevTools â†’ Application â†’ Service Workers
- Check registration, updates, and cache status

## ğŸš¨ Important Considerations

### Data Security:
- **Local Encryption**: Sensitive data should be encrypted locally
- **Sync Security**: Ensure sync happens over HTTPS only
- **Auth Tokens**: Handle authentication token refresh offline

### Performance:
- **Database Size**: Monitor IndexedDB size limits (~50MB-1GB)
- **Sync Frequency**: Balance between real-time and battery usage
- **Cleanup**: Implement data cleanup for old records

### Error Handling:
- **Network Errors**: Graceful degradation when offline
- **Sync Failures**: Clear user communication about sync status
- **Data Loss**: Backup strategies for critical data

## ğŸ”® Future Enhancements

- **Push Notifications**: Real-time alerts for critical updates
- **Background Sync**: Periodic data synchronization
- **Conflict UI**: Visual conflict resolution interface
- **Data Export**: Offline data export capabilities
- **Multi-device Sync**: Sync across multiple devices

## ğŸ› Troubleshooting

### Common Issues:
1. **Service Worker Not Registering**: Check browser support and HTTPS
2. **Sync Not Working**: Verify network permissions and API endpoints
3. **Database Errors**: Clear IndexedDB and reinstall app
4. **Icons Not Showing**: Ensure correct file paths and formats

### Debug Commands:
```javascript
// Check PWA status
console.log('PWA Installed:', window.matchMedia('(display-mode: standalone)').matches);

// Check online status
console.log('Online:', navigator.onLine);

// Force sync
// syncManager.forceSync(); // When implemented
```

---

## ğŸ“ Support

For technical support or questions about the PWA implementation, contact the development team.

**Last Updated**: December 2025
**Version**: 1.0.0
</file>

<file path="QUICK_FIX.sql">
-- ============================================================================
-- SIMPLE QUICK FIX - Direct inserts with hardcoded IDs
-- ============================================================================

-- Delete old data first if exists
DELETE FROM visits WHERE id IN ('72345678-1234-1234-1234-123456789abc', '82345678-1234-1234-1234-123456789abc');
DELETE FROM ivf_cycles WHERE id IN ('52345678-1234-1234-1234-123456789abc', '62345678-1234-1234-1234-123456789abc');
DELETE FROM patients WHERE id IN ('22345678-1234-1234-1234-123456789abc', '32345678-1234-1234-1234-123456789abc', '42345678-1234-1234-1234-123456789abc');
DELETE FROM doctors WHERE id = '12345678-1234-1234-1234-123456789abc';

-- Add doctor
INSERT INTO doctors (id, user_id, email, name, specialization, phone)
VALUES ('12345678-1234-1234-1234-123456789abc', 'test-user-001', 'test@example.com', 'Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­', 'Ø£Ø®ØµØ§Ø¦ÙŠ Ø§Ù„Ø®ØµÙˆØ¨Ø©', '01000000000');

-- Add patients
INSERT INTO patients (id, name, age, phone, husband_name, history, doctor_id)
VALUES ('22345678-1234-1234-1234-123456789abc', 'ÙØ§Ø·Ù…Ø© Ø§Ø­Ù…Ø¯', 32, '01012345678', 'Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ', 'Ø¹Ø¯Ù… Ø§Ù„Ø­Ù…Ù„ 3 Ø³Ù†ÙˆØ§Øª', '12345678-1234-1234-1234-123456789abc');

INSERT INTO patients (id, name, age, phone, husband_name, history, doctor_id)
VALUES ('32345678-1234-1234-1234-123456789abc', 'Ø³Ø§Ø±Ø© Ù…Ø­Ù…ÙˆØ¯', 28, '01087654321', 'Ø£Ø­Ù…Ø¯ Ø­Ø³Ù†', 'ØªØ£Ø®Ø± Ø§Ù„Ø­Ù…Ù„ Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ', '12345678-1234-1234-1234-123456789abc');

INSERT INTO patients (id, name, age, phone, husband_name, history, doctor_id)
VALUES ('42345678-1234-1234-1234-123456789abc', 'Ù„ÙŠÙ„Ù‰ Ø®Ø§Ù„Ø¯', 35, '01098765432', 'Ø¹Ù…Ø± Ù…Ø­Ù…Ø¯', 'Ø£ÙƒÙŠØ§Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨Ø§ÙŠØ¶', '12345678-1234-1234-1234-123456789abc');

-- Add IVF cycles
INSERT INTO ivf_cycles (id, patient_id, doctor_id, protocol, status, start_date, assessment_data)
VALUES ('52345678-1234-1234-1234-123456789abc', '22345678-1234-1234-1234-123456789abc', '12345678-1234-1234-1234-123456789abc', 'Long Protocol', 'Active', CURRENT_DATE, '{"test": "data"}');

INSERT INTO ivf_cycles (id, patient_id, doctor_id, protocol, status, start_date, assessment_data)
VALUES ('62345678-1234-1234-1234-123456789abc', '32345678-1234-1234-1234-123456789abc', '12345678-1234-1234-1234-123456789abc', 'Short Protocol', 'Active', CURRENT_DATE, '{"test": "data"}');

-- Add visits
INSERT INTO visits (id, patient_id, date, department, diagnosis, notes)
VALUES ('72345678-1234-1234-1234-123456789abc', '22345678-1234-1234-1234-123456789abc', CURRENT_DATE, 'IVF', 'ØªØ£Ø®Ø± Ø§Ù„Ø­Ù…Ù„', 'Ø¨Ø¯Ø¡ ØªØ­ÙÙŠØ² Ø§Ù„Ù…Ø¨Ø§ÙŠØ¶');

INSERT INTO visits (id, patient_id, date, department, diagnosis, notes)
VALUES ('82345678-1234-1234-1234-123456789abc', '32345678-1234-1234-1234-123456789abc', CURRENT_DATE - INTERVAL '5 days', 'IVF', 'ØªØ£Ø®Ø± Ø§Ù„Ø­Ù…Ù„ Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ', 'Ù…ØªØ§Ø¨Ø¹Ø© Ø±ÙˆØªÙŠÙ†ÙŠØ©');

-- ============================================================================
-- VERIFY
-- ============================================================================
SELECT COUNT(*) as doctors_count FROM doctors WHERE id = '12345678-1234-1234-1234-123456789abc';
SELECT COUNT(*) as patients_count FROM patients WHERE doctor_id = '12345678-1234-1234-1234-123456789abc';
SELECT COUNT(*) as cycles_count FROM ivf_cycles WHERE doctor_id = '12345678-1234-1234-1234-123456789abc';
SELECT COUNT(*) as visits_count FROM visits WHERE id IN ('72345678-1234-1234-1234-123456789abc', '82345678-1234-1234-1234-123456789abc');
</file>

<file path="SEED_DATA.sql">
-- ============================================================================
-- NILE IVF - SEED DATA (SAMPLE DATA FOR TESTING)
-- ============================================================================
-- Run this in Supabase SQL Editor to populate with sample data

-- Note: Replace 'YOUR_DOCTOR_USER_ID' with actual user ID from auth.users table

-- ============================================================================
-- 1. ADD SAMPLE DOCTOR (if not exists)
-- ============================================================================
-- This will use the first user from auth.users table

INSERT INTO doctors (user_id, email, name, specialization, phone)
SELECT 
  (SELECT id FROM auth.users LIMIT 1),
  'doctor@example.com',
  'Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±',
  'Ø£Ø®ØµØ§Ø¦ÙŠ Ø§Ù„Ø®ØµÙˆØ¨Ø©',
  '01000000000'
WHERE NOT EXISTS (
  SELECT 1 FROM doctors WHERE user_id = (SELECT id FROM auth.users LIMIT 1)
);

-- ============================================================================
-- 2. ADD SAMPLE PATIENTS
-- ============================================================================
INSERT INTO patients (name, age, phone, husband_name, history, doctor_id)
VALUES 
  ('ÙØ§Ø·Ù…Ø© Ø§Ø­Ù…Ø¯', 32, '01012345678', 'Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ', 'Ø¹Ø¯Ù… Ø§Ù„Ø­Ù…Ù„ Ù„Ù…Ø¯Ø© 3 Ø³Ù†ÙˆØ§Øª', (SELECT id FROM doctors LIMIT 1)),
  ('Ø³Ø§Ø±Ø© Ù…Ø­Ù…ÙˆØ¯', 28, '01087654321', 'Ø£Ø­Ù…Ø¯ Ø­Ø³Ù†', 'ØªØ£Ø®Ø± Ø§Ù„Ø­Ù…Ù„ Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ', (SELECT id FROM doctors LIMIT 1)),
  ('Ù„ÙŠÙ„Ù‰ Ø®Ø§Ù„Ø¯', 35, '01098765432', 'Ø¹Ù…Ø± Ù…Ø­Ù…Ø¯', 'Ø£ÙƒÙŠØ§Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨Ø§ÙŠØ¶', (SELECT id FROM doctors LIMIT 1));

-- ============================================================================
-- 3. ADD SAMPLE IVF CYCLES
-- ============================================================================
INSERT INTO ivf_cycles (patient_id, doctor_id, protocol, status, start_date, assessment_data)
VALUES 
  (
    (SELECT id FROM patients WHERE name = 'ÙØ§Ø·Ù…Ø© Ø§Ø­Ù…Ø¯'),
    (SELECT id FROM doctors LIMIT 1),
    'Long Protocol',
    'Active',
    CURRENT_DATE,
    jsonb_build_object(
      'coupleProfile', jsonb_build_object('duration', '3 years', 'type', 'primary'),
      'maleFactorData', jsonb_build_object('spermCount', 50, 'motility', 40),
      'femaleFactorData', jsonb_build_object('amh', 3.5, 'follicleCount', 15)
    )
  ),
  (
    (SELECT id FROM patients WHERE name = 'Ø³Ø§Ø±Ø© Ù…Ø­Ù…ÙˆØ¯'),
    (SELECT id FROM doctors LIMIT 1),
    'Short Protocol',
    'Active',
    CURRENT_DATE + INTERVAL '1 week',
    jsonb_build_object(
      'coupleProfile', jsonb_build_object('duration', '2 years', 'type', 'secondary')
    )
  );

-- ============================================================================
-- 4. ADD SAMPLE VISITS
-- ============================================================================
INSERT INTO visits (patient_id, date, department, diagnosis, prescription, notes)
VALUES 
  (
    (SELECT id FROM patients WHERE name = 'ÙØ§Ø·Ù…Ø© Ø§Ø­Ù…Ø¯'),
    CURRENT_DATE,
    'IVF',
    'ØªØ£Ø®Ø± Ø§Ù„Ø­Ù…Ù„',
    jsonb_build_array(jsonb_build_object('drug', 'Gonal-F', 'dose', '300 IU')),
    'Ø¨Ø¯Ø¡ ØªØ­ÙÙŠØ² Ø§Ù„Ù…Ø¨Ø§ÙŠØ¶'
  ),
  (
    (SELECT id FROM patients WHERE name = 'Ø³Ø§Ø±Ø© Ù…Ø­Ù…ÙˆØ¯'),
    CURRENT_DATE - INTERVAL '5 days',
    'IVF',
    'ØªØ£Ø®Ø± Ø§Ù„Ø­Ù…Ù„ Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ',
    jsonb_build_array(jsonb_build_object('drug', 'Menopur', 'dose', '75 IU')),
    'Ù…ØªØ§Ø¨Ø¹Ø© Ø±ÙˆØªÙŠÙ†ÙŠØ©'
  );

-- ============================================================================
-- 5. VERIFICATION QUERIES
-- ============================================================================
-- Run these to confirm data was inserted:

SELECT 'ğŸ“Š DOCTORS' as section;
SELECT id, name, email, specialization FROM doctors;

SELECT 'ğŸ‘¥ PATIENTS' as section;
SELECT id, name, age, doctor_id FROM patients;

SELECT 'ğŸ”„ IVF CYCLES' as section;
SELECT id, patient_id, protocol, status, start_date FROM ivf_cycles;

SELECT 'ğŸ“‹ VISITS' as section;
SELECT id, patient_id, date, department, diagnosis FROM visits;

-- ============================================================================
-- DONE!
-- Data should now be visible in the app
-- ============================================================================
</file>

<file path="services/authService.ts">
import { supabase } from './supabaseClient';

export const authService = {
  login: async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    
    if (error) throw error;
    return data;
  },

  signup: async (email: string, password: string, doctorData: { name: string; specialization?: string; phone?: string }) => {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    });
    
    if (error) throw error;

    if (data.user) {
      const { error: dbError } = await supabase
        .from('doctors')
        .insert([
          {
            user_id: data.user.id,
            email: email,
            name: doctorData.name,
            specialization: doctorData.specialization || null,
            phone: doctorData.phone || null,
            doctor_image: null,
            clinic_name: null,
            clinic_address: null,
            clinic_phone: null,
            clinic_image: null,
            clinic_latitude: null,
            clinic_longitude: null,
          }
        ]);

      if (dbError) {
        console.error('Doctor insert error:', dbError);
        throw dbError;
      }
    }

    return data;
  },

  logout: async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
  },

  getCurrentUser: async () => {
    try {
      // 1. Try strict server verification first (Secure)
      const { data: { user }, error } = await supabase.auth.getUser();
      if (error) throw error;
      return user;
    } catch (error: any) {
      // 2. If Network Error ("Failed to fetch"), Fallback to Local Session
      if (error.message?.includes('Failed to fetch') || !navigator.onLine) {
        console.warn('Offline mode: Verifying local session...');
        const { data: { session } } = await supabase.auth.getSession();
        // If we have a valid local session, allow access
        if (session?.user) {
          return session.user;
        }
      }
      // Real auth error? Re-throw
      throw error;
    }
  },

  getDoctorProfile: async (userId: string) => {
    const { data, error } = await supabase
      .from('doctors')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error) throw error;
    return data;
  },

  onAuthStateChange: (callback: (user: any) => void) => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      callback(session?.user || null);
    });

    return subscription;
  },

  updateDoctorProfile: async (userId: string, updates: any) => {
    const { data, error } = await supabase
      .from('doctors')
      .update(updates)
      .eq('user_id', userId);

    if (error) {
      console.error('Update error details:', error);
      throw new Error(error.message || 'Failed to update profile');
    }
    return data;
  },

  updatePassword: async (newPassword: string) => {
    const { data, error } = await supabase.auth.updateUser({
      password: newPassword
    });

    if (error) throw error;
    return data;
  },

  uploadImage: async (userId: string, file: File, folder: 'doctor_images' | 'clinic_images') => {
    const fileExt = file.name.split('.').pop();
    const fileName = `${userId}_${Date.now()}.${fileExt}`;
    const filePath = `${folder}/${fileName}`;

    const { error: uploadError } = await supabase.storage
      .from('doctor-files')
      .upload(filePath, file, { upsert: true });

    if (uploadError) throw uploadError;

    const { data } = supabase.storage
      .from('doctor-files')
      .getPublicUrl(filePath);

    return data.publicUrl;
  },

  ensureDoctorRecord: async (userId: string, email: string) => {
    const { data: existingDoctor, error: fetchError } = await supabase
      .from('doctors')
      .select('id')
      .eq('user_id', userId)
      .single();

    if (existingDoctor) {
      return existingDoctor;
    }

    const { data: newDoctor, error: insertError } = await supabase
      .from('doctors')
      .insert([
        {
          user_id: userId,
          email: email,
          name: 'Ø§Ù„Ø·Ø¨ÙŠØ¨',
          specialization: null,
          phone: null,
          doctor_image: null,
          clinic_name: null,
          clinic_address: null,
          clinic_phone: null,
          clinic_image: null,
          clinic_latitude: null,
          clinic_longitude: null,
        }
      ])
      .select()
      .single();

    if (insertError) {
      console.error('Error creating doctor record:', insertError);
      throw insertError;
    }

    return newDoctor;
  }
};
</file>

<file path="services/dbService.ts">
import { supabase } from './supabaseClient';
import { authService } from './authService';
import { Patient, IvfCycle, StimulationLog } from '../types';

const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

const executeWithRetry = async (fn: () => Promise<any>, context: string, retries = MAX_RETRIES): Promise<any> => {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await fn();
    } catch (error: any) {
      const isLastAttempt = attempt === retries;
      console.error(`âŒ [${context}] Attempt ${attempt}/${retries} failed:`, error?.message);
      
      if (isLastAttempt) {
        throw new Error(`${context} failed after ${retries} attempts: ${error?.message}`);
      }
      
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * attempt));
    }
  }
};

export const dbService = {
  // --- Patients ---
  getPatients: async (): Promise<Patient[]> => {
    try {
      const user = await authService.getCurrentUser();
      if (!user) throw new Error('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹');

      const doctor = await authService.ensureDoctorRecord(user.id, user.email || '');
      if (!doctor?.id) throw new Error('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù Ø§Ù„Ø·Ø¨ÙŠØ¨');

      const { data, error } = await supabase
        .from('patients')
        .select('*')
        .eq('doctor_id', doctor.id);

      if (error) throw error;

      return (data || []).map((p: any) => ({
        id: p.id,
        name: p.name,
        age: p.age || 0,
        phone: p.phone,
        husbandName: p.husband_name || '',
        history: p.history || '',
        createdAt: p.created_at || new Date().toISOString()
      }));
    } catch (error: any) {
      console.error('âŒ getPatients error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø¶Ù‰: ${error?.message}`);
    }
  },

  savePatient: async (patient: Omit<Patient, 'id' | 'createdAt'>) => {
    try {
      const user = await authService.getCurrentUser();
      if (!user) throw new Error('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹');

      const doctor = await authService.ensureDoctorRecord(user.id, user.email || '');
      if (!doctor?.id) throw new Error('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù Ø§Ù„Ø·Ø¨ÙŠØ¨');

      const id = crypto.randomUUID();
      const now = new Date().toISOString();

      await executeWithRetry(
        () => supabase.from('patients').insert({
          id,
          name: patient.name,
          age: patient.age,
          phone: patient.phone,
          husband_name: patient.husbandName,
          history: patient.history,
          doctor_id: doctor.id,
          created_at: now,
          updated_at: now
        }),
        'Save Patient'
      );

      return { id, ...patient, createdAt: now };
    } catch (error: any) {
      console.error('âŒ savePatient error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ÙŠØ¶: ${error?.message}`);
    }
  },

  // --- Cycles ---
  getCycles: async (): Promise<IvfCycle[]> => {
    try {
      const user = await authService.getCurrentUser();
      if (!user) throw new Error('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹');

      const doctor = await authService.ensureDoctorRecord(user.id, user.email || '');
      if (!doctor?.id) throw new Error('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù Ø§Ù„Ø·Ø¨ÙŠØ¨');

      const [cyclesData, logsData] = await Promise.all([
        supabase.from('ivf_cycles').select('*').eq('doctor_id', doctor.id),
        supabase.from('stimulation_logs').select('*')
      ]);

      if (cyclesData.error) throw cyclesData.error;
      if (logsData.error) throw logsData.error;

      const cycles = cyclesData.data || [];
      const logs = logsData.data || [];

      const parseJSON = (str: string) => {
        try { return str ? JSON.parse(str) : undefined; } catch (e) { return undefined; }
      };

      return cycles.map((c: any) => ({
        id: c.id,
        patientId: c.patient_id,
        protocol: c.protocol,
        startDate: c.start_date,
        status: c.status,
        logs: logs
          .filter((l: any) => l.cycle_id === c.id)
          .map((l: any) => ({
            id: l.id,
            date: l.date,
            cycleDay: l.cycle_day,
            fsh: l.fsh,
            hmg: l.hmg,
            e2: l.e2,
            lh: l.lh,
            rtFollicles: l.rt_follicles,
            ltFollicles: l.lt_follicles,
            endometriumThickness: l.endometrium_thickness
          })),
        lab: parseJSON(c.lab_data),
        transfer: parseJSON(c.transfer_data),
        outcome: parseJSON(c.outcome_data),
        assessment: parseJSON(c.assessment_data)
      }));
    } catch (error: any) {
      console.error('âŒ getCycles error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¯ÙˆØ±Ø§Øª Ø§Ù„Ø­Ù‚Ù† Ø§Ù„Ù…Ø¬Ù‡Ø±ÙŠ: ${error?.message}`);
    }
  },

  saveCycle: async (cycle: Partial<IvfCycle> & { patientId: string }) => {
    try {
      const user = await authService.getCurrentUser();
      if (!user) throw new Error('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹');

      const doctor = await authService.ensureDoctorRecord(user.id, user.email || '');
      if (!doctor?.id) throw new Error('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù Ø§Ù„Ø·Ø¨ÙŠØ¨');

      const id = crypto.randomUUID();
      const now = new Date().toISOString();

      await executeWithRetry(
        () => supabase.from('ivf_cycles').insert({
          id,
          patient_id: cycle.patientId,
          doctor_id: doctor.id,
          protocol: cycle.protocol,
          status: cycle.status || 'Active',
          start_date: cycle.startDate,
          assessment_data: JSON.stringify(cycle.assessment || {}),
          lab_data: JSON.stringify(cycle.lab || {}),
          transfer_data: JSON.stringify(cycle.transfer || {}),
          outcome_data: JSON.stringify(cycle.outcome || {}),
          created_at: now,
          updated_at: now
        }),
        'Save IVF Cycle'
      );

      return { id, ...cycle };
    } catch (error: any) {
      console.error('âŒ saveCycle error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø¯ÙˆØ±Ø© Ø§Ù„Ø­Ù‚Ù† Ø§Ù„Ù…Ø¬Ù‡Ø±ÙŠ: ${error?.message}`);
    }
  },

  // --- Logs ---
  addLog: async (cycleId: string, log: Partial<StimulationLog>) => {
    try {
      if (!cycleId) throw new Error('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯ÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨');
      if (!log.date || !log.cycleDay) throw new Error('Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ±Ù‚Ù… Ø§Ù„ÙŠÙˆÙ… Ù…Ø·Ù„ÙˆØ¨');

      const id = crypto.randomUUID();
      const now = new Date().toISOString();

      await executeWithRetry(
        () => supabase.from('stimulation_logs').insert({
          id,
          cycle_id: cycleId,
          cycle_day: log.cycleDay,
          date: log.date,
          fsh: log.fsh || '',
          hmg: log.hmg || '',
          e2: log.e2 || '',
          lh: log.lh || '',
          rt_follicles: log.rtFollicles || '',
          lt_follicles: log.ltFollicles || '',
          endometrium_thickness: log.endometriumThickness || '',
          created_at: now,
          updated_at: now
        }),
        'Add Stimulation Log'
      );

      return { id, ...log };
    } catch (error: any) {
      console.error('âŒ addLog error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø³Ø¬Ù„ Ø§Ù„ØªØ­ÙÙŠØ²: ${error?.message}`);
    }
  },

  updateLog: async (logId: string, updates: Partial<StimulationLog>) => {
    try {
      if (!logId) throw new Error('Ù…Ø¹Ø±Ù Ø§Ù„Ø³Ø¬Ù„ Ù…Ø·Ù„ÙˆØ¨');

      const updateData: any = {};
      if (updates.fsh !== undefined) updateData.fsh = updates.fsh;
      if (updates.hmg !== undefined) updateData.hmg = updates.hmg;
      if (updates.e2 !== undefined) updateData.e2 = updates.e2;
      if (updates.lh !== undefined) updateData.lh = updates.lh;
      if (updates.rtFollicles !== undefined) updateData.rt_follicles = updates.rtFollicles;
      if (updates.ltFollicles !== undefined) updateData.lt_follicles = updates.ltFollicles;
      if (updates.endometriumThickness !== undefined) updateData.endometrium_thickness = updates.endometriumThickness;

      if (Object.keys(updateData).length === 0) throw new Error('Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø¯ÙŠØ«Ø§Øª Ù„Ù„ØªØ·Ø¨ÙŠÙ‚');

      updateData.updated_at = new Date().toISOString();

      await executeWithRetry(
        () => supabase.from('stimulation_logs').update(updateData).eq('id', logId),
        'Update Stimulation Log'
      );
    } catch (error: any) {
      console.error('âŒ updateLog error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø³Ø¬Ù„ Ø§Ù„ØªØ­ÙÙŠØ²: ${error?.message}`);
    }
  },

  updateCycleAssessment: async (cycleId: string, assessment: any) => {
    try {
      if (!cycleId) throw new Error('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯ÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨');
      if (!assessment) throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ù…Ø·Ù„ÙˆØ¨Ø©');

      const now = new Date().toISOString();
      await executeWithRetry(
        () => supabase.from('ivf_cycles').update({
          assessment_data: JSON.stringify(assessment),
          updated_at: now
        }).eq('id', cycleId),
        'Update IVF Cycle Assessment'
      );
    } catch (error: any) {
      console.error('âŒ updateCycleAssessment error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: ${error?.message}`);
    }
  },

  updateCycleLabData: async (cycleId: string, labData: any) => {
    try {
      if (!cycleId) throw new Error('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯ÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨');
      if (!labData) throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®ØªØ¨Ø± Ù…Ø·Ù„ÙˆØ¨Ø©');

      const now = new Date().toISOString();
      await executeWithRetry(
        () => supabase.from('ivf_cycles').update({
          lab_data: JSON.stringify(labData),
          updated_at: now
        }).eq('id', cycleId),
        'Update IVF Lab Data'
      );
    } catch (error: any) {
      console.error('âŒ updateCycleLabData error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®ØªØ¨Ø±: ${error?.message}`);
    }
  },

  updateCycleTransfer: async (cycleId: string, transferData: any) => {
    try {
      if (!cycleId) throw new Error('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯ÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨');
      if (!transferData) throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù‚Ù„ Ù…Ø·Ù„ÙˆØ¨Ø©');

      const now = new Date().toISOString();
      await executeWithRetry(
        () => supabase.from('ivf_cycles').update({
          transfer_data: JSON.stringify(transferData),
          updated_at: now
        }).eq('id', cycleId),
        'Update IVF Transfer Data'
      );
    } catch (error: any) {
      console.error('âŒ updateCycleTransfer error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù‚Ù„: ${error?.message}`);
    }
  },

  updateCycleOutcome: async (cycleId: string, outcomeData: any) => {
    try {
      if (!cycleId) throw new Error('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯ÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨');
      if (!outcomeData) throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù…Ø·Ù„ÙˆØ¨Ø©');

      const now = new Date().toISOString();
      await executeWithRetry(
        () => supabase.from('ivf_cycles').update({
          outcome_data: JSON.stringify(outcomeData),
          status: 'Completed',
          updated_at: now
        }).eq('id', cycleId),
        'Update IVF Cycle Outcome'
      );
    } catch (error: any) {
      console.error('âŒ updateCycleOutcome error:', error?.message);
      throw new Error(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¯ÙˆØ±Ø©: ${error?.message}`);
    }
  }
};
</file>

<file path="services/supabaseClient.ts">
// Re-export the shared Supabase client instance
export { supabase } from '../src/lib/supabase';
</file>

<file path="services/workupService.ts">
import { powerSyncDb } from '../src/powersync/client';

// Database schema interface (snake_case for Supabase)
export interface WorkupData {
  id?: string;
  patient_id: string;
  // Ovarian Factor
  amh?: number;
  cycle_regularity?: 'Regular' | 'Irregular';
  // Male Factor
  sperm_count?: number;
  motility?: number;
  morphology?: number;
  // Tubal Factor
  left_tube?: 'Patent' | 'Blocked' | 'Hydrosalpinx';
  right_tube?: 'Patent' | 'Blocked' | 'Hydrosalpinx';
  // Uterine Factor
  cavity_status?: 'Normal' | 'Septum' | 'Polyp' | 'Adhesions';
  // Auto-generated
  diagnosis?: string;
  plan?: string;
  created_at?: string;
  updated_at?: string;
}

// TypeScript interface for component state (camelCase)
export interface WorkupState {
  patientId: string;
  ovarianFactor: {
    amh?: number;
    cycleRegularity?: 'Regular' | 'Irregular';
  };
  maleFactor: {
    spermCount?: number;
    motility?: number;
    morphology?: number;
  };
  tubalFactor: {
    leftTube?: 'Patent' | 'Blocked' | 'Hydrosalpinx';
    rightTube?: 'Patent' | 'Blocked' | 'Hydrosalpinx';
  };
  uterineFactor: {
    cavityStatus?: 'Normal' | 'Septum' | 'Polyp' | 'Adhesions';
  };
  diagnosis?: string;
  plan?: string;
}

// Convert database format to component state
const dbToState = (dbData: WorkupData): WorkupState => ({
  patientId: dbData.patient_id,
  ovarianFactor: {
    amh: dbData.amh,
    cycleRegularity: dbData.cycle_regularity,
  },
  maleFactor: {
    spermCount: dbData.sperm_count,
    motility: dbData.motility,
    morphology: dbData.morphology,
  },
  tubalFactor: {
    leftTube: dbData.left_tube,
    rightTube: dbData.right_tube,
  },
  uterineFactor: {
    cavityStatus: dbData.cavity_status,
  },
  diagnosis: dbData.diagnosis,
  plan: dbData.plan,
});

// Convert component state to database format
const stateToDb = (state: WorkupState): Omit<WorkupData, 'id' | 'created_at' | 'updated_at'> => ({
  patient_id: state.patientId,
  amh: state.ovarianFactor.amh,
  cycle_regularity: state.ovarianFactor.cycleRegularity,
  sperm_count: state.maleFactor.spermCount,
  motility: state.maleFactor.motility,
  morphology: state.maleFactor.morphology,
  left_tube: state.tubalFactor.leftTube,
  right_tube: state.tubalFactor.rightTube,
  cavity_status: state.uterineFactor.cavityStatus,
});

// Get workup data for a patient
export const getWorkup = async (patientId: string): Promise<WorkupState> => {
  try {
    const data = await powerSyncDb.getAll(
      'SELECT * FROM infertility_workups WHERE patient_id = ?',
      [patientId]
    ) as any[];

    if (data.length > 0) {
      return dbToState(data[0]);
    }

    // Return default empty object if no data exists
    return {
      patientId,
      ovarianFactor: {},
      maleFactor: {},
      tubalFactor: {},
      uterineFactor: {},
    };
  } catch (error) {
    console.error('Error fetching workup data:', error);
    throw new Error('Failed to fetch infertility workup data');
  }
};

// Save workup data (upsert)
export const saveWorkup = async (data: WorkupState): Promise<void> => {
  try {
    const dbData = stateToDb(data);
    const diagnosis = generateDiagnosis(data);
    const now = new Date().toISOString();

    // Check if record exists
    const existing = await powerSyncDb.getAll(
      'SELECT id FROM infertility_workups WHERE patient_id = ?',
      [data.patientId]
    ) as any[];

    if (existing.length > 0) {
      // Update existing record
      await powerSyncDb.execute(
        `UPDATE infertility_workups SET 
          amh = ?, cycle_regularity = ?, sperm_count = ?, motility = ?, 
          morphology = ?, left_tube = ?, right_tube = ?, cavity_status = ?, 
          diagnosis = ?, plan = ?, updated_at = ?
         WHERE patient_id = ?`,
        [
          dbData.amh,
          dbData.cycle_regularity,
          dbData.sperm_count,
          dbData.motility,
          dbData.morphology,
          dbData.left_tube,
          dbData.right_tube,
          dbData.cavity_status,
          diagnosis.diagnosis,
          diagnosis.plan,
          now,
          data.patientId
        ]
      );
    } else {
      // Insert new record
      const id = crypto.randomUUID();
      await powerSyncDb.execute(
        `INSERT INTO infertility_workups 
          (id, patient_id, amh, cycle_regularity, sperm_count, motility, 
           morphology, left_tube, right_tube, cavity_status, diagnosis, plan, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          data.patientId,
          dbData.amh,
          dbData.cycle_regularity,
          dbData.sperm_count,
          dbData.motility,
          dbData.morphology,
          dbData.left_tube,
          dbData.right_tube,
          dbData.cavity_status,
          diagnosis.diagnosis,
          diagnosis.plan,
          now,
          now
        ]
      );
    }
  } catch (error) {
    console.error('Error saving workup data:', error);
    throw new Error('Failed to save infertility workup data');
  }
};

// Generate diagnosis and plan based on medical logic
export const generateDiagnosis = (data: WorkupState): { diagnosis: string; plan: string } => {
  const factors: string[] = [];
  const plans: string[] = [];

  // Male Factor Assessment
  const hasMaleFactor =
    (data.maleFactor.spermCount !== undefined && data.maleFactor.spermCount < 15) ||
    (data.maleFactor.motility !== undefined && data.maleFactor.motility < 40) ||
    (data.maleFactor.morphology !== undefined && data.maleFactor.morphology < 4);

  if (hasMaleFactor) {
    factors.push('Male Factor Infertility');
    plans.push('IVF/ICSI Recommended');
  }

  // Tubal Factor Assessment
  const hasTubalFactor =
    data.tubalFactor.leftTube === 'Blocked' ||
    data.tubalFactor.rightTube === 'Blocked' ||
    data.tubalFactor.leftTube === 'Hydrosalpinx' ||
    data.tubalFactor.rightTube === 'Hydrosalpinx';

  if (hasTubalFactor) {
    factors.push('Tubal Factor Infertility');
    plans.push('IVF/ICSI Recommended');
  }

  // Ovarian Factor Assessment
  const hasOvarianFactor =
    (data.ovarianFactor.amh !== undefined && (data.ovarianFactor.amh < 1.1 || data.ovarianFactor.amh > 3.5)) ||
    data.ovarianFactor.cycleRegularity === 'Irregular';

  if (hasOvarianFactor) {
    if (data.ovarianFactor.amh !== undefined && data.ovarianFactor.amh < 1.1) {
      factors.push('Diminished Ovarian Reserve (DOR)');
    } else if (data.ovarianFactor.amh !== undefined && data.ovarianFactor.amh > 3.5) {
      factors.push('Polycystic Ovary Syndrome (PCOS)');
    }
    if (data.ovarianFactor.cycleRegularity === 'Irregular') {
      factors.push('Ovulatory Dysfunction');
    }
  }

  // Uterine Factor Assessment
  const hasUterineFactor = data.uterineFactor.cavityStatus && data.uterineFactor.cavityStatus !== 'Normal';

  if (hasUterineFactor) {
    factors.push('Uterine Factor Infertility');
    plans.push('Hysteroscopic Correction Required');
  }

  // Hydrosalpinx specific note
  const hasHydrosalpinx =
    data.tubalFactor.leftTube === 'Hydrosalpinx' ||
    data.tubalFactor.rightTube === 'Hydrosalpinx';

  if (hasHydrosalpinx) {
    plans.push('Salpingectomy Required Before ET');
  }

  // Generate diagnosis string
  let diagnosis = 'Unexplained Infertility';
  if (factors.length > 0) {
    diagnosis = factors.join(' + ');
  }

  // Generate plan string
  let plan = 'Further Investigation Required';
  if (plans.length > 0) {
    plan = plans.join(' + ');
  } else if (hasOvarianFactor && !hasMaleFactor && !hasTubalFactor && !hasUterineFactor) {
    plan = 'Induction + Timed Intercourse';
  }

  return { diagnosis, plan };
};
</file>

<file path="src/lib/networkStatus.ts">
export class NetworkStatus {
  private static instance: NetworkStatus;
  private isOnline: boolean = navigator.onLine;
  private listeners: Set<(isOnline: boolean) => void> = new Set();

  private constructor() {
    this.setupListeners();
  }

  static getInstance(): NetworkStatus {
    if (!NetworkStatus.instance) {
      NetworkStatus.instance = new NetworkStatus();
    }
    return NetworkStatus.instance;
  }

  private setupListeners(): void {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.notifyListeners();
    });

    window.addEventListener('offline', () => {
      this.isOnline = false;
      this.notifyListeners();
    });
  }

  getStatus(): boolean {
    return this.isOnline;
  }

  subscribe(callback: (isOnline: boolean) => void): () => void {
    this.listeners.add(callback);
    return () => {
      this.listeners.delete(callback);
    };
  }

  private notifyListeners(): void {
    this.listeners.forEach(listener => listener(this.isOnline));
  }
}

export const networkStatus = NetworkStatus.getInstance();
</file>

<file path="src/powersync/SyncRules.ts">
export const SYNC_RULES = `
-- ============================================================================
-- POWERSYNC SYNC RULES (YAML FORMAT)
-- Configure in PowerSync Dashboard > Settings > Sync Rules
-- ============================================================================

-- Use the following sync rules to configure which tables and columns
-- are synchronized based on user authentication and permissions

bucket_definitions:
  # Doctors sync: Each doctor only syncs their own profile
  doctors:
    table: doctors
    rule: 'auth.uid() = user_id'
    
  # Patients sync: Each doctor syncs only their assigned patients
  patients:
    table: patients
    rule: 'doctor_id in (select id from doctors where user_id = auth.uid())'
    
  # Visits sync: Each doctor syncs visits for their patients
  visits:
    table: visits
    rule: |
      patient_id in (
        select id from patients 
        where doctor_id in (select id from doctors where user_id = auth.uid())
      )
    
  # IVF Cycles sync: Each doctor syncs their IVF cycles
  ivf_cycles:
    table: ivf_cycles
    rule: 'doctor_id in (select id from doctors where user_id = auth.uid())'
    
  # Stimulation Logs sync: Related to doctor's IVF cycles
  stimulation_logs:
    table: stimulation_logs
    rule: |
      cycle_id in (
        select id from ivf_cycles 
        where doctor_id in (select id from doctors where user_id = auth.uid())
      )
    
  # Pregnancies sync: Each doctor syncs their pregnancies
  pregnancies:
    table: pregnancies
    rule: 'doctor_id in (select id from doctors where user_id = auth.uid())'
    
  # Antenatal Visits sync: Related to doctor's pregnancies
  antenatal_visits:
    table: antenatal_visits
    rule: |
      pregnancy_id in (
        select id from pregnancies 
        where doctor_id in (select id from doctors where user_id = auth.uid())
      )
    
  # Biometry Scans sync: Related to doctor's pregnancies
  biometry_scans:
    table: biometry_scans
    rule: |
      pregnancy_id in (
        select id from pregnancies 
        where doctor_id in (select id from doctors where user_id = auth.uid())
      )
    
  # Patient Files sync: Related to doctor's patients
  patient_files:
    table: patient_files
    rule: |
      patient_id in (
        select id from patients 
        where doctor_id in (select id from doctors where user_id = auth.uid())
      )
    
  # App Settings sync: Public data for all authenticated users
  app_settings:
    table: app_settings
    rule: 'true'
`;

export interface SyncConfig {
  enabled: boolean;
  interval: number;
  batchSize: number;
  retryAttempts: number;
  retryDelay: number;
  conflictResolution: 'remote_wins' | 'local_wins' | 'merge';
}

export const DEFAULT_SYNC_CONFIG: SyncConfig = {
  enabled: true,
  interval: 5000,
  batchSize: 100,
  retryAttempts: 3,
  retryDelay: 1000,
  conflictResolution: 'remote_wins'
};

export const OFFLINE_FIRST_STRATEGY = {
  useLocalFirst: true,
  syncWhenOnline: true,
  queueOfflineChanges: true,
  persistQueue: true,
  maxOfflineQueue: 1000
};

export const CONFLICT_RESOLUTION_STRATEGIES = {
  timestamp: (local: any, remote: any) => {
    const localTime = new Date(local.updated_at).getTime();
    const remoteTime = new Date(remote.updated_at).getTime();
    return remoteTime > localTime ? remote : local;
  },
  
  custom: (local: any, remote: any, context?: any) => {
    if (context?.field === 'assessment_data' || context?.field === 'lab_data') {
      return { ...local, ...remote };
    }
    return remote;
  },
  
  localWins: (local: any) => local,
  remoteWins: (remote: any) => remote
};
</file>

<file path="src/powersync/worker.ts">
// PowerSync Web Worker
// This file is part of the PowerSync worker setup
// The actual worker implementation is handled by @powersync/web package
// and the worker script is served from /powersync.worker.js

// Re-export the necessary types and utilities from @powersync/web
// This ensures proper TypeScript compilation and module resolution
export * from '@powersync/web';

// The worker implementation is automatically handled by the WASQLitePowerSyncDatabaseOpenFactory
// when workerScriptURL is provided in client.ts
// No additional worker setup is needed here as it's managed by the main client
</file>

<file path="src/utils/connectionDiagnostics.ts">
// Connection Diagnostics Utility
import { supabase } from '../lib/supabase';
import { powerSyncDb } from '../powersync/client';
import { useStatus } from '@powersync/react';

export interface ConnectionStatus {
  supabase: {
    connected: boolean;
    url: string;
    error?: string;
    user?: any;
  };
  powerSync: {
    connected: boolean;
    endpoint?: string;
    error?: string;
    lastSyncedAt?: Date;
  };
  overall: {
    status: 'connected' | 'partial' | 'disconnected';
    message: string;
  };
}

export async function checkSupabaseConnection(): Promise<{
  connected: boolean;
  url: string;
  error?: string;
  user?: any;
}> {
  try {
    const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
    
    if (!supabaseUrl) {
      return {
        connected: false,
        url: 'Not configured',
        error: 'VITE_SUPABASE_URL not found in environment variables'
      };
    }

    // Check authentication
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    
    if (sessionError) {
      return {
        connected: false,
        url: supabaseUrl,
        error: sessionError.message
      };
    }

    if (!session) {
      return {
        connected: false,
        url: supabaseUrl,
        error: 'No active session. Please log in.'
      };
    }

    // Test database connection
    const { data, error } = await supabase
      .from('patients')
      .select('id')
      .limit(1);

    if (error) {
      return {
        connected: false,
        url: supabaseUrl,
        error: `Database error: ${error.message}`,
        user: session.user
      };
    }

    return {
      connected: true,
      url: supabaseUrl,
      user: session.user
    };
  } catch (error: any) {
    return {
      connected: false,
      url: import.meta.env.VITE_SUPABASE_URL || 'Unknown',
      error: error?.message || 'Unknown error'
    };
  }
}

export async function checkPowerSyncConnection(): Promise<{
  connected: boolean;
  endpoint?: string;
  error?: string;
  lastSyncedAt?: Date;
}> {
  try {
    const endpoint = import.meta.env.VITE_POWERSYNC_URL;
    
    if (!endpoint) {
      return {
        connected: false,
        error: 'VITE_POWERSYNC_URL not found in environment variables'
      };
    }

    // Try to query PowerSync database
    try {
      const testQuery = await powerSyncDb.getAll('SELECT 1 as test');
      
      // Check connection status via useStatus hook would need to be called from component
      // For now, we'll check if we can query
      return {
        connected: true,
        endpoint: endpoint
      };
    } catch (dbError: any) {
      return {
        connected: false,
        endpoint: endpoint,
        error: `Database query failed: ${dbError?.message}`
      };
    }
  } catch (error: any) {
    return {
      connected: false,
      error: error?.message || 'Unknown error'
    };
  }
}

export async function getFullConnectionStatus(): Promise<ConnectionStatus> {
  const [supabaseStatus, powerSyncStatus] = await Promise.all([
    checkSupabaseConnection(),
    checkPowerSyncConnection()
  ]);

  // Determine overall status
  let overallStatus: 'connected' | 'partial' | 'disconnected';
  let message: string;

  if (supabaseStatus.connected && powerSyncStatus.connected) {
    overallStatus = 'connected';
    message = 'âœ… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­';
  } else if (supabaseStatus.connected) {
    overallStatus = 'partial';
    message = 'âš ï¸ Supabase Ù…ØªØµÙ„ØŒ Ù„ÙƒÙ† PowerSync ØºÙŠØ± Ù…ØªØµÙ„ - Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ù…Ù† Supabase Ù…Ø¨Ø§Ø´Ø±Ø©';
  } else if (powerSyncStatus.connected) {
    overallStatus = 'partial';
    message = 'âš ï¸ PowerSync Ù…ØªØµÙ„ØŒ Ù„ÙƒÙ† Supabase ØºÙŠØ± Ù…ØªØµÙ„';
  } else {
    overallStatus = 'disconnected';
    message = 'âŒ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª ÙØ§Ø´Ù„Ø© - ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª';
  }

  return {
    supabase: supabaseStatus,
    powerSync: powerSyncStatus,
    overall: {
      status: overallStatus,
      message: message
    }
  };
}
</file>

<file path="styles.css">
/* tailwindcss */
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: 'Tajawal', sans-serif;
  background-color: #f3f4f6;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Bottom Navigation Scrollbar Styles */
.no-scrollbar::-webkit-scrollbar {
  display: none;
}
.no-scrollbar {
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.pb-safe {
  padding-bottom: env(safe-area-inset-bottom, 0);
}

.print-only {
  display: none;
}

@media print {
  body, html {
    background: white !important;
    margin: 0 !important;
    padding: 0 !important;
    width: 100% !important;
    height: 100% !important;
  }

  .no-print {
    display: none !important;
  }

  .print-only {
    display: block !important;
    position: relative !important;
    width: 100% !important;
    margin: 0 !important;
    padding: 32px !important;
    background: white !important;
  }

  #root {
    width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }

  .print-only * {
    background: white !important;
    color: #000 !important;
  }

  .print-only h1,
  .print-only h2,
  .print-only h3 {
    margin-top: 0 !important;
    page-break-after: avoid !important;
  }
}
</file>

<file path="tailwind.config.js">
export default {
  content: [
    './index.html',
    './src/**/*.{js,ts,jsx,tsx}',
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
    './App.tsx',
  ],
  theme: {
    extend: {
      colors: {
        teal: {
          50: '#e0f2f1',
          100: '#b2dfdb',
          500: '#009688',
          600: '#00897b',
          700: '#00838f',
          800: '#006064',
          900: '#004d40',
        }
      }
    }
  },
  plugins: [],
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  },
  "exclude": ["vite.config.ts"]
}
</file>

<file path="components/Sidebar.tsx">
import React from 'react';
import { LayoutDashboard, Users, Baby, Heart, Settings, LogOut, Activity, FileText } from 'lucide-react';
import { Page } from '../types';
import { useBranding } from '../context/BrandingContext';
import SyncStatus from '../src/components/SyncStatus';

interface SidebarProps {
  activePage: Page;
  setPage: (page: Page) => void;
  onLogout: () => void;
}

export const Sidebar: React.FC<SidebarProps> = ({ activePage, setPage, onLogout }) => {
  const { branding } = useBranding();

  const menuItems = [
    { id: Page.HOME, label: 'Dashboard', arLabel: 'Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©', icon: LayoutDashboard },
    { id: Page.RECEPTION, label: 'Reception', arLabel: 'Ø§Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„', icon: Users },
    { id: Page.GYNECOLOGY, label: 'Gynecology', arLabel: 'Ø¹ÙŠØ§Ø¯Ø© Ø§Ù„Ù†Ø³Ø§Ø¡', icon: Activity },
    { id: Page.OBSTETRICS, label: 'Obstetrics', arLabel: 'Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø­Ù…Ù„', icon: Heart },
    { id: Page.IVF, label: 'IVF Center', arLabel: 'Ù…Ø±ÙƒØ² Ø§Ù„Ø®ØµÙˆØ¨Ø©', icon: Baby },
    { id: Page.PATIENT_RECORD, label: 'Patient Records', arLabel: 'Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù…Ø±Ø¶Ù‰', icon: FileText },
    { id: Page.SETTINGS, label: 'Settings', arLabel: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª', icon: Settings },
  ];

  return (
    // Hidden on mobile, visible from md and up
    <div className="hidden md:w-64 md:flex md:flex-col bg-white h-screen shadow-lg fixed md:static inset-y-0 right-0 z-10 no-print">
      <div className="p-6 border-b border-gray-100 flex items-center justify-center">
        <div className="flex flex-col items-center">
          {branding?.logo_url ? (
            <img src={branding.logo_url} alt="Logo" className="w-12 h-12 rounded-full mb-2 object-cover" />
          ) : (
            <div className="w-12 h-12 bg-teal-50 rounded-full flex items-center justify-center mb-2">
              <Baby className="text-teal-700 w-8 h-8" />
            </div>
          )}
          <h1 className="text-sm font-bold text-gray-800 text-center">{branding?.clinic_name || 'Nile IVF Center'}</h1>
          <p className="text-xs text-gray-400 uppercase tracking-wider">EMR System</p>
        </div>
      </div>
      
      <nav className="flex-1 overflow-y-auto py-4">
        <ul className="space-y-2 px-4">
          {menuItems.map((item) => {
            const Icon = item.icon;
            const isActive = activePage === item.id;
            return (
              <li key={item.id}>
                <button
                  onClick={() => setPage(item.id)}
                  className={`w-full flex items-center gap-4 px-4 py-3 rounded-xl transition-all duration-200 ${
                    isActive 
                      ? 'bg-teal-50 text-teal-700 font-bold shadow-sm' 
                      : 'text-gray-500 hover:bg-gray-50 hover:text-gray-900'
                  }`}
                >
                  <Icon className={`w-5 h-5 ${isActive ? 'text-teal-700' : 'text-gray-400'}`} />
                  <span>{item.arLabel || item.label}</span>
                </button>
              </li>
            );
          })}
        </ul>
      </nav>

      <div className="p-4 border-t border-gray-100">
        {/* Sync Status Indicator */}
        <div className="mb-4">
          <SyncStatus />
        </div>

        <button
          onClick={onLogout}
          className="w-full flex items-center gap-3 px-4 py-2 text-sm text-gray-500 hover:text-red-600 transition-colors"
        >
          <LogOut className="w-4 h-4" />
          <span>Sign Out</span>
        </button>

        {/* Developer Credits */}
        <div className="mt-4 pt-4 border-t border-gray-200 text-center">
          <p className="text-xs text-gray-400 font-[Tajawal] leading-tight">
            Ø¨Ø±Ù…Ø¬Ø© ÙˆØªØ·ÙˆÙŠØ±<br />
            Ø¯. Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±
          </p>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="context/BrandingContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import { supabase } from '../services/supabaseClient';
import { authService } from '../services/authService';
import { powerSyncDb } from '../src/powersync/client';

interface BrandingSettings {
  id: number;
  clinic_name: string;
  logo_url: string | null;
  clinic_address: string | null;
  clinic_phone: string | null;
  primary_color: string;
  secondary_color: string;
  accent_color: string;
  default_rx_notes: string | null;
  updated_at: string;
}

interface BrandingContextType {
  branding: BrandingSettings | null;
  loading: boolean;
  error: string | null;
  updateBranding: (updates: Partial<BrandingSettings>, logoFile?: File) => Promise<void>;
  refreshBranding: () => Promise<void>;
}

const BrandingContext = createContext<BrandingContextType | undefined>(undefined);

export const BrandingProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [branding, setBranding] = useState<BrandingSettings | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchBranding = async () => {
    try {
      setLoading(true);
      setError(null);

      // Use PowerSync for offline-first data
      const results = await powerSyncDb.getAll('SELECT * FROM app_settings');

      if (results.length > 0) {
        setBranding(results[0] as BrandingSettings);
      } else {
        setBranding(getDefaultBranding());
      }
    } catch (err) {
      console.error('Failed to fetch branding:', err);
      setError('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©');
      setBranding(getDefaultBranding());
    } finally {
      setLoading(false);
    }
  };

  const getDefaultBranding = (): BrandingSettings => ({
    id: 1,
    clinic_name: 'Ù†Ø¸Ø§Ù… Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±',
    logo_url: null,
    clinic_address: null,
    clinic_phone: null,
    primary_color: '#2d5a6b',
    secondary_color: '#00838f',
    accent_color: '#00bcd4',
    default_rx_notes: null,
    updated_at: new Date().toISOString(),
  });

  const updateBranding = async (
    updates: Partial<BrandingSettings>,
    logoFile?: File
  ) => {
    try {
      setError(null);

      let logoUrl = updates.logo_url;

      // Image upload still requires online connection to Supabase Storage
      if (logoFile) {
        try {
          const user = await authService.getCurrentUser();
          if (!user) throw new Error('User not authenticated');

          const fileExt = logoFile.name.split('.').pop();
          const fileName = `clinic_logo_${Date.now()}.${fileExt}`;

          const { data: uploadData, error: uploadError } = await supabase.storage
            .from('branding')
            .upload(fileName, logoFile, { upsert: true });

          if (uploadError) {
            console.error('Upload error:', uploadError);
            throw new Error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„Ø´Ø¹Ø§Ø±: ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ bucket "branding" ÙÙŠ Supabase Storage');
          }

          const { data: urlData } = supabase.storage
            .from('branding')
            .getPublicUrl(fileName);

          logoUrl = urlData.publicUrl;
        } catch (uploadErr: any) {
          console.error('Logo upload failed:', uploadErr);
          throw uploadErr;
        }
      }

      const updateData = {
        clinic_name: updates.clinic_name ?? branding?.clinic_name,
        clinic_address: updates.clinic_address ?? branding?.clinic_address,
        clinic_phone: updates.clinic_phone ?? branding?.clinic_phone,
        primary_color: updates.primary_color ?? branding?.primary_color,
        secondary_color: updates.secondary_color ?? branding?.secondary_color,
        accent_color: updates.accent_color ?? branding?.accent_color,
        default_rx_notes: updates.default_rx_notes ?? branding?.default_rx_notes,
        ...(logoUrl && { logo_url: logoUrl }),
        updated_at: new Date().toISOString(),
      };

      setBranding(prev => prev ? { ...prev, ...updateData } : null);

      // Update local PowerSync DB (which will sync to Supabase)
      // Note: We assume there's only one row in app_settings
      const existing = await powerSyncDb.getAll('SELECT id FROM app_settings');

      if (existing.length > 0) {
        const id = (existing[0] as any).id;
        await powerSyncDb.execute(
          `UPDATE app_settings SET 
             clinic_name = ?, clinic_address = ?, clinic_phone = ?, 
             primary_color = ?, secondary_color = ?, accent_color = ?, 
             default_rx_notes = ?, logo_url = ?, updated_at = ? 
           WHERE id = ?`,
          [
            updateData.clinic_name, updateData.clinic_address, updateData.clinic_phone,
            updateData.primary_color, updateData.secondary_color, updateData.accent_color,
            updateData.default_rx_notes, updateData.logo_url, updateData.updated_at,
            id
          ]
        );
      } else {
        // Insert if not exists (though sync should handle this)
        await powerSyncDb.execute(
          `INSERT INTO app_settings (
             id, clinic_name, clinic_address, clinic_phone, 
             primary_color, secondary_color, accent_color, 
             default_rx_notes, logo_url, updated_at
           ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            crypto.randomUUID(), // Generate a new UUID if creating locally
            updateData.clinic_name, updateData.clinic_address, updateData.clinic_phone,
            updateData.primary_color, updateData.secondary_color, updateData.accent_color,
            updateData.default_rx_notes, updateData.logo_url, updateData.updated_at
          ]
        );
      }

    } catch (err) {
      console.error('Failed to update branding:', err);
      setError('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ©');
      throw err;
    }
  };

  const refreshBranding = async () => {
    await fetchBranding();
  };

  useEffect(() => {
    fetchBranding();
  }, []);

  return (
    <BrandingContext.Provider
      value={{
        branding: branding || getDefaultBranding(),
        loading,
        error,
        updateBranding,
        refreshBranding,
      }}
    >
      {children}
    </BrandingContext.Provider>
  );
};

export const useBranding = (): BrandingContextType => {
  const context = useContext(BrandingContext);
  if (context === undefined) {
    throw new Error('useBranding must be used within a BrandingProvider');
  }
  return context;
};
</file>

<file path="index.tsx">
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
import { PowerSyncProvider } from "./src/context/PowerSyncContext";
import "./styles.css";

const rootElement = document.getElementById("root");
if (rootElement) {
  const root = createRoot(rootElement);
  root.render(
    <React.StrictMode>
      <PowerSyncProvider>
        <App />
      </PowerSyncProvider>
    </React.StrictMode>
  );
}
</file>

<file path="pages/AdminDashboard.tsx">
import React, { useState, useEffect } from 'react';
import {
  Settings, Palette, FileText, Database, Upload, Save, AlertCircle,
  CheckCircle, Loader, Trash2, Edit2, X
} from 'lucide-react';
import toast from 'react-hot-toast';
import { useBranding } from '../context/BrandingContext';
import { supabase } from '../services/supabaseClient';
import { powerSyncDb } from '../src/powersync/client';
import { EGYPTIAN_DRUGS } from '../constants';
import RefreshButton from '../components/RefreshButton';

interface TabState {
  active: 'branding' | 'prescription' | 'records';
}

const AdminDashboard: React.FC = () => {
  const { branding, updateBranding, loading: brandingLoading } = useBranding();
  const [activeTab, setActiveTab] = useState<'branding' | 'prescription' | 'records'>('branding');
  const [saving, setSaving] = useState(false);
  const [logoPreview, setLogoPreview] = useState<string | null>(null);

  const [brandingData, setBrandingData] = useState({
    clinic_name: '',
    clinic_address: '',
    clinic_phone: '',
    primary_color: '#2d5a6b',
    secondary_color: '#00838f',
    accent_color: '#00bcd4',
  });

  const [prescriptionDefaults, setPrescriptionDefaults] = useState({
    instructions: '',
    defaultCategory: 'Vitamins & Supplements',
  });

  const [records, setRecords] = useState<any[]>([]);
  const [recordsLoading, setRecordsLoading] = useState(false);

  useEffect(() => {
    if (branding) {
      setBrandingData({
        clinic_name: branding.clinic_name,
        clinic_address: branding.clinic_address || '',
        clinic_phone: branding.clinic_phone || '',
        primary_color: branding.primary_color,
        secondary_color: branding.secondary_color,
        accent_color: branding.accent_color,
      });
      if (branding.logo_url) {
        setLogoPreview(branding.logo_url);
      }
    }
  }, [branding]);

  const handleLogoUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setLogoPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleBrandingSave = async () => {
    try {
      setSaving(true);
      const fileInput = document.querySelector('[type="file"]') as HTMLInputElement;
      const logoFile = fileInput?.files?.[0];

      if (!brandingData.clinic_name.trim()) {
        toast.error('ÙŠØ¬Ø¨ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©');
        return;
      }

      await updateBranding(
        {
          clinic_name: brandingData.clinic_name,
          clinic_address: brandingData.clinic_address,
          clinic_phone: brandingData.clinic_phone,
          primary_color: brandingData.primary_color,
          secondary_color: brandingData.secondary_color,
          accent_color: brandingData.accent_color,
        },
        logoFile
      );

      toast.success('ØªÙ… Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­');
      if (fileInput) fileInput.value = '';
    } catch (error: any) {
      console.error('Error saving branding:', error);
      const errorMsg = error?.message || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª';
      toast.error(errorMsg);
    } finally {
      setSaving(false);
    }
  };

  const loadRecords = async () => {
    try {
      setRecordsLoading(true);
      // Use PowerSync for offline access
      const data = await powerSyncDb.getAll(
        'SELECT id, date, patient_id, diagnosis, department FROM visits ORDER BY date DESC LIMIT 50'
      );

      setRecords(data || []);
    } catch (error: any) {
      console.error('Error loading records:', error);
      const errorMsg = error?.message || 'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³Ø¬Ù„Ø§Øª';
      toast.error(errorMsg);
    } finally {
      setRecordsLoading(false);
    }
  };

  useEffect(() => {
    if (activeTab === 'records') {
      loadRecords();
    }
  }, [activeTab]);

  const deleteRecord = async (id: string) => {
    if (!window.confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¬Ù„ØŸ')) return;

    try {
      // Use PowerSync for offline deletion
      await powerSyncDb.execute('DELETE FROM visits WHERE id = ?', [id]);

      setRecords(records.filter(r => r.id !== id));
      toast.success('ØªÙ… Ø­Ø°Ù Ø§Ù„Ø³Ø¬Ù„ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('Error deleting record:', error);
      toast.error('ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ø³Ø¬Ù„');
    }
  };

  return (
    <div className="space-y-6" dir="rtl">
      {/* Header */}
      <div className="flex items-center justify-between gap-3 mb-8">
        <div className="flex items-center gap-3">
          <div className="p-3 bg-indigo-100 rounded-lg">
            <Settings className="w-8 h-8 text-indigo-600" />
          </div>
          <div>
            <h1 className="text-3xl font-bold text-gray-900">Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</h1>
            <p className="text-gray-600">Ø¥Ø¯Ø§Ø±Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙˆØ§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¬Ø§Ø±ÙŠØ© ÙˆØ§Ù„Ø³Ø¬Ù„Ø§Øª</p>
          </div>
        </div>
        <RefreshButton />
      </div>

      {/* Tab Navigation */}
      <div className="flex gap-2 border-b border-gray-200">
        <button
          onClick={() => setActiveTab('branding')}
          className={`flex items-center gap-2 px-6 py-4 font-medium transition-colors ${activeTab === 'branding'
            ? 'border-b-2 border-indigo-600 text-indigo-600'
            : 'text-gray-600 hover:text-gray-900'
            }`}
        >
          <Palette size={20} />
          ØªØ®ØµÙŠØµ Ø§Ù„ØªØµÙ…ÙŠÙ…
        </button>
        <button
          onClick={() => setActiveTab('prescription')}
          className={`flex items-center gap-2 px-6 py-4 font-medium transition-colors ${activeTab === 'prescription'
            ? 'border-b-2 border-indigo-600 text-indigo-600'
            : 'text-gray-600 hover:text-gray-900'
            }`}
        >
          <FileText size={20} />
          Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±ÙˆØ´ØªØ©
        </button>
        <button
          onClick={() => setActiveTab('records')}
          className={`flex items-center gap-2 px-6 py-4 font-medium transition-colors ${activeTab === 'records'
            ? 'border-b-2 border-indigo-600 text-indigo-600'
            : 'text-gray-600 hover:text-gray-900'
            }`}
        >
          <Database size={20} />
          Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø³Ø¬Ù„Ø§Øª
        </button>
      </div>

      {/* Content */}
      <div className="bg-white rounded-lg shadow-md p-8">
        {/* Branding Tab */}
        {activeTab === 'branding' && (
          <div className="space-y-6">
            {/* Setup Guide */}
            <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 space-y-3">
              <h3 className="font-semibold text-amber-900 flex items-center gap-2">
                <AlertCircle className="w-5 h-5" />
                Ø¥Ø¹Ø¯Ø§Ø¯ ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø´Ø¹Ø§Ø±
              </h3>
              <div className="text-sm text-amber-800 space-y-2">
                <p>Ù„ØªÙ…ÙƒÙŠÙ† Ø±ÙØ¹ Ø§Ù„Ø´Ø¹Ø§Ø±Ø§ØªØŒ ØªØ§Ø¨Ø¹ Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ§Øª:</p>
                <ol className="list-decimal list-inside space-y-1 ml-2">
                  <li>Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ <strong>Supabase Dashboard â†’ Storage</strong></li>
                  <li>Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ <strong>Create new bucket</strong></li>
                  <li>Ø£Ø¯Ø®Ù„ Ø§Ù„Ø§Ø³Ù…: <code className="bg-amber-100 px-2 py-1 rounded">branding</code></li>
                  <li>Ø§Ø®ØªØ± <strong>Public bucket</strong></li>
                  <li>Ø§Ù†Ù‚Ø± <strong>Create bucket</strong></li>
                </ol>
              </div>
            </div>
            <div className="grid md:grid-cols-2 gap-6">
              {/* Clinic Name */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Ø§Ø³Ù… Ø§Ù„Ù…Ø±ÙƒØ² / Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©
                </label>
                <input
                  type="text"
                  value={brandingData.clinic_name}
                  onChange={(e) => setBrandingData(prev => ({
                    ...prev,
                    clinic_name: e.target.value
                  }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500"
                  placeholder="Ù…Ø«Ø§Ù„: Ù†Ø¸Ø§Ù… Ø¯ Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±"
                />
              </div>

              {/* Clinic Phone */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ
                </label>
                <input
                  type="tel"
                  value={brandingData.clinic_phone}
                  onChange={(e) => setBrandingData(prev => ({
                    ...prev,
                    clinic_phone: e.target.value
                  }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500"
                  placeholder="Ù…Ø«Ø§Ù„: 201001234567+"
                />
              </div>

              {/* Clinic Address */}
              <div className="md:col-span-2">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
                </label>
                <textarea
                  value={brandingData.clinic_address}
                  onChange={(e) => setBrandingData(prev => ({
                    ...prev,
                    clinic_address: e.target.value
                  }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500"
                  placeholder="Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©"
                  rows={3}
                />
              </div>
            </div>

            {/* Logo Upload */}
            <div className="border-t pt-6">
              <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                <Upload size={20} />
                Ø´Ø¹Ø§Ø± Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©
              </h3>
              <div className="grid md:grid-cols-2 gap-6">
                {/* Upload Area */}
                <div>
                  <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-indigo-500 transition-colors cursor-pointer">
                    <input
                      type="file"
                      accept="image/*"
                      onChange={handleLogoUpload}
                      className="hidden"
                      id="logo-upload"
                    />
                    <label htmlFor="logo-upload" className="cursor-pointer">
                      <Upload className="w-12 h-12 text-gray-400 mx-auto mb-2" />
                      <p className="text-sm text-gray-600">Ø§Ø¶ØºØ· Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø£Ùˆ Ø§Ø³Ø­Ø¨ Ø§Ù„Ù…Ù„Ù Ù‡Ù†Ø§</p>
                      <p className="text-xs text-gray-500">PNG, JPG, GIF (Ø­Ø¯ Ø£Ù‚ØµÙ‰ 5 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)</p>
                    </label>
                  </div>
                </div>

                {/* Preview */}
                {logoPreview && (
                  <div className="flex flex-col items-center justify-center">
                    <div className="bg-gray-50 rounded-lg p-4 w-full">
                      <img
                        src={logoPreview}
                        alt="Logo Preview"
                        className="w-32 h-32 object-contain mx-auto"
                      />
                    </div>
                    <p className="text-sm text-gray-600 mt-2">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø´Ø¹Ø§Ø±</p>
                  </div>
                )}
              </div>
            </div>

            {/* Colors */}
            <div className="border-t pt-6">
              <h3 className="text-lg font-semibold text-gray-900 mb-4">Ø§Ù„Ø£Ù„ÙˆØ§Ù†</h3>
              <div className="grid md:grid-cols-3 gap-6">
                {/* Primary Color */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
                  </label>
                  <div className="flex items-center gap-3">
                    <input
                      type="color"
                      value={brandingData.primary_color}
                      onChange={(e) => setBrandingData(prev => ({
                        ...prev,
                        primary_color: e.target.value
                      }))}
                      className="w-12 h-12 rounded cursor-pointer"
                    />
                    <input
                      type="text"
                      value={brandingData.primary_color}
                      onChange={(e) => setBrandingData(prev => ({
                        ...prev,
                        primary_color: e.target.value
                      }))}
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm"
                    />
                  </div>
                </div>

                {/* Secondary Color */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ
                  </label>
                  <div className="flex items-center gap-3">
                    <input
                      type="color"
                      value={brandingData.secondary_color}
                      onChange={(e) => setBrandingData(prev => ({
                        ...prev,
                        secondary_color: e.target.value
                      }))}
                      className="w-12 h-12 rounded cursor-pointer"
                    />
                    <input
                      type="text"
                      value={brandingData.secondary_color}
                      onChange={(e) => setBrandingData(prev => ({
                        ...prev,
                        secondary_color: e.target.value
                      }))}
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm"
                    />
                  </div>
                </div>

                {/* Accent Color */}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Ù„ÙˆÙ† Ø§Ù„ØªÙ…ÙŠÙŠØ²
                  </label>
                  <div className="flex items-center gap-3">
                    <input
                      type="color"
                      value={brandingData.accent_color}
                      onChange={(e) => setBrandingData(prev => ({
                        ...prev,
                        accent_color: e.target.value
                      }))}
                      className="w-12 h-12 rounded cursor-pointer"
                    />
                    <input
                      type="text"
                      value={brandingData.accent_color}
                      onChange={(e) => setBrandingData(prev => ({
                        ...prev,
                        accent_color: e.target.value
                      }))}
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm"
                    />
                  </div>
                </div>
              </div>
            </div>

            {/* Save Button */}
            <div className="flex gap-4 pt-6 border-t">
              <button
                onClick={handleBrandingSave}
                disabled={saving || brandingLoading}
                className="flex items-center gap-2 px-6 py-2 bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-400 text-white rounded-lg font-medium transition-colors"
              >
                {saving ? (
                  <>
                    <Loader size={18} className="animate-spin" />
                    Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...
                  </>
                ) : (
                  <>
                    <Save size={18} />
                    Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
                  </>
                )}
              </button>
            </div>
          </div>
        )}

        {/* Prescription Tab */}
        {activeTab === 'prescription' && (
          <div className="space-y-6">
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 flex gap-3">
              <AlertCircle className="w-5 h-5 text-blue-600 flex-shrink-0 mt-0.5" />
              <div>
                <h4 className="font-semibold text-blue-900">Ù…Ø¹Ù„ÙˆÙ…Ø©</h4>
                <p className="text-sm text-blue-700">
                  ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¯ÙˆÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠÙ…ÙƒÙ†Ùƒ Ù‡Ù†Ø§ ØªØ®ØµÙŠØµ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ø±ÙˆØ´ØªØ§Øª.
                </p>
              </div>
            </div>

            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ø£Ø¯ÙˆÙŠØ©
                </label>
                <select
                  value={prescriptionDefaults.defaultCategory}
                  onChange={(e) => setPrescriptionDefaults(prev => ({
                    ...prev,
                    defaultCategory: e.target.value
                  }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500"
                >
                  {Object.keys(EGYPTIAN_DRUGS).map(category => (
                    <option key={category} value={category}>
                      {category}
                    </option>
                  ))}
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ø±ÙˆØ´ØªØ©
                </label>
                <textarea
                  value={prescriptionDefaults.instructions}
                  onChange={(e) => setPrescriptionDefaults(prev => ({
                    ...prev,
                    instructions: e.target.value
                  }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500"
                  placeholder="Ù…Ø«Ø§Ù„: Ø§ØªØ¨Ø¹ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø¨Ø¯Ù‚Ø©... ØªÙ†Ø§ÙˆÙ„ Ø§Ù„Ø¯ÙˆØ§Ø¡ Ù…Ø¹ Ø§Ù„Ø·Ø¹Ø§Ù…..."
                  rows={4}
                />
              </div>

              <button
                onClick={() => {
                  toast.success('ØªÙ… Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±ÙˆØ´ØªØ©');
                }}
                className="flex items-center gap-2 px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-medium transition-colors"
              >
                <Save size={18} />
                Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
              </button>
            </div>

            {/* Available Drugs */}
            <div className="mt-8 border-t pt-8">
              <h3 className="text-lg font-semibold text-gray-900 mb-4">Ø§Ù„Ø£Ø¯ÙˆÙŠØ© Ø§Ù„Ù…ØªØ§Ø­Ø©</h3>
              <div className="grid md:grid-cols-2 gap-4">
                {Object.entries(EGYPTIAN_DRUGS).map(([category, drugs]) => (
                  <div key={category} className="bg-gray-50 rounded-lg p-4">
                    <h4 className="font-semibold text-gray-900 mb-2 text-right">{category}</h4>
                    <ul className="text-sm text-gray-600 space-y-1">
                      {Object.keys(drugs).slice(0, 5).map(drug => (
                        <li key={drug} className="text-right">â€¢ {drug}</li>
                      ))}
                      {Object.keys(drugs).length > 5 && (
                        <li className="text-gray-500">... Ùˆ {Object.keys(drugs).length - 5} Ø£Ø¯ÙˆÙŠØ© Ø£Ø®Ø±Ù‰</li>
                      )}
                    </ul>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* Records Tab */}
        {activeTab === 'records' && (
          <div className="space-y-6">
            <div className="flex justify-between items-center">
              <h3 className="text-lg font-semibold text-gray-900">Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ø·Ø¨ÙŠØ©</h3>
              <button
                onClick={loadRecords}
                className="text-indigo-600 hover:text-indigo-700 text-sm font-medium"
              >
                â† ØªØ­Ø¯ÙŠØ«
              </button>
            </div>

            {recordsLoading ? (
              <div className="flex items-center justify-center py-12">
                <Loader className="animate-spin w-8 h-8 text-indigo-600" />
              </div>
            ) : records.length === 0 ? (
              <div className="text-center py-12 text-gray-500">
                Ù„Ø§ ØªÙˆØ¬Ø¯ Ø³Ø¬Ù„Ø§Øª
              </div>
            ) : (
              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-4 py-3 text-right text-sm font-semibold text-gray-700">Ø§Ù„ØªØ§Ø±ÙŠØ®</th>
                      <th className="px-4 py-3 text-right text-sm font-semibold text-gray-700">Ø±Ù‚Ù… Ø§Ù„Ù…Ø±ÙŠØ¶</th>
                      <th className="px-4 py-3 text-right text-sm font-semibold text-gray-700">Ø§Ù„ØªØ´Ø®ÙŠØµ</th>
                      <th className="px-4 py-3 text-right text-sm font-semibold text-gray-700">Ø§Ù„Ù‚Ø³Ù…</th>
                      <th className="px-4 py-3 text-right text-sm font-semibold text-gray-700">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200">
                    {records.map(record => (
                      <tr key={record.id} className="hover:bg-gray-50">
                        <td className="px-4 py-3 text-sm text-gray-600">
                          {new Date(record.date).toLocaleDateString('ar-EG')}
                        </td>
                        <td className="px-4 py-3 text-sm text-gray-600">{record.patient_id}</td>
                        <td className="px-4 py-3 text-sm text-gray-600">{record.diagnosis || '-'}</td>
                        <td className="px-4 py-3 text-sm text-gray-600">{record.department || 'Ø¹Ø§Ù…'}</td>
                        <td className="px-4 py-3 text-sm">
                          <button
                            onClick={() => deleteRecord(record.id)}
                            className="text-red-600 hover:text-red-700 font-medium flex items-center gap-1"
                          >
                            <Trash2 size={16} />
                            Ø­Ø°Ù
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default AdminDashboard;
</file>

<file path="POWERSYNC_PUBLICATION_SETUP.sql">
-- ============================================================================
-- POWERSYNC PUBLICATION SETUP (ROBUST VERSION)
-- ============================================================================
-- Run this in Supabase SQL Editor. It will add all tables to the publication
-- and ignore any "already exists" errors.
-- ============================================================================

DO $$
DECLARE
    tables_to_add text[] := ARRAY[
        'patients', 
        'visits', 
        'ivf_cycles', 
        'stimulation_logs', 
        'pregnancies', 
        'antenatal_visits', 
        'biometry_scans', 
        'patient_files', 
        'doctors', 
        'app_settings'
    ];
    t text;
BEGIN
    -- Create publication if it doesn't exist
    IF NOT EXISTS (SELECT 1 FROM pg_publication WHERE pubname = 'powersync') THEN
        CREATE PUBLICATION powersync;
    END IF;

    -- Loop through tables and add them if not already in publication
    FOREACH t IN ARRAY tables_to_add LOOP
        BEGIN
            EXECUTE format('ALTER PUBLICATION powersync ADD TABLE public.%I', t);
        EXCEPTION WHEN duplicate_object THEN
            -- Ignore if table is already in publication
            RAISE NOTICE 'Table % is already in publication', t;
        END;
    END LOOP;
END $$;

-- Verify results
SELECT * FROM pg_publication_tables WHERE pubname = 'powersync';
</file>

<file path="public/sw.js">
// Service Worker for Nile IVF PWA
const CACHE_NAME = 'nile-ivf-v1';
const STATIC_CACHE = 'nile-ivf-static-v1';
const DYNAMIC_CACHE = 'nile-ivf-dynamic-v1';

// Assets to cache immediately
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/manifest.webmanifest',
  '/styles.css',
  // Add other static assets as needed
];

// Install event - cache static assets
self.addEventListener('install', (event) => {
  console.log('Service Worker: Installing...');
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('Service Worker: Caching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
      .catch((error) => {
        console.error('Service Worker: Failed to cache static assets:', error);
      })
  );
  self.skipWaiting();
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('Service Worker: Activating...');
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
            console.log('Service Worker: Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  self.clients.claim();
});

// Fetch event - serve from cache or network
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') return;

  // Handle Supabase API requests with network-first strategy
  if (url.hostname.includes('supabase.co')) {
    event.respondWith(
      fetch(request)
        .then((response) => {
          // Cache successful responses
          if (response.ok) {
            const responseClone = response.clone();
            caches.open(DYNAMIC_CACHE).then((cache) => {
              cache.put(request, responseClone);
            });
          }
          return response;
        })
        .catch(() => {
          // Fallback to cache if network fails
          return caches.match(request);
        })
    );
    return;
  }

  // Handle static assets with cache-first strategy
  event.respondWith(
    caches.match(request)
      .then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }

        return fetch(request)
          .then((response) => {
            // Cache successful responses
            if (response.ok && response.type === 'basic') {
              const responseClone = response.clone();
              caches.open(DYNAMIC_CACHE).then((cache) => {
                cache.put(request, responseClone);
              });
            }
            return response;
          })
          .catch((error) => {
            console.error('Service Worker: Fetch failed:', error);
            // Return offline fallback for navigation requests
            if (request.mode === 'navigate') {
              return caches.match('/index.html');
            }
          });
      })
  );
});

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  console.log('Service Worker: Background sync triggered:', event.tag);

  if (event.tag === 'sync-pending-data') {
    event.waitUntil(syncPendingData());
  }
});

// Function to sync pending data when back online
async function syncPendingData() {
  try {
    // This would integrate with the sync manager
    console.log('Service Worker: Syncing pending data...');
    // Implementation would go here
  } catch (error) {
    console.error('Service Worker: Failed to sync pending data:', error);
  }
}

// Push notifications (for future use)
self.addEventListener('push', (event) => {
  if (event.data) {
    const data = event.data.json();
    const options = {
      body: data.body,
      icon: '/pwa-192x192.png',
      badge: '/pwa-192x192.png',
      vibrate: [100, 50, 100],
      data: data.data
    };

    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  }
});

// Notification click handler
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  event.waitUntil(
    clients.openWindow(event.notification.data?.url || '/')
  );
});
</file>

<file path="src/components/HistorySidebar.tsx">
import React, { useState, useEffect } from 'react';
import { X, Copy, ChevronDown, ChevronUp, Activity, Scale, Baby } from 'lucide-react';
import { visitsService } from '../../services/visitsService';
import { Visit, PrescriptionItem } from '../../types';

interface HistorySidebarProps {
  patientId: string;
  category: 'GYNA' | 'OBS' | 'IVF' | 'ALL';
  isOpen: boolean;
  onClose: () => void;
  onCopyData?: (visit: Visit) => void;
  onCopyRx?: (prescription: PrescriptionItem[]) => void;
}

const HistorySidebar: React.FC<HistorySidebarProps> = ({
  patientId,
  category,
  isOpen,
  onClose,
  onCopyData,
  onCopyRx
}) => {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [loading, setLoading] = useState(false);
  const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set());

  useEffect(() => {
    if (isOpen && patientId) {
      fetchHistory();
    }
  }, [isOpen, patientId]);

  const fetchHistory = async () => {
    setLoading(true);
    try {
      const allVisits = await visitsService.getVisitsByPatient(patientId);
      const filteredVisits = category === 'ALL'
        ? allVisits
        : allVisits.filter(visit => visit.department === category);
      setVisits(filteredVisits);
    } catch (error) {
      console.error('Error fetching history:', error);
      setVisits([]);
    } finally {
      setLoading(false);
    }
  };

  const toggleExpanded = (visitId: string) => {
    const newExpanded = new Set(expandedItems);
    if (newExpanded.has(visitId)) {
      newExpanded.delete(visitId);
    } else {
      newExpanded.add(visitId);
    }
    setExpandedItems(newExpanded);
  };

  const getRelativeTime = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    if (diffDays === 0) return 'Ø§Ù„ÙŠÙˆÙ…';
    if (diffDays === 1) return 'Ø£Ù…Ø³';
    if (diffDays < 7) return `Ù…Ù†Ø° ${diffDays} Ø£ÙŠØ§Ù…`;
    if (diffDays < 30) return `Ù…Ù†Ø° ${Math.floor(diffDays / 7)} Ø£Ø³Ø§Ø¨ÙŠØ¹`;
    if (diffDays < 365) return `Ù…Ù†Ø° ${Math.floor(diffDays / 30)} Ø£Ø´Ù‡Ø±`;
    return `Ù…Ù†Ø° ${Math.floor(diffDays / 365)} Ø³Ù†ÙˆØ§Øª`;
  };

  const renderVisitSummary = (visit: Visit) => {
    const { department, clinical_data, diagnosis } = visit;

    if (department === 'OBS' && clinical_data) {
      const ga = clinical_data.gestational_age_weeks && clinical_data.gestational_age_days
        ? `${clinical_data.gestational_age_weeks}w+${clinical_data.gestational_age_days}d`
        : '-';
      const bp = clinical_data.systolic_bp && clinical_data.diastolic_bp
        ? `${clinical_data.systolic_bp}/${clinical_data.diastolic_bp}`
        : '-';
      const weight = clinical_data.weight_kg ? `${clinical_data.weight_kg}kg` : '-';

      const isBpAlert = clinical_data.systolic_bp && clinical_data.diastolic_bp &&
        (clinical_data.systolic_bp >= 140 || clinical_data.diastolic_bp >= 90);

      return (
        <div className="space-y-2">
          <div className="flex items-center gap-2 text-sm">
            <Baby size={14} className="text-blue-500" />
            <span className="font-medium">{ga}</span>
          </div>
          <div className="flex items-center gap-4 text-xs">
            <div className={`flex items-center gap-1 ${isBpAlert ? 'text-red-600' : 'text-gray-700'}`}>
              <Activity size={12} />
              <span>{bp}</span>
            </div>
            <div className="flex items-center gap-1 text-gray-700">
              <Scale size={12} />
              <span>{weight}</span>
            </div>
          </div>
        </div>
      );
    }

    if (department === 'GYNA') {
      return (
        <div className="space-y-2">
          <div className="text-sm font-medium text-purple-600 bg-purple-50 px-2 py-1 rounded">
            {diagnosis || 'Diagnosis'}
          </div>
          <div className="text-xs text-gray-600">
            {clinical_data?.complaint || 'Complaint'}
          </div>
        </div>
      );
    }

    if (department === 'IVF') {
      const protocol = clinical_data?.protocol || 'Protocol';
      const e2 = clinical_data?.e2 ? `${clinical_data.e2} pg/mL` : null;
      const follicleCount = clinical_data?.follicle_count ? `${clinical_data.follicle_count} follicles` : null;

      return (
        <div className="space-y-2">
          <div className="text-sm font-medium text-green-600">
            {protocol}
          </div>
          <div className="text-xs text-gray-600">
            {e2 || follicleCount || 'IVF Data'}
          </div>
        </div>
      );
    }

    return (
      <div className="text-sm text-gray-600">
        {diagnosis || 'Medical Visit'}
      </div>
    );
  };

  if (!isOpen) return null;

  return (
    <>
      {/* Backdrop */}
      <div
        className="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm z-40"
        onClick={onClose}
      />

      {/* Sidebar */}
      <div className="fixed right-0 top-0 h-full w-96 bg-white shadow-xl z-50 transform transition-transform duration-300 ease-in-out">
        <div className="flex flex-col h-full">
          {/* Header */}
          <div className="flex items-center justify-between p-4 border-b bg-teal-50">
            <h2 className="text-lg font-bold text-gray-900 font-[Tajawal]">
              ğŸ“œ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ø³Ø§Ø¨Ù‚ - {category === 'GYNA' ? 'Ø·Ø¨ Ø§Ù„Ù†Ø³Ø§Ø¡' : category === 'OBS' ? 'Ø§Ù„Ø­Ù…Ù„' : category === 'IVF' ? 'Ø§Ù„ØªÙ„Ù‚ÙŠØ­ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ' : 'Ø§Ù„ÙƒÙ„'}
            </h2>
            <button
              onClick={onClose}
              className="p-2 hover:bg-gray-200 rounded-full transition-colors"
            >
              <X size={20} />
            </button>
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto p-4">
            {loading ? (
              <div className="flex justify-center items-center py-8">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-teal-600"></div>
              </div>
            ) : visits.length === 0 ? (
              <div className="text-center py-8 text-gray-500">
                Ù„Ø§ ØªÙˆØ¬Ø¯ Ø³Ø¬Ù„Ø§Øª Ø³Ø§Ø¨Ù‚Ø©
              </div>
            ) : (
              <div className="space-y-4">
                {visits.map((visit) => (
                  <div key={visit.id} className="bg-gray-50 rounded-lg border border-gray-200 overflow-hidden">
                    {/* Header */}
                    <div className="p-3 border-b border-gray-200">
                      <div className="flex items-center justify-between">
                        <div className="text-sm font-bold text-gray-900">
                          {new Date(visit.date).toLocaleDateString('ar-EG')}
                        </div>
                        <div className="text-xs text-gray-500">
                          {getRelativeTime(visit.date)}
                        </div>
                      </div>
                    </div>

                    {/* Always Visible Summary Body */}
                    <div className="p-3 bg-gray-100 border-b border-gray-200">
                      {renderVisitSummary(visit)}
                    </div>

                    {/* Expand/Collapse Button */}
                    <div className="p-3 flex justify-between items-center">
                      <div className="flex items-center gap-2">
                        {onCopyData && (
                          <button
                            onClick={() => onCopyData(visit)}
                            className="p-1 text-teal-600 hover:bg-teal-100 rounded transition-colors"
                            title="Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"
                          >
                            <Copy size={14} />
                          </button>
                        )}
                      </div>
                      <button
                        onClick={() => toggleExpanded(visit.id)}
                        className="p-1 text-gray-600 hover:bg-gray-200 rounded transition-colors"
                      >
                        {expandedItems.has(visit.id) ? <ChevronUp size={14} /> : <ChevronDown size={14} />}
                      </button>
                    </div>

                    {/* Expanded Content */}
                    {expandedItems.has(visit.id) && (
                      <div className="p-3 bg-white">
                        {visit.notes && (
                          <div className="mb-3">
                            <h4 className="text-sm font-medium text-gray-900 mb-1">Ù…Ù„Ø§Ø­Ø¸Ø§Øª:</h4>
                            <p className="text-sm text-gray-700">{visit.notes}</p>
                          </div>
                        )}

                        {visit.prescription && visit.prescription.length > 0 && (
                          <div className="mb-3">
                            <h4 className="text-sm font-medium text-gray-900 mb-1">Ø§Ù„ÙˆØµÙØ© Ø§Ù„Ø·Ø¨ÙŠØ©:</h4>
                            <div className="space-y-1">
                              {visit.prescription.map((item, idx) => (
                                <div key={idx} className="text-sm text-gray-700 bg-gray-100 p-2 rounded">
                                  {item.drug} - {item.dose}
                                </div>
                              ))}
                            </div>
                          </div>
                        )}

                        {visit.clinical_data && Object.keys(visit.clinical_data).length > 0 && (
                          <div>
                            <h4 className="text-sm font-medium text-gray-900 mb-1">Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ±ÙŠØ©:</h4>
                            <div className="text-sm text-gray-700">
                              {Object.entries(visit.clinical_data).map(([key, value]) => (
                                <div key={key} className="flex justify-between py-1 border-b border-gray-100 last:border-b-0">
                                  <span className="capitalize">{key.replace(/_/g, ' ')}:</span>
                                  <span>{String(value)}</span>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    </>
  );
};

export default HistorySidebar;
</file>

<file path="src/context/PowerSyncContext.tsx">
import { PowerSyncContext } from "@powersync/react";
import { ReactNode } from "react";
import { powerSyncDb } from "../powersync/client";

export const PowerSyncProvider = ({ children }: { children: ReactNode }) => {
    return (
        <PowerSyncContext.Provider value={powerSyncDb}>
            {children}
        </PowerSyncContext.Provider>
    );
};
</file>

<file path="src/hooks/usePowerSync.ts">
import { useQuery, useStatus } from '@powersync/react';
import { powerSyncDb } from '../powersync/client';
import { supabase } from '../lib/supabase';
import { useState, useEffect } from 'react';

// Hook for querying PowerSync data with Supabase fallback
export function usePowerSyncQuery<T = any>(sql: string, parameters: any[] = []) {
    const powerSyncStatus = useStatus();
    const [supabaseData, setSupabaseData] = useState<T[]>([]);
    const [isLoadingSupabase, setIsLoadingSupabase] = useState(false);
    const [hasFetchedSupabase, setHasFetchedSupabase] = useState(false);
    
    // Try PowerSync first
    let powerSyncQueryResult;
    try {
        powerSyncQueryResult = useQuery<T>(sql, parameters);
    } catch (error) {
        console.warn('âš ï¸ PowerSync query failed, using Supabase fallback:', error);
        powerSyncQueryResult = { data: [], isLoading: false, error };
    }
    
    const { data: powerSyncData = [], isLoading: isLoadingPowerSync, error: powerSyncError } = powerSyncQueryResult;

    // Extract table name from SQL
    const tableMatch = sql.match(/FROM\s+(\w+)/i);
    const tableName = tableMatch ? tableMatch[1] : null;

    // Fallback to Supabase if PowerSync is not connected
    useEffect(() => {
        const fetchFromSupabase = async () => {
            // Only fetch once if PowerSync is not connected and we have no data
            if (!powerSyncStatus.connected && tableName && !hasFetchedSupabase && !isLoadingPowerSync) {
                setIsLoadingSupabase(true);
                setHasFetchedSupabase(true);
                
                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    if (!user) {
                        console.warn('âš ï¸ No user logged in for Supabase fallback');
                        setIsLoadingSupabase(false);
                        return;
                    }

                    console.log(`ğŸ”„ Fetching ${tableName} from Supabase (fallback mode)...`);
                    
                    // Build basic query
                    let query = supabase.from(tableName).select('*');
                    
                    // Handle WHERE clause with parameters
                    if (parameters.length > 0 && sql.includes('WHERE')) {
                        const whereMatch = sql.match(/WHERE\s+(.+?)(?:\s+ORDER|\s+LIMIT|$)/i);
                        if (whereMatch) {
                            const whereClause = whereMatch[1];
                            // Handle common patterns: patient_id = ?, doctor_id = ?
                            if (whereClause.includes('patient_id = ?')) {
                                query = query.eq('patient_id', parameters[0]);
                            } else if (whereClause.includes('doctor_id = ?')) {
                                query = query.eq('doctor_id', parameters[0]);
                            } else if (whereClause.includes('id = ?')) {
                                query = query.eq('id', parameters[0]);
                            }
                        }
                    }
                    
                    // Handle ORDER BY
                    const orderMatch = sql.match(/ORDER\s+BY\s+(\w+)(?:\s+(ASC|DESC))?/i);
                    if (orderMatch) {
                        const orderColumn = orderMatch[1];
                        const orderDirection = orderMatch[2]?.toLowerCase() === 'desc' ? { ascending: false } : { ascending: true };
                        query = query.order(orderColumn, orderDirection);
                    }
                    
                    const { data, error } = await query;
                    
                    if (error) {
                        console.error(`âŒ Error fetching ${tableName} from Supabase:`, error);
                    } else if (data && data.length > 0) {
                        console.log(`âœ… Fetched ${data.length} records from Supabase (${tableName})`);
                        setSupabaseData(data as T[]);
                    } else {
                        console.log(`â„¹ï¸ No data found in Supabase for ${tableName}`);
                    }
                } catch (error) {
                    console.error(`âŒ Error in Supabase fallback for ${tableName}:`, error);
                } finally {
                    setIsLoadingSupabase(false);
                }
            }
        };

        fetchFromSupabase();
    }, [powerSyncStatus.connected, tableName, hasFetchedSupabase, isLoadingPowerSync]);

    // Reset Supabase fetch flag when PowerSync connects
    useEffect(() => {
        if (powerSyncStatus.connected) {
            setHasFetchedSupabase(false);
            setSupabaseData([]);
        }
    }, [powerSyncStatus.connected]);

    // Return PowerSync data if connected and has data, otherwise return Supabase fallback
    const data = powerSyncStatus.connected && powerSyncData.length > 0 
        ? powerSyncData 
        : (supabaseData.length > 0 ? supabaseData : powerSyncData);
    
    const isLoading = isLoadingPowerSync || isLoadingSupabase;
    const error = powerSyncError;

    return { data, isLoading, error };
}

// Helper hooks for common queries
export function usePowerSyncPatients() {
    return usePowerSyncQuery('SELECT * FROM patients ORDER BY name');
}

export function usePowerSyncVisits(patientId?: string) {
    if (patientId) {
        return usePowerSyncQuery('SELECT * FROM visits WHERE patient_id = ? ORDER BY date DESC', [patientId]);
    }
    return usePowerSyncQuery('SELECT * FROM visits ORDER BY date DESC');
}

export function usePowerSyncCycles(patientId?: string) {
    if (patientId) {
        return usePowerSyncQuery('SELECT * FROM ivf_cycles WHERE patient_id = ? ORDER BY start_date DESC', [patientId]);
    }
    return usePowerSyncQuery('SELECT * FROM ivf_cycles ORDER BY start_date DESC');
}

// Direct database access for writes
export { powerSyncDb as db };
</file>

<file path="src/hooks/useSyncStatus.ts">
import { useEffect, useState } from 'react';
import { useStatus } from '@powersync/react';

export interface SyncStatus {
  isOnline: boolean;
  syncInProgress: boolean;
  pendingItemsCount: number;
  lastSyncTime?: Date;
}

export const useSyncStatus = (): SyncStatus => {
  const status = useStatus() as any;

  return {
    isOnline: status.connected,
    syncInProgress: status.uploading || status.downloading,
    pendingItemsCount: 0, // PowerSync handles this internally
    lastSyncTime: status.lastSyncedAt
  };
};

export const useNetworkStatus = () => {
  const [isOnline, setIsOnline] = useState<boolean>(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
};
</file>

<file path="src/lib/powerSyncHelpers.ts">
// PowerSync Query Helpers
// Use these instead of Dexie queries

import { powerSyncDb as powerSync } from '../powersync/client';
import { useQuery } from '@powersync/react';

// Hook to get all patients
export const usePatients = () => {
    return useQuery('SELECT * FROM patients ORDER BY name');
};

// Hook to get all visits
export const useVisits = () => {
    return useQuery('SELECT * FROM visits ORDER BY date DESC');
};

// Hook to get all IVF cycles
export const useIVFCycles = () => {
    return useQuery('SELECT * FROM ivf_cycles ORDER BY start_date DESC');
};

// Hook to get all pregnancies
export const usePregnancies = () => {
    return useQuery('SELECT * FROM pregnancies ORDER BY lmp_date DESC');
};

// Hook to get visits by patient
export const useVisitsByPatient = (patientId: string) => {
    return useQuery('SELECT * FROM visits WHERE patient_id = ? ORDER BY date DESC', [patientId]);
};

// Hook to get cycles by patient
export const useCyclesByPatient = (patientId: string) => {
    return useQuery('SELECT * FROM ivf_cycles WHERE patient_id = ? ORDER BY start_date DESC', [patientId]);
};

// Hook to get stimulation logs by cycle
export const useStimulationLogsByCycle = (cycleId: string) => {
    return useQuery('SELECT * FROM stimulation_logs WHERE cycle_id = ? ORDER BY cycle_day', [cycleId]);
};

// Hook to get pregnancies by patient
export const usePregnanciesByPatient = (patientId: string) => {
    return useQuery('SELECT * FROM pregnancies WHERE patient_id = ?', [patientId]);
};

// Direct database operations (for mutations)
export const db = {
    patients: {
        async add(data: any) {
            const id = crypto.randomUUID();
            await powerSync.execute(
                'INSERT INTO patients (id, name, age, phone, husband_name, history, doctor_id) VALUES (?, ?, ?, ?, ?, ?, ?)',
                [id, data.name, data.age, data.phone, data.husband_name, data.history, data.doctor_id]
            );
            return { id };
        },
        async update(id: string, data: any) {
            const fields = Object.keys(data).map(k => `${k} = ?`).join(', ');
            const values = [...Object.values(data), id];
            await powerSync.execute(`UPDATE patients SET ${fields} WHERE id = ?`, values);
        },
        async delete(id: string) {
            await powerSync.execute('DELETE FROM patients WHERE id = ?', [id]);
        },
        async toArray() {
            const result = await powerSync.getAll('SELECT * FROM patients');
            return result;
        }
    },

    visits: {
        async add(data: any) {
            const id = crypto.randomUUID();
            await powerSync.execute(
                'INSERT INTO visits (id, patient_id, date, department, diagnosis, prescription, notes, clinical_data) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
                [id, data.patient_id, data.date, data.department, data.diagnosis, data.prescription, data.notes, data.clinical_data]
            );
            return { id };
        }
    },

    ivf_cycles: {
        async add(data: any) {
            const id = crypto.randomUUID();
            await powerSync.execute(
                'INSERT INTO ivf_cycles (id, patient_id, doctor_id, protocol, status, start_date, assessment_data, lab_data, transfer_data, outcome_data) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                [id, data.patient_id, data.doctor_id, data.protocol, data.status, data.start_date, data.assessment_data, data.lab_data, data.transfer_data, data.outcome_data]
            );
            return { id };
        },
        async where(field: string) {
            return {
                equals: async (value: string) => {
                    const result = await powerSync.getAll(`SELECT * FROM ivf_cycles WHERE ${field} = ?`, [value]);
                    return {
                        toArray: async () => result
                    };
                }
            };
        }
    },

    stimulation_logs: {
        async add(data: any) {
            const id = crypto.randomUUID();
            await powerSync.execute(
                'INSERT INTO stimulation_logs (id, cycle_id, cycle_day, date, fsh, hmg, e2, lh, rt_follicles, lt_follicles) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                [id, data.cycle_id, data.cycle_day, data.date, data.fsh, data.hmg, data.e2, data.lh, data.rt_follicles, data.lt_follicles]
            );
            return { id };
        },
        async where(field: string) {
            return {
                equals: async (value: string) => {
                    const result = await powerSync.getAll(`SELECT * FROM stimulation_logs WHERE ${field} = ?`, [value]);
                    return {
                        toArray: async () => result
                    };
                }
            };
        }
    },

    pregnancies: {
        async add(data: any) {
            const id = crypto.randomUUID();
            await powerSync.execute(
                'INSERT INTO pregnancies (id, patient_id, doctor_id, lmp_date, edd_date, edd_by_scan, risk_level, risk_factors, aspirin_prescribed, thromboprophylaxis_needed) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                [id, data.patient_id, data.doctor_id, data.lmp_date, data.edd_date, data.edd_by_scan, data.risk_level, data.risk_factors, data.aspirin_prescribed, data.thromboprophylaxis_needed]
            );
            return { id };
        }
    }
};
</file>

<file path="src/lib/pwa.ts">
// PWA Registration and Management
export const registerServiceWorker = async (): Promise<void> => {
  if ('serviceWorker' in navigator) {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/'
      });

      console.log('Service Worker registered successfully:', registration.scope);

      // Handle updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        if (newWorker) {
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New version available
              showUpdateNotification();
            }
          });
        }
      });

      // Handle controller change (new SW activated)
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        window.location.reload();
      });

    } catch (error) {
      console.error('Service Worker registration failed:', error);
    }
  }
};

const showUpdateNotification = (): void => {
  // Create a toast or notification for app update
  const updateToast = document.createElement('div');
  updateToast.className = 'fixed top-4 left-4 right-4 z-50 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-lg';
  updateToast.innerHTML = `
    <div class="flex items-center justify-between">
      <div>
        <p class="font-semibold">ØªØ­Ø¯ÙŠØ« Ù…ØªØ§Ø­</p>
        <p class="text-sm">ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ·Ø¨ÙŠÙ‚. Ø§Ù†Ù‚Ø± Ù„Ù„ØªØ­Ø¯ÙŠØ«</p>
      </div>
      <button id="update-btn" class="bg-white text-blue-600 px-3 py-1 rounded text-sm font-semibold hover:bg-gray-100">
        ØªØ­Ø¯ÙŠØ«
      </button>
    </div>
  `;

  document.body.appendChild(updateToast);

  document.getElementById('update-btn')?.addEventListener('click', () => {
    window.location.reload();
  });

  // Auto-hide after 10 seconds
  setTimeout(() => {
    updateToast.remove();
  }, 10000);
};

// Check if app is installed
export const isPWAInstalled = (): boolean => {
  return window.matchMedia('(display-mode: standalone)').matches ||
         (window.navigator as any).standalone === true;
};

// Request notification permission
export const requestNotificationPermission = async (): Promise<NotificationPermission> => {
  if ('Notification' in window) {
    return await Notification.requestPermission();
  }
  return 'denied';
};

// Check online status
export const isOnline = (): boolean => {
  return navigator.onLine;
};

// Listen for online/offline events
export const setupNetworkListeners = (
  onOnline: () => void,
  onOffline: () => void
): void => {
  window.addEventListener('online', onOnline);
  window.addEventListener('offline', onOffline);
};

// Initialize PWA features
export const initPWA = async (): Promise<void> => {
  // Suppress manifest.json 401 errors (non-critical)
  const originalError = console.error;
  const manifestErrorHandler = (...args: any[]) => {
    const message = args[0]?.toString() || '';
    if (message.includes('manifest.json') && message.includes('401')) {
      // Suppress manifest.json 401 errors - they're non-critical
      return;
    }
    originalError.apply(console, args);
  };
  
  // Temporarily replace console.error to suppress manifest errors
  console.error = manifestErrorHandler as any;

  try {
    // Register service worker
    await registerServiceWorker();

    // Request notification permission
    const permission = await requestNotificationPermission();
    if (permission === 'granted') {
      console.log('Notification permission granted');
    }

    // Log PWA status
    console.log('PWA Status:', {
      installed: isPWAInstalled(),
      online: isOnline(),
      notifications: permission
    });
  } finally {
    // Restore original console.error after a delay
    setTimeout(() => {
      console.error = originalError;
    }, 2000);
  }
};
</file>

<file path="src/powersync/connector.ts">
/// <reference types="vite/client" />
import { PowerSyncBackendConnector } from '@powersync/web';
import { supabase } from '../lib/supabase';

export class AppConfig {
    static readonly SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
    static readonly SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;
    static readonly POWERSYNC_URL = import.meta.env.VITE_POWERSYNC_URL;
}

export class Connector implements PowerSyncBackendConnector {
    async fetchCredentials() {
        const { data: { session }, error } = await supabase.auth.getSession();
        if (!session || error) {
            throw new Error('Could not fetch credentials');
        }

        return {
            endpoint: AppConfig.POWERSYNC_URL,
            token: session.access_token
        };
    }

    async uploadData(database: any) {
        // Upload logic if needed, usually handled by Supabase automatically via triggers
        // But for PowerSync, we might need to handle writes if we are using local-only tables or custom sync
        // For now, we assume writes go to Supabase directly or via PowerSync's write-back (if configured)
        // Since we are using Supabase as the backend, PowerSync handles the sync from Supabase to local.
        // Writes should be done to PowerSync local DB and then synced back?
        // PowerSync Web SDK handles uploadData by calling this method.
        // We need to implement the upload logic here.

        const transaction = await database.getNextCrudTransaction();
        if (!transaction) return;

        try {
            // Process transaction
            await transaction.complete();
        } catch (error) {
            console.error('Upload failed', error);
            // await transaction.reject();
        }
    }
}
</file>

<file path="types.ts">
export interface Patient {
  id?: string | number;
  name: string;
  age?: number;
  phone: string;
  husbandName?: string;
  history?: string;
  createdAt?: string;
}

export interface Visit {
  id: string;
  patientId: string;
  date: string;
  department?: string; // 'GYNA', 'OBS', 'IVF_STIM', 'IVF_LAB'
  diagnosis: string;
  prescription: PrescriptionItem[];
  notes: string;
  clinical_data?: any; // JSONB for structured clinical data
  vitals?: {
    weight?: number;
    height?: number;
    bmi?: number;
  };
}

export interface PrescriptionItem {
  category: string;
  drug: string;
  dose: string;
}

export interface MaleFactorAssessment {
  volume?: number;
  concentration?: number;
  motility?: number;
  morphology?: number;
  tmsc?: number;
  diagnosis?: string;
  icsiIndicated?: boolean;
}

export interface FemaleFactorAssessment {
  amh?: number;
  fsh?: number;
  lh?: number;
  e2?: number;
  afcRight?: number;
  afcLeft?: number;
  ovaryClassification?: 'Poor Responder' | 'Normal' | 'High Responder';
}

export interface TubalUterineAssessment {
  hsgFindings?: string;
  hysteroscopyFindings?: string;
  septate?: boolean;
  polyps?: boolean;
  adhesions?: boolean;
}

export interface CoupleProfileAssessment {
  age?: number;
  infertilityDuration?: number;
  infertilityType?: 'Primary' | 'Secondary';
  previousAttempts?: number;
  height?: number;
  weight?: number;
  bmi?: number;
  bmiAlert?: boolean;
}

export interface ImagingAssessment {
  baselineUltrasound: {
    uterus: { dimensions: string, myometrium: string, cavity: string };
    endometrium: { thickness: number, pattern: string };
    ovaries: {
      afcRight: number;
      afcLeft: number;
      pathology: { cyst: boolean, endometrioma: boolean, dermoid: boolean };
    };
    adnexa: { hydrosalpinx: boolean };
  };
  hysteroscopyHSG: {
    status: string[];
    actionTaken: string;
  };
}

export interface CycleAssessment {
  coupleProfile?: CoupleProfileAssessment;
  maleFactor?: MaleFactorAssessment;
  femaleFactor?: FemaleFactorAssessment;
  tubalUterine?: TubalUterineAssessment;
  imaging?: ImagingAssessment;
}

export interface StimulationLog {
  id: string;
  date: string;
  cycleDay: number;
  fsh: string;
  hmg: string;
  e2: string;
  lh: string;
  rtFollicles: string;
  ltFollicles: string;
  endometriumThickness?: string;
}

export interface OpuLabData {
  opuDate?: string;
  totalOocytes?: number;
  mii?: number;
  mi?: number;
  gv?: number;
  atretic?: number;
  maturationRate?: number;
  fertilizedTwoPN?: number;
  fertilizationRate?: number;
  embryoDay3A?: number;
  embryoDay3B?: number;
  embryoDay3C?: number;
  blastocystsExpanded?: number;
  blastocystsHatching?: number;
}

export interface TransferData {
  transferDate?: string;
  numberTransferred?: number;
  embryoQuality?: string;
  catheterDifficulty?: 'Easy' | 'Moderate' | 'Difficult';
  lutealSupport?: string[];
}

export interface OutcomeData {
  betaHcg?: number;
  betaHcgPositive?: boolean;
  clinicalPregnancy?: boolean;
  gestationalSac?: boolean;
  fHR?: boolean;
}

export interface IvfCycle {
  id: string;
  patientId: string;
  protocol: 'Long' | 'Antagonist' | 'Flare-up' | 'Mini-IVF';
  startDate: string;
  status: 'Active' | 'Completed' | 'Cancelled';
  assessment?: CycleAssessment;
  logs: StimulationLog[];
  lab?: OpuLabData;
  transfer?: TransferData;
  outcome?: OutcomeData;
  cycleData?: any;
}

export interface Doctor {
  id: string;
  user_id: string;
  email: string;
  name: string;
  specialization?: string;
  phone?: string;
  created_at?: string;
  doctor_image?: string;
  clinic_name?: string;
  clinic_address?: string;
  clinic_phone?: string;
  clinic_image?: string;
  clinic_latitude?: string;
  clinic_longitude?: string;
}

export interface Pregnancy {
  id: string;
  patient_id: string;
  lmp_date?: string;
  edd_date?: string;
  edd_by_scan?: string;
  ga_at_booking?: number;
  risk_level: 'low' | 'moderate' | 'high';
  risk_factors: string[];
  aspirin_prescribed: boolean;
  thromboprophylaxis_needed: boolean;
  created_at?: string;
  updated_at?: string;
}

export interface AntenatalVisit {
  id: string;
  pregnancy_id: string;
  visit_date: string;
  gestational_age_weeks: number;
  gestational_age_days: number;
  systolic_bp?: number;
  diastolic_bp?: number;
  weight_kg?: number;
  urine_albuminuria?: string;
  urine_glycosuria?: string;
  fetal_heart_sound?: boolean;
  fundal_height_cm?: number;
  edema?: boolean;
  edema_grade?: string;
  notes?: string;
  next_visit_date?: string;
  prescription?: PrescriptionItem[];
  created_at?: string;
}

export interface BiometryScan {
  id: string;
  pregnancy_id: string;
  scan_date: string;
  gestational_age_weeks: number;
  gestational_age_days: number;
  bpd_mm?: number;
  hc_mm?: number;
  ac_mm?: number;
  fl_mm?: number;
  efw_grams?: number;
  percentile?: number;
  notes?: string;
  created_at?: string;
}

export interface ObstetricsData {
  id?: string;
  patientId: string;
  lmp: string | null;
  edd: string | null;
  gestationalAge?: string;
  riskFactors: string[];
  isHighRisk: boolean;
  notes?: string;
}

export interface AntenatalVisitData {
  id: string;
  date: string;
  gaWeeks: number;
  bp: string;
  weight: string;
  urine: string;
  fetalHeart: string;
  fundalHeight?: string;
  edema?: string;
  notes: string;
}

export interface FetalBiometryData {
  date: string;
  bpd?: number;
  fl?: number;
  ac?: number;
  hc?: number;
  efw?: number;
  afi?: number;
  placenta?: string;
}

export enum Page {
  HOME = 'home',
  RECEPTION = 'reception',
  CLINICAL = 'clinical',
  GYNECOLOGY = 'gynecology',
  IVF = 'ivf',
  PATIENT_RECORD = 'patient_record',
  SETTINGS = 'settings',
  OBSTETRICS = 'obstetrics',
  ADMIN = 'admin'
}
</file>

<file path="vercel.json">
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": { "distDir": "dist" }
    }
  ],
  "routes": [
    {
      "src": "/manifest.json",
      "dest": "/manifest.json",
      "headers": {
        "Cache-Control": "public, max-age=3600",
        "Content-Type": "application/manifest+json"
      }
    },
    {
      "src": "/manifest.webmanifest",
      "dest": "/manifest.webmanifest",
      "headers": {
        "Cache-Control": "public, max-age=3600",
        "Content-Type": "application/manifest+json"
      }
    },
    {
      "src": "/(.*)",
      "dest": "/$1"
    }
  ],
  "headers": [
    {
      "source": "/manifest.json",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=3600"
        },
        {
          "key": "Content-Type",
          "value": "application/manifest+json"
        }
      ]
    }
  ]
}
</file>

<file path="README.md">
<div align="center">
<img width="1200" height="475" alt="Dr Salah IVF Center" src="https://images.unsplash.com/photo-1576091160550-2173dba999ef?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" />
</div>

# ğŸ¥ Ù…Ø±ÙƒØ² Ø¯ ØµÙ„Ø§Ø­ Ù„Ù„Ø®ØµÙˆØ¨Ø©
## Ù…Ø¹Ø§ÙƒÙ… Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ©

**Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø¹ÙŠØ§Ø¯Ø© Ø§Ù„Ø®ØµÙˆØ¨Ø© ÙˆØ§Ù„ØªÙˆÙ„ÙŠØ¯** - ØªØ·ÙˆÙŠØ± Ø¯. Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±

Ù†Ø¸Ø§Ù… Ø´Ø§Ù…Ù„ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø¹ÙŠØ§Ø¯Ø§Øª Ø§Ù„Ø®ØµÙˆØ¨Ø© ÙˆØ§Ù„ØªÙˆÙ„ÙŠØ¯ Ù…Ø¹ ÙˆØ§Ø¬Ù‡Ø© Ø³Ù‡Ù„Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙˆØ£Ø¯ÙˆØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„ØªØªØ¨Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø§Øª ÙˆØ§Ù„Ø­Ù…Ù„.

## âœ¨ Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª

- ğŸ“Š **ØªØªØ¨Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø§Øª**: Ù…ØªØ§Ø¨Ø¹Ø© Ø´Ø§Ù…Ù„Ø© Ù„Ø¯ÙˆØ±Ø§Øª Ø§Ù„ØªÙ„Ù‚ÙŠØ­ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
- ğŸ‘¶ **Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ù…Ù„**: Ù†Ø¸Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„ Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø­Ù…Ù„ ÙˆØ§Ù„ÙˆÙ„Ø§Ø¯Ø©
- ğŸ’Š **Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø¯ÙˆÙŠØ©**: Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø£Ø¯ÙˆÙŠØ© Ø§Ù„Ù…ØµØ±ÙŠØ©
- ğŸ“± **ØªØµÙ…ÙŠÙ… Ù…ØªØ¬Ø§ÙˆØ¨**: ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©
- ğŸ”’ **Ø¢Ù…Ù† ÙˆÙ…ÙˆØ«ÙˆÙ‚**: Ù…ØµØ§Ø¯Ù‚Ø© Ø¢Ù…Ù†Ø© ÙˆÙ‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­Ù…ÙŠØ©

## ğŸš€ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø­Ù„ÙŠ

**Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª:** Node.js

1. **ØªØ«Ø¨ÙŠØª Ø§Ù„ØªØ¨Ø¹ÙŠØ§Øª:**
   ```bash
   npm install
   ```

2. **Ø¥Ø¹Ø¯Ø§Ø¯ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©:**
   Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù `.env` ÙÙŠ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ÙˆØ£Ø¶Ù Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:
   ```env
   VITE_SUPABASE_URL=https://your-project.supabase.co
   VITE_SUPABASE_ANON_KEY=your-anon-key-here
   VITE_POWERSYNC_URL=https://6938cd7948645822f36663c8.powersync.journeyapps.com
   ```
   
   **ÙƒÙŠÙÙŠØ© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ…:**
   - `VITE_SUPABASE_URL` Ùˆ `VITE_SUPABASE_ANON_KEY`: Ù…Ù† Supabase Dashboard > Settings > API
   - `VITE_POWERSYNC_URL`: Ø§Ù„Ø±Ø§Ø¨Ø· Ù…ÙˆØ¬ÙˆØ¯ Ø£Ø¹Ù„Ø§Ù‡ØŒ Ø£Ùˆ Ù…Ù† PowerSync Dashboard > Settings > Instance URL
   
   **Ù…Ù„Ø§Ø­Ø¸Ø©:** Ø±Ø§Ø¬Ø¹ Ù…Ù„Ù `ENV_SETUP.md` Ù„Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©

3. **ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚:**
   ```bash
   npm run dev
   ```

4. **ÙØªØ­ Ø§Ù„Ù…ØªØµÙØ­:**
   Ø§Ù†ØªÙ‚Ù„ Ø¥Ù„Ù‰ `http://localhost:5173`

## ğŸ”§ Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

### Ù…Ø´ÙƒÙ„Ø©: "ØºÙŠØ± Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±"

Ø¥Ø°Ø§ Ø¸Ù‡Ø±Øª Ø±Ø³Ø§Ù„Ø© "ØºÙŠØ± Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±" ÙÙŠ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ØŒ Ø§ØªØ¨Ø¹ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:

1. **ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©:**
   - ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ù„Ù `.env` ÙÙŠ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
   - ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù‚ÙŠÙ… ÙÙŠ Ø§Ù„Ù…Ù„Ù
   - Ø£Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø³ÙŠØ±ÙØ± Ø§Ù„ØªØ·ÙˆÙŠØ± Ø¨Ø¹Ø¯ ØªØ¹Ø¯ÙŠÙ„ `.env`

2. **ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª:**
   - ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª
   - ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…ØªØµÙØ­ Ù„ÙŠØ³ ÙÙŠ ÙˆØ¶Ø¹ Ø£ÙˆÙÙ„Ø§ÙŠÙ†

3. **ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„:**
   - ØªØ£ÙƒØ¯ Ù…Ù† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
   - Ø¬Ø±Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ ÙˆØ§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰

4. **ØªØ­Ù‚Ù‚ Ù…Ù† Console:**
   - Ø§ÙØªØ­ Developer Tools (F12)
   - Ø§Ø¨Ø­Ø« Ø¹Ù† Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø®Ø·Ø£ ÙÙŠ Console
   - Ø§Ø¨Ø­Ø« Ø¹Ù† Ø±Ø³Ø§Ø¦Ù„ ØªØ¨Ø¯Ø£ Ø¨Ù€ `âŒ` Ø£Ùˆ `âš ï¸`

5. **Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©:**
   - Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙŠØ­Ø§ÙˆÙ„ Ø§Ù„Ø§ØªØµØ§Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ
   - ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© "ØºÙŠØ± Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±" Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹

### Ù…Ø´ÙƒÙ„Ø©: Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù„Ø§ ØªØ¸Ù‡Ø±

Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù„Ø§ ØªØ¸Ù‡Ø±:

1. **ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„:**
   - ØªØ£ÙƒØ¯ Ù…Ù† Ø¸Ù‡ÙˆØ± "Ù…ØªØµÙ„" ÙÙŠ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
   - Ø¥Ø°Ø§ Ø¸Ù‡Ø± "ØºÙŠØ± Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±"ØŒ Ø§ØªØ¨Ø¹ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø£Ø¹Ù„Ø§Ù‡

2. **Ø§Ù†ØªØ¸Ø± Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©:**
   - Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ø¨Ø¹Ø¶ Ø§Ù„ÙˆÙ‚Øª
   - ØªØ­Ù‚Ù‚ Ù…Ù† Console Ù„Ù…Ø¹Ø±ÙØ© Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©

3. **ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©:**
   - Ø¬Ø±Ø¨ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø© (F5)
   - ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù…Ø´Ø§ÙƒÙ„ ÙÙŠ Cache

## ğŸ“‹ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©

- **Frontend:** React + TypeScript + Tailwind CSS
- **Backend:** Supabase
- **Charts:** Recharts
- **Icons:** Lucide React
- **UI Components:** Custom components with RTL support

## ğŸ“ Ø§Ù„ØªÙˆØ§ØµÙ„

**Ø§Ù„Ù…Ø·ÙˆØ±:** Ø¯. Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±
**Ø§Ù„Ù…Ø±ÙƒØ²:** Ù…Ø±ÙƒØ² Ø¯ ØµÙ„Ø§Ø­ Ù„Ù„Ø®ØµÙˆØ¨Ø©

---

<div align="center">
ØªÙ… Ø§Ù„ØªØ·ÙˆÙŠØ± Ø¨ÙˆØ§Ø³Ø·Ø© Ø¯. Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø± Â© 2025
</div>
</file>

<file path="src/components/SyncStatus.tsx">
import React from 'react';
import { Cloud, CloudOff, RefreshCw, AlertTriangle } from 'lucide-react';
import { useSyncStatus } from '../hooks/useSyncStatus';

interface SyncStatusProps {
  className?: string;
}

const SyncStatus: React.FC<SyncStatusProps> = ({ className = '' }) => {
  // Get sync statistics from PowerSync
  const { isOnline, syncInProgress, lastSyncTime } = useSyncStatus();
  const pending = 0; // Not available in PowerSync hook directly
  const errors = 0; // Not available in PowerSync hook directly

  const hasPendingItems = pending > 0;
  const hasErrors = errors > 0;

  // Determine status and styling
  const getStatusInfo = () => {
    if (!isOnline) {
      return {
        icon: CloudOff,
        color: 'text-gray-500',
        bgColor: 'bg-gray-100',
        text: 'Offline Mode',
        description: hasPendingItems ? `${pending} items pending` : 'All data saved locally'
      };
    }

    if (hasErrors) {
      return {
        icon: AlertTriangle,
        color: 'text-red-600',
        bgColor: 'bg-red-100',
        text: 'Sync Issues',
        description: `${errors} items failed to sync`
      };
    }

    if (syncInProgress) {
      return {
        icon: RefreshCw,
        color: 'text-yellow-600',
        bgColor: 'bg-yellow-100',
        text: 'Syncing...',
        description: 'Synchronizing data...'
      };
    }

    return {
      icon: Cloud,
      color: 'text-green-600',
      bgColor: 'bg-green-100',
      text: 'All Synced',
      description: lastSyncTime ? `Last synced: ${new Date(lastSyncTime).toLocaleTimeString()}` : 'Synced'
    };
  };

  const statusInfo = getStatusInfo();
  const Icon = statusInfo.icon;

  return (
    <div className={`flex items-center gap-2 ${className}`}>
      <div className={`flex items-center gap-2 px-3 py-1 rounded-full ${statusInfo.bgColor}`}>
        <Icon
          className={`w-4 h-4 ${statusInfo.color} ${syncInProgress ? 'animate-spin' : ''}`}
        />
        <div className="flex flex-col">
          <span className={`text-sm font-medium ${statusInfo.color}`}>
            {statusInfo.text}
          </span>
          <span className="text-xs text-gray-600">
            {statusInfo.description}
          </span>
        </div>
      </div>

      {/* Additional info for pending items */}
      {syncInProgress && isOnline && (
        <div className="text-xs text-yellow-600">
          Auto-sync in progress...
        </div>
      )}

      {/* Error indicator */}
      {hasErrors && (
        <div className="text-xs text-red-600">
          Check connection
        </div>
      )}
    </div>
  );
};

export default SyncStatus;
</file>

<file path="src/lib/supabase.ts">
/// <reference types="vite/client" />
import { createClient, SupabaseClient } from '@supabase/supabase-js';

// Get environment variables
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Validate environment variables
if (!supabaseUrl) {
  console.error('âŒ VITE_SUPABASE_URL is not configured');
  console.error('âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© VITE_SUPABASE_URL ÙÙŠ Ù…Ù„Ù .env');
  console.error('âŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù† Supabase Dashboard > Settings > API');
}

if (!supabaseKey) {
  console.error('âŒ VITE_SUPABASE_ANON_KEY is not configured');
  console.error('âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© VITE_SUPABASE_ANON_KEY ÙÙŠ Ù…Ù„Ù .env');
  console.error('âŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙØªØ§Ø­ Ù…Ù† Supabase Dashboard > Settings > API');
}

// Create Supabase client with optimized options
export const supabase: SupabaseClient = createClient(
  supabaseUrl || '', // Fallback to empty string if not configured
  supabaseKey || '', // Fallback to empty string if not configured
  {
    auth: {
      // Automatically refresh tokens before they expire
      autoRefreshToken: true,
      // Persist session in localStorage
      persistSession: true,
      // Detect session from URL hash (for OAuth redirects)
      detectSessionInUrl: true,
      // Storage key for session
      storageKey: 'supabase.auth.token',
      // Storage implementation (defaults to localStorage)
      storage: typeof window !== 'undefined' ? window.localStorage : undefined,
    },
    // Global fetch options
    global: {
      headers: {
        'x-client-info': 'nile-ivf-emr@1.0.0',
      },
    },
    // Realtime options (if needed in future)
    realtime: {
      params: {
        eventsPerSecond: 10,
      },
    },
  }
);

// Helper function to check if Supabase is properly configured
export function isSupabaseConfigured(): boolean {
  return !!(supabaseUrl && supabaseKey);
}

// Helper function to get configuration status
export function getSupabaseConfigStatus(): {
  urlConfigured: boolean;
  keyConfigured: boolean;
  fullyConfigured: boolean;
} {
  return {
    urlConfigured: !!supabaseUrl,
    keyConfigured: !!supabaseKey,
    fullyConfigured: !!(supabaseUrl && supabaseKey),
  };
}

// Log configuration status in development
if (import.meta.env.DEV) {
  const configStatus = getSupabaseConfigStatus();
  if (configStatus.fullyConfigured) {
    console.log('âœ… Supabase configured successfully');
    console.log('ğŸ”— URL:', supabaseUrl?.substring(0, 30) + '...');
  } else {
    console.warn('âš ï¸ Supabase configuration incomplete:');
    console.warn('   URL:', configStatus.urlConfigured ? 'âœ“' : 'âœ—');
    console.warn('   Key:', configStatus.keyConfigured ? 'âœ“' : 'âœ—');
  }
}
</file>

<file path="src/powersync/AppSchema.ts">
import { column, Schema, Table } from '@powersync/web';

const patients = new Table({
  name: column.text,
  age: column.integer,
  phone: column.text,
  husband_name: column.text,
  history: column.text,
  doctor_id: column.text
});

const visits = new Table({
  patient_id: column.text,
  date: column.text,
  department: column.text,
  diagnosis: column.text,
  prescription: column.text,
  notes: column.text,
  clinical_data: column.text
});

const ivf_cycles = new Table({
  patient_id: column.text,
  doctor_id: column.text,
  protocol: column.text,
  status: column.text,
  start_date: column.text,
  assessment_data: column.text,
  lab_data: column.text,
  transfer_data: column.text,
  outcome_data: column.text
});

const stimulation_logs = new Table({
  cycle_id: column.text,
  cycle_day: column.integer,
  date: column.text,
  fsh: column.text,
  hmg: column.text,
  e2: column.text,
  lh: column.text,
  rt_follicles: column.text,
  lt_follicles: column.text,
  endometrium_thickness: column.text
});

const pregnancies = new Table({
  patient_id: column.text,
  doctor_id: column.text,
  lmp_date: column.text,
  edd_date: column.text,
  edd_by_scan: column.text,
  risk_level: column.text,
  risk_factors: column.text,
  aspirin_prescribed: column.integer,
  thromboprophylaxis_needed: column.integer
});

const antenatal_visits = new Table({
  pregnancy_id: column.text,
  visit_date: column.text,
  gestational_age_weeks: column.integer,
  gestational_age_days: column.integer,
  weight_kg: column.real,
  systolic_bp: column.integer,
  diastolic_bp: column.integer,
  urine_albuminuria: column.text,
  urine_glycosuria: column.text,
  fetal_heart_sound: column.integer,
  fundal_height_cm: column.real,
  edema: column.integer,
  edema_grade: column.text,
  notes: column.text,
  next_visit_date: column.text
});

const biometry_scans = new Table({
  pregnancy_id: column.text,
  scan_date: column.text,
  gestational_age_weeks: column.integer,
  gestational_age_days: column.integer,
  efw_grams: column.integer,
  percentile: column.integer,
  bpd_mm: column.real,
  hc_mm: column.real,
  ac_mm: column.real,
  fl_mm: column.real,
  notes: column.text
});

const patient_files = new Table({
  patient_id: column.text,
  file_url: column.text,
  file_type: column.text,
  file_name: column.text
});

const doctors = new Table({
  user_id: column.text,
  email: column.text,
  name: column.text,
  specialization: column.text,
  phone: column.text,
  doctor_image: column.text,
  clinic_name: column.text,
  clinic_address: column.text,
  clinic_phone: column.text,
  clinic_image: column.text,
  clinic_latitude: column.text,
  clinic_longitude: column.text
});

const profiles = new Table({
  email: column.text,
  name: column.text,
  role: column.text
});

const app_settings = new Table({
  clinic_name: column.text,
  logo_url: column.text,
  primary_color: column.text,
  secondary_color: column.text
});

export const AppSchema = new Schema({
  patients,
  visits,
  ivf_cycles,
  stimulation_logs,
  pregnancies,
  antenatal_visits,
  biometry_scans,
  patient_files,
  doctors,
  profiles,
  app_settings
});
</file>

<file path="POWERSYNC_SYNC_RULES.yaml">
# PowerSync Sync Rules for IVF & OB/GYN Center
# Copy this content to your PowerSync Dashboard under "Sync Rules"

bucket_definitions:
  global:
    data:
      - SELECT id, name, age, phone, husband_name, history, doctor_id FROM patients
      - SELECT id, patient_id, date, department, diagnosis, prescription, notes, clinical_data FROM visits
      - SELECT id, patient_id, doctor_id, protocol, status, start_date, assessment_data, lab_data, transfer_data, outcome_data FROM ivf_cycles
      - SELECT id, cycle_id, cycle_day, date, fsh, hmg, e2, lh, rt_follicles, lt_follicles FROM stimulation_logs
      - SELECT id, patient_id, doctor_id, lmp_date, edd_date, edd_by_scan, risk_level, risk_factors, aspirin_prescribed, thromboprophylaxis_needed FROM pregnancies
      - SELECT id, pregnancy_id, visit_date, gestational_age_weeks, gestational_age_days, weight_kg, systolic_bp, diastolic_bp, urine_albuminuria, urine_glycosuria, fetal_heart_sound, fundal_height_cm, edema, edema_grade, notes, next_visit_date FROM antenatal_visits
      - SELECT id, pregnancy_id, scan_date, efw_grams, percentile, bpd_mm, hc_mm, ac_mm, fl_mm, notes FROM biometry_scans
      - SELECT id, patient_id, file_url, file_type, file_name FROM patient_files
      - SELECT id, user_id, email, name, specialization, phone, doctor_image, clinic_name, clinic_address, clinic_phone FROM doctors
      - SELECT id, clinic_name, logo_url, clinic_address, clinic_phone, primary_color, secondary_color, accent_color FROM app_settings
      - SELECT id, patient_id, amh, cycle_regularity, sperm_count, motility, morphology, left_tube, right_tube, cavity_status, diagnosis, plan FROM infertility_workups
</file>

<file path="src/hooks/usePatients.ts">
import { usePowerSync } from '@powersync/react';
import { usePowerSyncQuery } from './usePowerSync';
import { supabase } from '../lib/supabase';
import { useState, useEffect } from 'react';
import { useStatus } from '@powersync/react';

export interface Patient {
    id: string;
    name: string;
    age: number;
    phone: string;
    husband_name: string;
    history: string;
    doctor_id: string;
    created_at?: string;
    updated_at?: string;
    remoteId?: string; // For compatibility with existing code
}

export function usePatients() {
    const powerSync = usePowerSync();
    const powerSyncStatus = useStatus();
    const [supabasePatients, setSupabasePatients] = useState<Patient[]>([]);
    const [isLoadingSupabase, setIsLoadingSupabase] = useState(false);

    // Live query for all patients from PowerSync
    const { data: powerSyncData = [], isLoading: isLoadingPowerSync, error: powerSyncError } = usePowerSyncQuery<Patient>(
        'SELECT * FROM patients ORDER BY created_at DESC'
    );

    // Fallback: Fetch from Supabase directly if PowerSync is not connected
    useEffect(() => {
        const fetchFromSupabase = async () => {
            // Only fetch from Supabase if PowerSync is not connected and we have no data
            if (!powerSyncStatus.connected && powerSyncData.length === 0 && !isLoadingPowerSync) {
                setIsLoadingSupabase(true);
                try {
                    const user = await supabase.auth.getUser();
                    if (user.data.user) {
                        const { data, error } = await supabase
                            .from('patients')
                            .select('*')
                            .order('created_at', { ascending: false });
                        
                        if (error) {
                            console.error('âŒ Error fetching patients from Supabase:', error);
                        } else if (data) {
                            console.log('âœ… Fetched patients from Supabase:', data.length);
                            setSupabasePatients(data as Patient[]);
                        }
                    }
                } catch (error) {
                    console.error('âŒ Error in Supabase fallback:', error);
                } finally {
                    setIsLoadingSupabase(false);
                }
            }
        };

        fetchFromSupabase();
    }, [powerSyncStatus.connected, powerSyncData.length, isLoadingPowerSync]);

    // Use PowerSync data if available, otherwise use Supabase fallback
    const patients = powerSyncStatus.connected && powerSyncData.length > 0 
        ? powerSyncData 
        : (supabasePatients.length > 0 ? supabasePatients : powerSyncData);
    
    const isLoading = isLoadingPowerSync || isLoadingSupabase;
    const error = powerSyncError;

    console.log('ğŸ”„ usePatients hook:', { 
        patients: patients.length, 
        isLoading, 
        error,
        powerSyncConnected: powerSyncStatus.connected,
        source: powerSyncStatus.connected ? 'PowerSync' : 'Supabase'
    });

    const addPatient = async (patient: Omit<Patient, 'id' | 'created_at' | 'updated_at'>) => {
        const id = crypto.randomUUID();
        const now = new Date().toISOString();
        await powerSync.execute(
            'INSERT INTO patients (id, name, age, phone, husband_name, history, doctor_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
            [id, patient.name, patient.age, patient.phone, patient.husband_name, patient.history, patient.doctor_id, now, now]
        );
        return id;
    };

    const updatePatient = async (id: string, patient: Partial<Patient>) => {
        // Construct dynamic update query
        const updates: string[] = [];
        const values: any[] = [];

        Object.entries(patient).forEach(([key, value]) => {
            if (key !== 'id' && key !== 'created_at' && key !== 'updated_at' && key !== 'remoteId') {
                updates.push(`${key} = ?`);
                values.push(value);
            }
        });

        if (updates.length === 0) return;

        updates.push('updated_at = ?');
        values.push(new Date().toISOString());
        values.push(id);

        await powerSync.execute(
            `UPDATE patients SET ${updates.join(', ')} WHERE id = ?`,
            values
        );
    };

    const deletePatient = async (id: string) => {
        await powerSync.execute('DELETE FROM patients WHERE id = ?', [id]);
    };

    return {
        patients,
        isLoading,
        error,
        addPatient,
        updatePatient,
        deletePatient
    };
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ù…Ø±ÙƒØ² Ø¯ ØµÙ„Ø§Ø­ Ù„Ù„Ø®ØµÙˆØ¨Ø© - Ù†Ø¸Ø§Ù… Ø¯. Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±</title>
    <meta name="author" content="Dr. Mohamed Salah Gabr">
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#00838f">
    <meta name="description" content="Comprehensive IVF and Obstetrics Management System">
    <link rel="manifest" href="/manifest.webmanifest">
    <link rel="apple-touch-icon" href="/pwa-192x192.png">
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css">
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.1/",
    "react/": "https://aistudiocdn.com/react@^19.2.1/",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.555.0",
    "react-hot-toast": "https://aistudiocdn.com/react-hot-toast@^2.6.0",
    "recharts": "https://aistudiocdn.com/recharts@^3.5.1",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.1.1",
    "vite": "https://aistudiocdn.com/vite@^7.2.6",
    "@supabase/supabase-js": "https://aistudiocdn.com/@supabase/supabase-js@^2.86.2"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>
</file>

<file path="pages/Dashboard.tsx">
import React, { useEffect, useState, useMemo } from 'react';
import {
  Users, Activity, Calendar, TrendingUp, AlertTriangle, CheckCircle,
  Clock, Search, Filter, Plus, Eye, Edit, Phone, MapPin,
  BarChart3, PieChart, CalendarDays, Bell, Download, RefreshCw,
  Stethoscope, Baby, Microscope, UserCheck, Loader2
} from 'lucide-react';
import {
  AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer,
  PieChart as RechartsPieChart, Pie, Cell, BarChart, Bar, LineChart, Line
} from 'recharts';
import { usePowerSyncQuery } from '../src/hooks/usePowerSync';
import { db as ivfService } from '../services/ivfService';
import { obstetricsService } from '../services/obstetricsService';
import { Patient, IvfCycle, Pregnancy } from '../types';
import { useBranding } from '../context/BrandingContext';

import toast from 'react-hot-toast';

const Dashboard: React.FC = () => {
  const { branding } = useBranding();
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedDepartment, setSelectedDepartment] = useState<string>('all');


  // Live queries for real-time data
  const { data: patients = [] } = usePowerSyncQuery<Patient>('SELECT * FROM patients');
  const { data: cycles = [] } = usePowerSyncQuery<any>('SELECT * FROM ivf_cycles');
  const { data: pregnancies = [] } = usePowerSyncQuery<any>('SELECT * FROM pregnancies');

  // Calculate comprehensive stats
  const stats = useMemo(() => {
    if (!patients || !cycles || !pregnancies) return null;

    const activeCycles = cycles.filter((c: any) => c.status === 'Active').length;
    const completedCycles = cycles.filter((c: any) => c.status === 'Completed').length;
    const highRiskPregnancies = pregnancies.filter((p: any) => p.risk_level === 'high').length;
    const totalPregnancies = pregnancies.length;

    // Mock today's visits (would come from visits table)
    const todayVisits = Math.floor(Math.random() * 15) + 5;

    // Calculate success rates
    const successfulCycles = cycles.filter((c: any) => {
      try {
        const outcome = c.outcome_data ? JSON.parse(c.outcome_data) : {};
        return outcome.clinicalPregnancy;
      } catch (e) {
        return false;
      }
    }).length;
    const successRate = cycles.length > 0 ? Math.round((successfulCycles / cycles.length) * 100) : 0;

    return {
      totalPatients: patients.length,
      activeCycles,
      completedCycles,
      totalPregnancies,
      highRiskPregnancies,
      todayVisits,
      successRate,
      pendingLabs: Math.floor(Math.random() * 8) + 2, // Mock
      upcomingAppointments: Math.floor(Math.random() * 12) + 3 // Mock
    };
  }, [patients, cycles, pregnancies]);

  // Filter patients based on search and department
  const filteredPatients = useMemo(() => {
    if (!patients) return [];

    return patients.filter(patient => {
      const matchesSearch = searchTerm === '' ||
        patient.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        patient.phone.includes(searchTerm);

      const matchesDepartment = selectedDepartment === 'all' ||
        (selectedDepartment === 'ivf' && cycles.some((c: any) => c.patient_id === patient.id || c.patient_id === String(patient.id))) ||
        (selectedDepartment === 'ob' && pregnancies.some((p: any) => p.patient_id === patient.id || p.patient_id === String(patient.id)));

      return matchesSearch && matchesDepartment;
    }).slice(0, 10); // Show top 10
  }, [patients, cycles, pregnancies, searchTerm, selectedDepartment]);

  // Mock data for charts
  const monthlyGrowth = [
    { month: 'Jan', patients: 45, cycles: 12, pregnancies: 8 },
    { month: 'Feb', patients: 52, cycles: 15, pregnancies: 10 },
    { month: 'Mar', patients: 61, cycles: 18, pregnancies: 12 },
    { month: 'Apr', patients: 78, cycles: 22, pregnancies: 15 },
    { month: 'May', patients: 89, cycles: 25, pregnancies: 18 },
    { month: 'Jun', patients: 95, cycles: 28, pregnancies: 20 },
  ];

  const cycleOutcomes = [
    { name: 'Successful', value: stats?.successRate || 0, color: '#10B981' },
    { name: 'Ongoing', value: 100 - (stats?.successRate || 0), color: '#3B82F6' },
  ];

  const departmentStats = [
    { name: 'IVF', patients: cycles?.length || 0, color: '#8B5CF6' },
    { name: 'Obstetrics', patients: pregnancies?.length || 0, color: '#F59E0B' },
    { name: 'Gynecology', patients: Math.floor((patients?.length || 0) * 0.6), color: '#EF4444' },
  ];

  // Set loading to false once we have data
  useEffect(() => {
    if (patients !== undefined && cycles !== undefined && pregnancies !== undefined) {
      setLoading(false);
    }
  }, [patients, cycles, pregnancies]);

  const handleRefresh = async () => {
    try {
      // Refresh logic if needed, or just toast
      toast.success('Data refreshed');
    } catch (error) {
      toast.error('Failed to refresh data');
    }
  };

  const getPatientStatus = (patient: Patient) => {
    const patientId = patient.id?.toString();
    const hasActiveCycle = cycles?.some((c: any) => c.patient_id === patientId && c.status === 'Active');
    const hasPregnancy = pregnancies?.some((p: any) => p.patient_id === patientId);

    if (hasActiveCycle) return { status: 'IVF Active', color: 'bg-purple-100 text-purple-800' };
    if (hasPregnancy) return { status: 'Pregnancy Care', color: 'bg-pink-100 text-pink-800' };
    return { status: 'General Care', color: 'bg-gray-100 text-gray-800' };
  };

  if (loading || patients === undefined || cycles === undefined || pregnancies === undefined) {
    return (
      <div className="flex h-[80vh] items-center justify-center">
        <div className="text-center">
          <Loader2 className="w-12 h-12 animate-spin text-teal-600 mx-auto mb-4" />
          <p className="text-gray-600">Loading dashboard...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white border-b border-gray-200 px-4 py-6 md:px-8">
        <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
          <div>
            <h1 className="text-3xl font-bold text-gray-900 font-[Tajawal]">
              {branding?.clinic_name || 'Nile IVF & OB/GYN Center'}
            </h1>
            <p className="text-gray-600 mt-1">Professional Clinic Management Dashboard</p>
          </div>

          <div className="flex items-center gap-3">
            {/* Refresh Button */}
            <button
              onClick={handleRefresh}
              className="flex items-center gap-2 px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700 transition-colors"
            >
              <RefreshCw className="w-4 h-4" />
              Refresh
            </button>
          </div>
        </div>
      </div>

      <div className="px-4 py-6 md:px-8 space-y-6">
        {/* Advanced KPI Cards */}
        <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
          <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-500">Total Patients</p>
                <p className="text-2xl font-bold text-gray-900">{stats.totalPatients}</p>
              </div>
              <Users className="w-8 h-8 text-blue-600" />
            </div>
          </div>

          <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-500">Active IVF Cycles</p>
                <p className="text-2xl font-bold text-purple-600">{stats.activeCycles}</p>
              </div>
              <Microscope className="w-8 h-8 text-purple-600" />
            </div>
          </div>

          <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-500">Pregnancy Care</p>
                <p className="text-2xl font-bold text-pink-600">{stats.totalPregnancies}</p>
              </div>
              <Baby className="w-8 h-8 text-pink-600" />
            </div>
          </div>

          <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-500">Success Rate</p>
                <p className="text-2xl font-bold text-green-600">{stats.successRate}%</p>
              </div>
              <CheckCircle className="w-8 h-8 text-green-600" />
            </div>
          </div>

          <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-500">Today's Visits</p>
                <p className="text-2xl font-bold text-orange-600">{stats.todayVisits}</p>
              </div>
              <Calendar className="w-8 h-8 text-orange-600" />
            </div>
          </div>

          <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-500">High Risk Cases</p>
                <p className="text-2xl font-bold text-red-600">{stats.highRiskPregnancies}</p>
              </div>
              <AlertTriangle className="w-8 h-8 text-red-600" />
            </div>
          </div>
        </div>

        {/* Main Content Grid */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Patient Overview */}
          <div className="lg:col-span-2 space-y-6">
            {/* Search and Filters */}
            <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
              <div className="flex flex-col sm:flex-row gap-4 mb-4">
                <div className="flex-1 relative">
                  <Search className="w-5 h-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                  <input
                    type="text"
                    placeholder="Search patients by name or phone..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                  />
                </div>
                <select
                  value={selectedDepartment}
                  onChange={(e) => setSelectedDepartment(e.target.value)}
                  className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                >
                  <option value="all">All Departments</option>
                  <option value="ivf">IVF Patients</option>
                  <option value="ob">Obstetrics</option>
                  <option value="gyn">Gynecology</option>
                </select>
              </div>

              {/* Patient List */}
              <div className="space-y-3 max-h-96 overflow-y-auto">
                {filteredPatients.map((patient) => {
                  const status = getPatientStatus(patient);
                  return (
                    <div key={patient.id} className="flex items-center justify-between p-4 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors">
                      <div className="flex items-center gap-3">
                        <div className="w-10 h-10 bg-teal-100 rounded-full flex items-center justify-center">
                          <span className="text-teal-700 font-semibold">{patient.name.charAt(0)}</span>
                        </div>
                        <div>
                          <h4 className="font-semibold text-gray-900">{patient.name}</h4>
                          <p className="text-sm text-gray-600">{patient.phone}</p>
                        </div>
                      </div>
                      <div className="flex items-center gap-3">
                        <span className={`px-2 py-1 rounded-full text-xs font-medium ${status.color}`}>
                          {status.status}
                        </span>
                        <div className="flex gap-1">
                          <button className="p-2 text-gray-400 hover:text-teal-600 transition-colors">
                            <Eye className="w-4 h-4" />
                          </button>
                          <button className="p-2 text-gray-400 hover:text-teal-600 transition-colors">
                            <Edit className="w-4 h-4" />
                          </button>
                          <button className="p-2 text-gray-400 hover:text-teal-600 transition-colors">
                            <Phone className="w-4 h-4" />
                          </button>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>

            {/* Charts */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {/* Growth Chart */}
              <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
                <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                  <TrendingUp className="w-5 h-5 text-teal-600" />
                  Monthly Growth
                </h3>
                <div className="h-64">
                  <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={monthlyGrowth}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="month" />
                      <YAxis />
                      <Tooltip />
                      <Line type="monotone" dataKey="patients" stroke="#00838f" strokeWidth={2} />
                      <Line type="monotone" dataKey="cycles" stroke="#8B5CF6" strokeWidth={2} />
                    </LineChart>
                  </ResponsiveContainer>
                </div>
              </div>

              {/* Success Rate */}
              <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
                <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                  <CheckCircle className="w-5 h-5 text-green-600" />
                  IVF Success Rate
                </h3>
                <div className="h-64 flex items-center justify-center">
                  <ResponsiveContainer width="100%" height="100%">
                    <RechartsPieChart>
                      <Pie
                        data={cycleOutcomes}
                        innerRadius={60}
                        outerRadius={80}
                        paddingAngle={5}
                        dataKey="value"
                      >
                        {cycleOutcomes.map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={entry.color} />
                        ))}
                      </Pie>
                      <Tooltip />
                    </RechartsPieChart>
                  </ResponsiveContainer>
                </div>
                <div className="text-center mt-4">
                  <p className="text-2xl font-bold text-gray-900">{stats.successRate}%</p>
                  <p className="text-sm text-gray-600">Success Rate</p>
                </div>
              </div>
            </div>
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            {/* Department Overview */}
            <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
              <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                <BarChart3 className="w-5 h-5 text-teal-600" />
                Department Overview
              </h3>
              <div className="space-y-4">
                {departmentStats.map((dept, index) => (
                  <div key={index} className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <div className="w-3 h-3 rounded-full" style={{ backgroundColor: dept.color }}></div>
                      <span className="text-sm font-medium text-gray-700">{dept.name}</span>
                    </div>
                    <span className="text-sm font-semibold text-gray-900">{dept.patients}</span>
                  </div>
                ))}
              </div>
            </div>

            {/* Alerts & Notifications */}
            <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
              <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                <Bell className="w-5 h-5 text-orange-600" />
                Alerts & Notifications
              </h3>
              <div className="space-y-3">
                <div className="flex items-start gap-3 p-3 bg-red-50 rounded-lg">
                  <AlertTriangle className="w-5 h-5 text-red-600 mt-0.5" />
                  <div>
                    <p className="text-sm font-medium text-red-900">High Risk Pregnancy</p>
                    <p className="text-xs text-red-700">Patient requires immediate attention</p>
                  </div>
                </div>
                <div className="flex items-start gap-3 p-3 bg-yellow-50 rounded-lg">
                  <Clock className="w-5 h-5 text-yellow-600 mt-0.5" />
                  <div>
                    <p className="text-sm font-medium text-yellow-900">Pending Lab Results</p>
                    <p className="text-xs text-yellow-700">{stats.pendingLabs} results awaiting review</p>
                  </div>
                </div>
                <div className="flex items-start gap-3 p-3 bg-blue-50 rounded-lg">
                  <Calendar className="w-5 h-5 text-blue-600 mt-0.5" />
                  <div>
                    <p className="text-sm font-medium text-blue-900">Upcoming Appointments</p>
                    <p className="text-xs text-blue-700">{stats.upcomingAppointments} scheduled for today</p>
                  </div>
                </div>
              </div>
            </div>

            {/* Today's Schedule */}
            <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
              <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                <CalendarDays className="w-5 h-5 text-teal-600" />
                Today's Schedule
              </h3>
              <div className="space-y-3">
                <div className="flex items-center gap-3 p-3 bg-blue-50 rounded-lg">
                  <div className="w-2 h-2 bg-blue-600 rounded-full"></div>
                  <div>
                    <p className="text-sm font-medium text-blue-900">Dr. Ahmed - IVF Consultation</p>
                    <p className="text-xs text-blue-700">10:00 AM - 10:30 AM</p>
                  </div>
                </div>
                <div className="flex items-center gap-3 p-3 bg-purple-50 rounded-lg">
                  <div className="w-2 h-2 bg-purple-600 rounded-full"></div>
                  <div>
                    <p className="text-sm font-medium text-purple-900">Ultrasound - Pregnancy Check</p>
                    <p className="text-xs text-purple-700">11:00 AM - 11:30 AM</p>
                  </div>
                </div>
                <div className="flex items-center gap-3 p-3 bg-green-50 rounded-lg">
                  <div className="w-2 h-2 bg-green-600 rounded-full"></div>
                  <div>
                    <p className="text-sm font-medium text-green-900">Lab Results Review</p>
                    <p className="text-xs text-green-700">2:00 PM - 2:30 PM</p>
                  </div>
                </div>
              </div>
            </div>

            {/* Quick Actions */}
            <div className="bg-white p-6 rounded-xl shadow-sm border border-gray-100">
              <h3 className="text-lg font-semibold text-gray-900 mb-4">Quick Actions</h3>
              <div className="space-y-3">
                <button className="w-full flex items-center gap-3 p-3 bg-teal-50 hover:bg-teal-100 rounded-lg transition-colors">
                  <Plus className="w-5 h-5 text-teal-600" />
                  <span className="text-sm font-medium text-teal-900">New Patient</span>
                </button>
                <button className="w-full flex items-center gap-3 p-3 bg-purple-50 hover:bg-purple-100 rounded-lg transition-colors">
                  <Microscope className="w-5 h-5 text-purple-600" />
                  <span className="text-sm font-medium text-purple-900">Start IVF Cycle</span>
                </button>
                <button className="w-full flex items-center gap-3 p-3 bg-pink-50 hover:bg-pink-100 rounded-lg transition-colors">
                  <Baby className="w-5 h-5 text-pink-600" />
                  <span className="text-sm font-medium text-pink-900">Add Pregnancy</span>
                </button>
                <button
                  onClick={() => {
                    // Mock export functionality
                    toast.success('Report exported successfully');
                  }}
                  className="w-full flex items-center gap-3 p-3 bg-gray-50 hover:bg-gray-100 rounded-lg transition-colors"
                >
                  <Download className="w-5 h-5 text-gray-600" />
                  <span className="text-sm font-medium text-gray-900">Export Report</span>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;
</file>

<file path="pages/ObstetricsDashboard.tsx">
import React, { useState, useEffect } from 'react';
import { Plus, Save } from 'lucide-react';
import { usePatients } from '../src/hooks/usePatients';
import toast from 'react-hot-toast';
import { Pregnancy, Patient, PrescriptionItem } from '../types';
import { obstetricsService, calculateEDD, calculateGestationalAge } from '../services/obstetricsService';
import { authService } from '../services/authService';
import { visitsService } from '../services/visitsService';
import PregnancyHeader from './components/obstetrics/PregnancyHeader';
import RiskAssessment from './components/obstetrics/RiskAssessment';
import ANCFlowSheet from './components/obstetrics/ANCFlowSheet';
import FetalGrowthChart from './components/obstetrics/FetalGrowthChart';
import PrescriptionComponent from '../components/PrescriptionComponent';
import PrescriptionPrinter from '../components/PrescriptionPrinter';
import RefreshButton from '../components/RefreshButton';
import HistorySidebar from '../src/components/HistorySidebar';

const ObstetricsDashboard: React.FC = () => {
  const { patients } = usePatients();
  const [selectedPatientId, setSelectedPatientId] = useState<string | null>(null);
  const [pregnancy, setPregnancy] = useState<Pregnancy | null>(null);
  const [isLoadingPregnancy, setIsLoadingPregnancy] = useState(false);
  const [showNewPregnancyForm, setShowNewPregnancyForm] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [doctorId, setDoctorId] = useState<string | null>(null);
  const [prescription, setPrescription] = useState<PrescriptionItem[]>([]);
  const [isPrinterOpen, setIsPrinterOpen] = useState(false);
  const [showHistory, setShowHistory] = useState(false);

  const [formData, setFormData] = useState({
    lmp_date: '',
    edd_by_scan: '',
  });

  useEffect(() => {
    fetchDoctorProfile();
    if (patients.length > 0 && !selectedPatientId) {
      setSelectedPatientId(patients[0].id.toString());
    }
  }, []);

  useEffect(() => {
    if (selectedPatientId) {
      fetchPregnancy(selectedPatientId);
      fetchLastPrescription(selectedPatientId);
    }
  }, [selectedPatientId]);

  const fetchLastPrescription = async (patientId: string) => {
    try {
      // Get the pregnancy first
      const pregnancy = await obstetricsService.getPregnancyByPatient(patientId);
      if (pregnancy && pregnancy.id) {
        // Get the most recent antenatal visit for this pregnancy to load prescription
        const visits = await obstetricsService.getANCVisits(pregnancy.id);
        if (visits.length > 0) {
          const lastVisit = visits[visits.length - 1];
          // Check if prescription exists in the visit data
          if (lastVisit.prescription && Array.isArray(lastVisit.prescription)) {
            setPrescription(lastVisit.prescription);
          }
        }
      }
    } catch (error) {
      console.error('Error fetching last prescription:', error);
    }
  };

  const fetchPregnancy = async (patientId: string) => {
    try {
      setIsLoadingPregnancy(true);
      const data = await obstetricsService.getPregnancyByPatient(patientId);
      setPregnancy(data || null);
    } catch (error) {
      console.error('Error fetching pregnancy:', error);
      setPregnancy(null);
    } finally {
      setIsLoadingPregnancy(false);
    }
  };

  const fetchDoctorProfile = async () => {
    try {
      const user = await authService.getCurrentUser();
      if (user) {
        const doctor = await authService.getDoctorProfile(user.id);
        setDoctorId(doctor.id);
      }
    } catch (error) {
      console.error('Error fetching doctor profile:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø¨ÙŠØ¨');
    }
  };

  const handleCreatePregnancy = async () => {
    try {
      if (!selectedPatientId) {
        toast.error('Ø§Ø®ØªØ± Ù…Ø±ÙŠØ¶Ø© Ø£ÙˆÙ„Ø§Ù‹');
        return;
      }

      if (!doctorId) {
        toast.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø¨ÙŠØ¨');
        return;
      }

      const lmpDate = formData.lmp_date?.trim() || null;
      const eddByScan = formData.edd_by_scan?.trim() || null;

      if (!lmpDate && !eddByScan) {
        toast.error('Ø£Ø¯Ø®Ù„ ØªØ§Ø±ÙŠØ® Ø¢Ø®Ø± Ø¯ÙˆØ±Ø© Ø£Ùˆ ØªØ§Ø±ÙŠØ® Ø§Ù„ÙˆÙ„Ø§Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹');
        return;
      }

      setIsSaving(true);

      let eddDate: string | null = null;

      if (eddByScan) {
        if (isNaN(new Date(eddByScan).getTime())) {
          toast.error('Invalid EDD date provided');
          setIsSaving(false);
          return;
        }
        eddDate = eddByScan;
      } else if (lmpDate) {
        eddDate = calculateEDD(lmpDate);
        if (!eddDate) {
          toast.error('Unable to calculate EDD from LMP date');
          setIsSaving(false);
          return;
        }
      }

      if (!eddDate) {
        toast.error('Invalid date provided. Please check LMP or EDD by scan.');
        setIsSaving(false);
        return;
      }

      const pregnancyData = {
        doctor_id: doctorId,
        patient_id: selectedPatientId,
        lmp_date: lmpDate,
        edd_date: eddDate,
        edd_by_scan: eddByScan,
        risk_level: 'low' as const,
        risk_factors: [] as string[],
        aspirin_prescribed: false,
        thromboprophylaxis_needed: false,
      };

      console.log('Creating pregnancy with data:', pregnancyData);

      const newPregnancy = await obstetricsService.createPregnancy(pregnancyData);

      if (!newPregnancy || !newPregnancy.id) {
        throw new Error('Failed to create pregnancy: Invalid response from server');
      }

      setPregnancy(newPregnancy);
      setShowNewPregnancyForm(false);
      setFormData({ lmp_date: '', edd_by_scan: '' });
      toast.success('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø­Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error: any) {
      console.error('Error creating pregnancy:', error);
      console.error('Error details:', {
        message: error?.message,
        code: error?.code,
        status: error?.status,
        details: error?.details,
        hint: error?.hint,
      });
      toast.error(`ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø­Ù…Ù„: ${error?.message || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}`);
    } finally {
      setIsSaving(false);
    }
  };

  const handleUpdatePregnancy = async (updates: Partial<Pregnancy>) => {
    if (!pregnancy || !pregnancy.id) {
      console.error('Cannot update pregnancy: pregnancy data is invalid');
      toast.error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ù…Ù„Ù Ø§Ù„Ø­Ù…Ù„: Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
      return;
    }

    try {
      if (!updates || Object.keys(updates).length === 0) {
        console.warn('No updates provided');
        return;
      }

      const sanitizedUpdates = {
        ...updates,
        risk_factors: Array.isArray(updates.risk_factors) ? updates.risk_factors : [],
      };

      await obstetricsService.updatePregnancy(pregnancy.id, sanitizedUpdates);
      const updated = await obstetricsService.getPregnancyByPatient(pregnancy.patient_id);

      if (!updated || !updated.id) {
        throw new Error('Failed to fetch updated pregnancy data');
      }

      setPregnancy(updated);
    } catch (error) {
      console.error('Error updating pregnancy:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ù…Ù„Ù Ø§Ù„Ø­Ù…Ù„');
      throw error;
    }
  };

  const handleSaveVisit = async () => {
    if (!selectedPatientId || !pregnancy || !pregnancy.id) {
      toast.error('Please select a patient and ensure pregnancy data is loaded');
      return;
    }

    setIsSaving(true);
    try {
      if (!selectedPatientId || typeof selectedPatientId !== 'string') {
        throw new Error('Invalid patient ID');
      }

      const gestationalAge = calculateGestationalAge(pregnancy.lmp_date);

      if (!gestationalAge || typeof gestationalAge.weeks !== 'number' || typeof gestationalAge.days !== 'number') {
        throw new Error('Invalid gestational age calculation');
      }

      // Save as antenatal visit with prescription data
      const visitData = {
        pregnancy_id: pregnancy.id,
        visit_date: new Date().toISOString().split('T')[0],
        gestational_age_weeks: gestationalAge.weeks,
        gestational_age_days: gestationalAge.days,
        systolic_bp: null, // Will be filled in ANCFlowSheet
        diastolic_bp: null,
        weight_kg: null,
        urine_albuminuria: 'negative',
        urine_glycosuria: 'negative',
        fetal_heart_sound: true,
        fundal_height_cm: null,
        edema: false,
        edema_grade: 'none',
        notes: `Pregnancy monitoring visit - GA: ${gestationalAge.weeks}w+${gestationalAge.days}d, Risk: ${pregnancy.risk_level || 'low'}`,
        next_visit_date: null,
        prescription: Array.isArray(prescription) ? prescription : [], // Include prescription
      };

      await obstetricsService.createANCVisit(visitData);

      toast.success('Obstetrics visit saved successfully');
      setPrescription([]);

    } catch (error: any) {
      console.error('Error saving visit:', error);
      toast.error(`Failed to save visit: ${error?.message || 'Unknown error'}`);
    } finally {
      setIsSaving(false);
    }
  };

  const currentPatient = patients.find(p => p.id.toString() === selectedPatientId);

  return (
    <div className="max-w-7xl mx-auto">
      <div className="mb-8 flex items-start justify-between">
        <div>
          <h1 className="text-4xl font-bold text-gray-900 mb-2 font-[Tajawal]">
            ğŸ¤° ÙˆØ­Ø¯Ø© Ø·Ø¨ Ø§Ù„ØªÙˆÙ„ÙŠØ¯ ÙˆØ§Ù„Ù†Ø³Ø§Ø¦ÙŠØ©
          </h1>
          <p className="text-gray-600 font-[Tajawal]">
            Ù…ØªØ§Ø¨Ø¹Ø© Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø­Ù…Ù„ ÙˆØ§Ù„ÙˆÙ„Ø§Ø¯Ø© Ù…Ø¹ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…Ø®Ø§Ø·Ø± ÙˆØ§Ù„Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠÙˆÙ…ÙŠØªØ±ÙŠ
          </p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={() => setShowHistory(true)}
            className="bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-2"
          >
            ğŸ“œ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ø³Ø§Ø¨Ù‚
          </button>
          <RefreshButton onRefreshComplete={() => {
            if (selectedPatientId) {
              fetchPregnancy(selectedPatientId);
            }
          }} />
        </div>
      </div>

      <div className="grid md:grid-cols-4 gap-4 mb-6">
        <div className="md:col-span-3">
          <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
            Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±ÙŠØ¶Ø©
          </label>
          <select
            value={selectedPatientId || ''}
            onChange={(e) => setSelectedPatientId(e.target.value)}
            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
          >
            <option value="">-- Ø§Ø®ØªØ± Ù…Ø±ÙŠØ¶Ø© --</option>
            {patients.map(patient => (
              <option key={patient.id} value={patient.id.toString()}>
                {patient.name} - {patient.phone}
              </option>
            ))}
          </select>
        </div>

        <div>
          <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
            &nbsp;
          </label>
          <button
            onClick={() => window.location.reload()}
            className="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-[Tajawal] font-semibold transition-colors"
          >
            ğŸ”„ ØªØ­Ø¯ÙŠØ«
          </button>
        </div>
      </div>

      {isLoadingPregnancy ? (
        <div className="flex items-center justify-center h-96">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-teal-600"></div>
        </div>
      ) : pregnancy && pregnancy.id && pregnancy.patient_id ? (
        <>
          <PregnancyHeader pregnancy={pregnancy} />
          <RiskAssessment pregnancy={pregnancy} onUpdate={handleUpdatePregnancy} />
          <ANCFlowSheet pregnancyId={pregnancy.id} lmpDate={pregnancy.lmp_date || undefined} />
          <FetalGrowthChart pregnancyId={pregnancy.id} lmpDate={pregnancy.lmp_date || undefined} />

          {/* Prescription Section */}
          <div className="bg-white rounded-lg shadow-md p-6 mt-6">
            <PrescriptionComponent
              prescriptions={prescription}
              onPrescriptionsChange={setPrescription}
              onPrint={() => setIsPrinterOpen(true)}
              showPrintButton={true}
            />
          </div>

          {/* Save Visit Button */}
          <div className="bg-white rounded-lg shadow-md p-6 mt-6">
            <button
              onClick={handleSaveVisit}
              disabled={isSaving}
              className="w-full bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2"
            >
              <Save className="w-5 h-5" />
              {isSaving ? 'Saving...' : 'Save Obstetrics Visit'}
            </button>
          </div>
        </>
      ) : currentPatient ? (
        <div className="bg-white rounded-lg shadow-md p-12 text-center">
          <div className="inline-flex items-center justify-center w-16 h-16 bg-teal-100 rounded-full mb-4">
            <Plus size={32} className="text-teal-600" />
          </div>
          <h3 className="text-xl font-bold text-gray-900 mb-2 font-[Tajawal]">
            Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù Ø­Ù…Ù„ Ù„Ù€ {currentPatient.name}
          </h3>
          <p className="text-gray-600 mb-6 font-[Tajawal]">
            Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø­Ù…Ù„ Ø¬Ø¯ÙŠØ¯ Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø´Ø§Ù…Ù„Ø©
          </p>

          {!showNewPregnancyForm ? (
            <button
              onClick={() => setShowNewPregnancyForm(true)}
              className="inline-flex items-center gap-2 bg-teal-600 hover:bg-teal-700 text-white px-6 py-3 rounded-lg font-[Tajawal] font-semibold transition-colors"
            >
              <Plus size={20} />
              Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø­Ù…Ù„ Ø¬Ø¯ÙŠØ¯
            </button>
          ) : (
            <div className="bg-gray-50 p-6 rounded-lg border-2 border-teal-200 max-w-md mx-auto">
              <div className="mb-4">
                <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
                  Ø¢Ø®Ø± Ø¯ÙˆØ±Ø© Ø´Ù‡Ø±ÙŠØ© (LMP)
                </label>
                <input
                  type="date"
                  value={formData.lmp_date}
                  onChange={(e) => setFormData(prev => ({ ...prev, lmp_date: e.target.value }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                />
              </div>

              <div className="mb-4">
                <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">
                  Ø£Ùˆ ØªØ§Ø±ÙŠØ® Ø§Ù„ÙˆÙ„Ø§Ø¯Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ Ø¨Ø§Ù„Ù…Ø³Ø­ (EDD by Ultrasound)
                </label>
                <input
                  type="date"
                  value={formData.edd_by_scan}
                  onChange={(e) => setFormData(prev => ({ ...prev, edd_by_scan: e.target.value }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                />
              </div>

              <div className="flex gap-2">
                <button
                  onClick={handleCreatePregnancy}
                  disabled={isSaving}
                  className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white px-6 py-2 rounded-lg font-[Tajawal] font-semibold transition-colors"
                >
                  {isSaving ? 'Ø¬Ø§Ø±ÙŠ...' : 'Ø¥Ù†Ø´Ø§Ø¡'}
                </button>
                <button
                  onClick={() => setShowNewPregnancyForm(false)}
                  className="flex-1 bg-gray-400 hover:bg-gray-500 text-white px-6 py-2 rounded-lg font-[Tajawal] font-semibold transition-colors"
                >
                  Ø¥Ù„ØºØ§Ø¡
                </button>
              </div>
            </div>
          )}
        </div>
      ) : (
        <div className="bg-white rounded-lg shadow-md p-12 text-center">
          <p className="text-gray-600 font-[Tajawal]">Ø§Ø®ØªØ± Ù…Ø±ÙŠØ¶Ø© Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©</p>
        </div>
      )}

      <PrescriptionPrinter
        patient={currentPatient || null}
        prescriptions={Array.isArray(prescription) ? prescription : []}
        diagnosis={pregnancy && pregnancy.id ? `Pregnancy - ${pregnancy.risk_level || 'low'} risk` : ''}
        notes={pregnancy && pregnancy.id && pregnancy.lmp_date ? (() => {
          try {
            const ga = calculateGestationalAge(pregnancy.lmp_date);
            return ga && ga.weeks > 0 ? `Gestational age: ${ga.weeks} weeks ${ga.days} days` : 'Gestational age: Not available';
          } catch (err) {
            console.warn('Error calculating GA for printer:', err);
            return 'Gestational age: Not available';
          }
        })() : ''}
        isOpen={isPrinterOpen}
        onClose={() => setIsPrinterOpen(false)}
      />

      <HistorySidebar
        patientId={selectedPatientId || ''}
        category="OBS"
        isOpen={showHistory}
        onClose={() => setShowHistory(false)}
      />
    </div>
  );
};

export default ObstetricsDashboard;
</file>

<file path="src/powersync/schema.ts">
import { column, Schema, Table } from '@powersync/web';

// Define PowerSync schema matching Supabase tables
const patients = new Table({
    name: column.text,
    age: column.integer,
    phone: column.text,
    husband_name: column.text,
    history: column.text,
    doctor_id: column.text,
    created_at: column.text,
    updated_at: column.text
});

const visits = new Table({
    patient_id: column.text,
    date: column.text,
    department: column.text,
    diagnosis: column.text,
    prescription: column.text,
    notes: column.text,
    clinical_data: column.text,
    created_at: column.text,
    updated_at: column.text
});

const ivf_cycles = new Table({
    patient_id: column.text,
    doctor_id: column.text,
    protocol: column.text,
    status: column.text,
    start_date: column.text,
    assessment_data: column.text,
    lab_data: column.text,
    transfer_data: column.text,
    outcome_data: column.text,
    created_at: column.text,
    updated_at: column.text
});

const stimulation_logs = new Table({
    cycle_id: column.text,
    cycle_day: column.integer,
    date: column.text,
    fsh: column.text,
    hmg: column.text,
    e2: column.text,
    lh: column.text,
    rt_follicles: column.text,
    lt_follicles: column.text,
    created_at: column.text,
    updated_at: column.text
});

const pregnancies = new Table({
    patient_id: column.text,
    doctor_id: column.text,
    lmp_date: column.text,
    edd_date: column.text,
    edd_by_scan: column.text,
    risk_level: column.text,
    risk_factors: column.text,
    aspirin_prescribed: column.integer,
    thromboprophylaxis_needed: column.integer,
    created_at: column.text,
    updated_at: column.text
});

const antenatal_visits = new Table({
    pregnancy_id: column.text,
    visit_date: column.text,
    gestational_age_weeks: column.integer,
    gestational_age_days: column.integer,
    systolic_bp: column.integer,
    diastolic_bp: column.integer,
    weight_kg: column.real,
    urine_albuminuria: column.text,
    urine_glycosuria: column.text,
    fetal_heart_sound: column.text,
    fundal_height_cm: column.real,
    edema: column.integer,
    edema_grade: column.text,
    notes: column.text,
    next_visit_date: column.text,
    created_at: column.text,
    updated_at: column.text
});

const biometry_scans = new Table({
    pregnancy_id: column.text,
    scan_date: column.text,
    gestational_age_weeks: column.integer,
    gestational_age_days: column.integer,
    bpd_mm: column.real,
    hc_mm: column.real,
    ac_mm: column.real,
    fl_mm: column.real,
    efw_grams: column.real,
    percentile: column.real,
    notes: column.text,
    created_at: column.text,
    updated_at: column.text
});

const patient_files = new Table({
    patient_id: column.text,
    file_name: column.text,
    file_type: column.text,
    file_url: column.text,
    file_size: column.integer,
    uploaded_by: column.text,
    created_at: column.text,
    updated_at: column.text
});

const doctors = new Table({
    user_id: column.text,
    email: column.text,
    name: column.text,
    specialization: column.text,
    phone: column.text,
    doctor_image: column.text,
    clinic_name: column.text,
    clinic_address: column.text,
    clinic_phone: column.text,
    created_at: column.text,
    updated_at: column.text
});

const app_settings = new Table({
    clinic_name: column.text,
    logo_url: column.text,
    clinic_address: column.text,
    clinic_phone: column.text,
    primary_color: column.text,
    secondary_color: column.text,
    accent_color: column.text,
    created_at: column.text,
    updated_at: column.text
});

const infertility_workups = new Table({
    patient_id: column.text,
    amh: column.real,
    cycle_regularity: column.text,
    sperm_count: column.integer,
    motility: column.integer,
    morphology: column.integer,
    left_tube: column.text,
    right_tube: column.text,
    cavity_status: column.text,
    diagnosis: column.text,
    plan: column.text,
    created_at: column.text,
    updated_at: column.text
});

export const AppSchema = new Schema({
    patients,
    visits,
    ivf_cycles,
    stimulation_logs,
    pregnancies,
    antenatal_visits,
    biometry_scans,
    patient_files,
    doctors,
    app_settings,
    infertility_workups
});

export type Database = (typeof AppSchema)['types'];
</file>

<file path="pages/IvfJourney.tsx">
import React, { useState, useEffect } from 'react';
import { usePatients } from '../src/hooks/usePatients';
import { calculateTMSC, analyzeSemenAnalysis, classifyOvarianReserve, calculateMaturationRate, calculateFertilizationRate, db } from '../services/ivfService';
import { Patient } from '../types';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { Baby, TestTube, PlusCircle, TrendingUp, PipetteIcon, Heart, Save, AlertCircle, CheckCircle, Pill, Printer, Microscope, Activity, Plus, X } from 'lucide-react';
import toast from 'react-hot-toast';
import PrescriptionPrinter from '../components/PrescriptionPrinter';
import RefreshButton from '../components/RefreshButton';
import HistorySidebar from '../src/components/HistorySidebar';

const PROTOCOL_OPTIONS = ['Long', 'Antagonist', 'Flare-up', 'Mini-IVF'];

const LOCAL_IVF_DRUGS = {
  'Induction (Stimulation)': ['Gonal-F 75 IU', 'Merional 75 IU', 'Menogon 75 IU', 'Clomid 50mg', 'Femara 2.5mg'],
  'Trigger Shots': ['Ovitrelle 250mcg', 'Choriomon 5000 IU', 'Pregnyl 5000 IU', 'Decapeptyl 0.1mg (Trigger)'],
  'Down-Regulation': ['Cetrotide 0.25mg', 'Orgalutran 0.25mg', 'Decapeptyl 0.1mg Daily', 'Zoladex 3.6mg'],
  'Luteal Support': ['Cyclogest 400mg', 'Cyclogest 200mg', 'Prontogest 100mg', 'Duphaston 10mg', 'Utrogestan 200mg', 'Crinone 8% Gel']
};

const PROTOCOL_INFO: any = {
  'Long': {
    name: 'Long Agonist Protocol',
    arabicName: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ù†Ø§Ù‡Ø¶Ø§Øª Ø§Ù„Ø·ÙˆÙŠÙ„Ø©',
    bestFor: ['Normal responders', 'Regular cycles', 'PCO patients'],
    duration: '35-42 days',
    stimDays: '10-12 days',
    stimDrugs: ['Gonal-F 75 IU', 'Merional 75 IU', 'Fostimon 75 IU'],
    trigger: ['Ovitrelle 250mcg', 'Choriomon 5000 IU'],
    luteal: ['Cyclogest 400mg', 'Utrogestan 200mg']
  },
  'Antagonist': {
    name: 'Antagonist Protocol',
    arabicName: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ù…Ø¶Ø§Ø¯Ø§Øª',
    bestFor: ['Poor responders', 'Previous low response'],
    duration: '14-16 days',
    stimDays: '8-10 days',
    stimDrugs: ['Gonal-F 75-150 IU', 'Merional 75 IU', 'Menopur 75 IU'],
    trigger: ['Ovitrelle 250mcg', 'Decapeptyl 0.1mg (Trigger)'],
    luteal: ['Cyclogest 400mg', 'Progynova 2mg']
  },
  'Flare-up': {
    name: 'Flare-up Protocol',
    arabicName: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„ØªÙ†Ø´ÙŠØ· Ø§Ù„Ø­Ø§Ø¯',
    bestFor: ['Poor responders', 'Diminished ovarian reserve'],
    duration: '10-12 days',
    stimDays: '8-9 days',
    stimDrugs: ['Gonal-F 150-300 IU', 'Merional 150 IU'],
    trigger: ['Ovitrelle 250mcg', 'Choriomon 5000 IU'],
    luteal: ['Cyclogest 400mg', 'Duphaston 10mg']
  },
  'Mini-IVF': {
    name: 'Mini-IVF Protocol',
    arabicName: 'Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø­Ù‚Ù† Ø§Ù„Ù…Ø¬Ù‡Ø±ÙŠ Ø§Ù„Ø®ÙÙŠÙ',
    bestFor: ['Poor responders', 'Previous OHSS'],
    duration: '10-14 days',
    stimDays: '7-8 days',
    stimDrugs: ['Clomid 50mg', 'Femara 2.5mg', 'Gonal-F 75 IU'],
    trigger: ['Ovitrelle 250mcg'],
    luteal: ['Cyclogest 200mg', 'Utrogestan 200mg']
  }
};

interface StimulationLog {
  id?: string;
  date: string;
  cycleDay: number;
  fsh: string;
  hmg: string;
  e2: string;
  lh: string;
  rtFollicles: string;
  ltFollicles: string;
  endometriumThickness?: string;
}

interface CycleDataState {
  id: string;
  patientId: string;
  protocol: string;
  status: 'Assessment' | 'Active' | 'PickUp' | 'Transfer' | 'Done';
  startDate: string;

  // Assessment Tab
  coupleAge?: number;
  coupleBMI?: number;
  amh?: number;
  afc?: number;
  pcosHistory?: boolean;
  maleFactorAnalysis?: string;
  maleFactorDiagnosis?: string;
  recommendedProtocol?: string;

  // Stimulation Tab
  stimulationLogs: StimulationLog[];
  triggerDate?: string;

  // Lab Tab
  opuDate?: string;
  totalOocytes?: number;
  mii?: number;
  mi?: number;
  gv?: number;
  atretic?: number;
  maturationRate?: number;
  fertilizedTwoPN?: number;
  fertilizationRate?: number;

  // Transfer Tab
  transferDate?: string;
  numberTransferred?: number;
  embryoQuality?: string;
  betaHcg?: number;
  clinicalPregnancy?: boolean;
  gestationalSac?: boolean;
  fHR?: boolean;
}

const defaultCycleData: CycleDataState = {
  id: '',
  patientId: '',
  protocol: 'Antagonist',
  status: 'Assessment',
  startDate: new Date().toISOString().split('T')[0],
  stimulationLogs: [],
  coupleAge: undefined,
  coupleBMI: undefined,
  amh: undefined,
  afc: undefined,
  pcosHistory: false,
  maleFactorAnalysis: '',
  maleFactorDiagnosis: '',
  recommendedProtocol: 'GnRH Antagonist',
  triggerDate: undefined,
  opuDate: undefined,
  totalOocytes: undefined,
  mii: undefined,
  mi: undefined,
  gv: undefined,
  atretic: undefined,
  maturationRate: undefined,
  fertilizedTwoPN: undefined,
  fertilizationRate: undefined,
  transferDate: undefined,
  numberTransferred: undefined,
  embryoQuality: '',
  betaHcg: undefined,
  clinicalPregnancy: false,
  gestationalSac: false,
  fHR: false
};

const IvfJourney: React.FC = () => {
  const { patients } = usePatients();
  const [selectedPatientId, setSelectedPatientId] = useState('');
  const [cycleData, setCycleData] = useState<CycleDataState>(defaultCycleData);
  const [activeTab, setActiveTab] = useState<'assessment' | 'stimulation' | 'lab' | 'transfer'>('assessment');
  const [isLoading, setIsLoading] = useState(false);
  const [isPrinterOpen, setIsPrinterOpen] = useState(false);
  const [showHistory, setShowHistory] = useState(false);

  const selectedPatient = patients.find(p => String(p.id) === selectedPatientId);

  useEffect(() => {
    if (selectedPatientId) {
      loadExistingCycle(selectedPatientId);
    }
  }, [selectedPatientId]);

  const loadExistingCycle = async (patientId: string) => {
    try {
      const cycles = await db.getCycles();
      const patientCycles = cycles.filter(c => c.patientId === patientId);

      if (patientCycles.length > 0) {
        // Load the most recent cycle
        const activeCycle = patientCycles[0]; // Get the first (most recent) cycle

        // Load stimulation logs for this cycle from the cycle object itself (populated by service)
        const cycleLogs = activeCycle.logs || [];

        // Map status to component status
        let componentStatus: CycleDataState['status'] = 'Assessment';
        if (activeCycle.status === 'Active') componentStatus = 'Active';
        else if (activeCycle.status === 'Completed') componentStatus = 'Done';

        setCycleData({
          id: activeCycle.id,
          patientId: activeCycle.patientId,
          protocol: activeCycle.protocol,
          status: componentStatus,
          startDate: activeCycle.startDate,
          stimulationLogs: cycleLogs.map(log => ({
            id: log.id,
            date: log.date,
            cycleDay: log.cycleDay,
            fsh: log.fsh || '',
            hmg: log.hmg || '',
            e2: log.e2 || '',
            lh: log.lh || '',
            rtFollicles: log.rtFollicles || '',
            ltFollicles: log.ltFollicles || '',
            endometriumThickness: log.endometriumThickness || ''
          })),
          // Load assessment data from cycle data
          coupleAge: activeCycle.assessment?.coupleProfile?.age,
          coupleBMI: activeCycle.assessment?.coupleProfile?.bmi,
          amh: activeCycle.assessment?.femaleFactor?.amh,
          afc: activeCycle.assessment?.femaleFactor?.afcRight,
          pcosHistory: activeCycle.assessment?.coupleProfile?.infertilityType === 'Secondary',
          maleFactorAnalysis: activeCycle.assessment?.maleFactor?.diagnosis,
          recommendedProtocol: activeCycle.protocol,
          // Load lab data
          opuDate: activeCycle.lab?.opuDate,
          totalOocytes: activeCycle.lab?.totalOocytes,
          mii: activeCycle.lab?.mii,
          mi: activeCycle.lab?.mi,
          gv: activeCycle.lab?.gv,
          atretic: activeCycle.lab?.atretic,
          fertilizedTwoPN: activeCycle.lab?.fertilizedTwoPN,
          // Load transfer data
          transferDate: activeCycle.transfer?.transferDate,
          numberTransferred: activeCycle.transfer?.numberTransferred,
          embryoQuality: activeCycle.transfer?.embryoQuality,
          // Load outcome data
          betaHcg: activeCycle.outcome?.betaHcg,
          clinicalPregnancy: activeCycle.outcome?.clinicalPregnancy,
          gestationalSac: activeCycle.outcome?.gestationalSac,
          fHR: activeCycle.outcome?.fHR
        });
      } else {
        // No existing cycle, reset to default
        setCycleData({ ...defaultCycleData, patientId: selectedPatientId });
      }
    } catch (error) {
      console.error('Error loading existing cycle:', error);
      setCycleData({ ...defaultCycleData, patientId: selectedPatientId });
    }
  };

  const handleStartCycle = async () => {
    if (!selectedPatientId) {
      toast.error('Please select a patient');
      return;
    }

    setIsLoading(true);
    try {
      // Create new cycle in database
      const cycleDataToSave = {
        patientId: selectedPatientId,
        protocol: cycleData.protocol as 'Long' | 'Antagonist' | 'Flare-up' | 'Mini-IVF',
        startDate: new Date().toISOString().split('T')[0],
        status: 'Active' as const,
        assessment: {
          coupleProfile: {
            age: cycleData.coupleAge,
            bmi: cycleData.coupleBMI,
            infertilityType: cycleData.pcosHistory ? 'Secondary' as const : 'Primary' as const
          },
          femaleFactor: {
            amh: cycleData.amh,
            afcRight: cycleData.afc
          },
          maleFactor: {
            diagnosis: cycleData.maleFactorAnalysis
          }
        }
      };

      const savedCycle = await db.saveCycle(cycleDataToSave);

      // Update local state with the saved cycle ID
      setCycleData(prev => ({
        ...prev,
        id: savedCycle.id,
        patientId: selectedPatientId,
        status: 'Active',
        startDate: new Date().toISOString().split('T')[0]
      }));

      toast.success('New IVF cycle started and saved');
    } catch (error) {
      console.error('Error starting cycle:', error);
      toast.error('Failed to start cycle');
    } finally {
      setIsLoading(false);
    }
  };

  const handleAddStimulationLog = async () => {
    const newLog: StimulationLog = {
      date: new Date().toISOString().split('T')[0],
      cycleDay: cycleData.stimulationLogs.length + 1,
      fsh: '',
      hmg: '',
      e2: '',
      lh: '',
      rtFollicles: '',
      ltFollicles: '',
      endometriumThickness: ''
    };
    try {
      const savedLog = await db.addLog(cycleData.id, newLog);
      setCycleData(prev => ({
        ...prev,
        stimulationLogs: [...prev.stimulationLogs, { ...newLog, id: savedLog.id }]
      }));
      toast.success('Day added');
    } catch (error) {
      console.error('Error adding log:', error);
      toast.error('Failed to add day');
    }
  };

  const handleUpdateLog = (index: number, field: string, value: any) => {
    setCycleData(prev => {
      const newLogs = [...prev.stimulationLogs];
      newLogs[index] = { ...newLogs[index], [field]: value };
      return { ...prev, stimulationLogs: newLogs };
    });
  };

  const handleRemoveLog = (index: number) => {
    setCycleData(prev => ({
      ...prev,
      stimulationLogs: prev.stimulationLogs.filter((_, i) => i !== index)
    }));
  };

  const calculateMaturation = () => {
    if (!cycleData.totalOocytes || cycleData.totalOocytes === 0) return 0;
    if (!cycleData.mii) return 0;
    return ((cycleData.mii / cycleData.totalOocytes) * 100).toFixed(1);
  };

  const calculateFertilization = () => {
    if (!cycleData.mii || cycleData.mii === 0) return 0;
    if (!cycleData.fertilizedTwoPN) return 0;
    return ((cycleData.fertilizedTwoPN / cycleData.mii) * 100).toFixed(1);
  };

  const handleSaveCycle = async () => {
    if (!cycleData.id) {
      toast.error('No cycle to save');
      return;
    }

    setIsLoading(true);
    try {
      // Update cycle with all current data
      const cycleUpdate = {
        status: cycleData.status === 'Done' ? 'Completed' as const : 'Active' as const,
        assessment_data: {
          coupleProfile: {
            age: cycleData.coupleAge,
            bmi: cycleData.coupleBMI,
            infertilityType: cycleData.pcosHistory ? 'Secondary' as const : 'Primary' as const
          },
          femaleFactor: {
            amh: cycleData.amh,
            afcRight: cycleData.afc
          },
          maleFactor: {
            diagnosis: cycleData.maleFactorAnalysis
          }
        },
        lab_data: {
          opuDate: cycleData.opuDate,
          totalOocytes: cycleData.totalOocytes,
          mii: cycleData.mii,
          mi: cycleData.mi,
          gv: cycleData.gv,
          atretic: cycleData.atretic,
          fertilizedTwoPN: cycleData.fertilizedTwoPN,
          maturationRate: cycleData.totalOocytes && cycleData.mii ? ((cycleData.mii / cycleData.totalOocytes) * 100) : undefined,
          fertilizationRate: cycleData.mii && cycleData.fertilizedTwoPN ? ((cycleData.fertilizedTwoPN / cycleData.mii) * 100) : undefined
        },
        transfer_data: {
          transferDate: cycleData.transferDate,
          numberTransferred: cycleData.numberTransferred,
          embryoQuality: cycleData.embryoQuality
        },
        outcome_data: {
          betaHcg: cycleData.betaHcg,
          clinicalPregnancy: cycleData.clinicalPregnancy,
          gestationalSac: cycleData.gestationalSac,
          fHR: cycleData.fHR
        }
      };

      // Update cycle assessment data
      await db.updateCycleAssessment(cycleData.id, cycleUpdate.assessment_data);

      // Update cycle lab data
      await db.updateCycleLabData(cycleData.id, cycleUpdate.lab_data);

      // Update cycle transfer data
      await db.updateCycleTransfer(cycleData.id, cycleUpdate.transfer_data);

      // Update cycle outcome data
      await db.updateCycleOutcome(cycleData.id, cycleUpdate.outcome_data);

      // Save stimulation logs
      for (const log of cycleData.stimulationLogs) {
        const logData = {
          cycleDay: log.cycleDay,
          date: log.date,
          fsh: log.fsh || '',
          hmg: log.hmg || '',
          e2: log.e2 || '',
          lh: log.lh || '',
          rtFollicles: log.rtFollicles || '',
          ltFollicles: log.ltFollicles || '',
          endometriumThickness: log.endometriumThickness || ''
        };

        if (log.id) {
          // Update existing log
          await db.updateLog(log.id, logData);
        } else {
          // Add new log
          await db.addLog(cycleData.id, logData);
        }
      }

      toast.success('IVF cycle data saved successfully');
    } catch (error) {
      console.error('Error saving cycle:', error);
      toast.error('Failed to save cycle data');
    } finally {
      setIsLoading(false);
    }
  };

  const stimulationChartData = cycleData.stimulationLogs.map(log => ({
    day: `D${log.cycleDay}`,
    e2: parseFloat(log.e2) || 0,
    lh: parseFloat(log.lh) || 0,
    date: log.date
  }));

  return (
    <div className="max-w-7xl mx-auto space-y-6" style={{ fontFamily: 'Tajawal, sans-serif' }} dir="ltr">
      {/* Header */}
      <div className="bg-gradient-to-r from-teal-600 to-indigo-600 text-white p-6 rounded-2xl shadow-lg">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold mb-2">ğŸ”¬ IVF Journey</h1>
            <p className="text-teal-100">Comprehensive IVF Cycle Management & Tracking</p>
          </div>
          <div className="flex items-center gap-4">
            <button
              onClick={() => setShowHistory(true)}
              className="bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-2"
            >
              ğŸ“œ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ø³Ø§Ø¨Ù‚
            </button>
            <RefreshButton variant="secondary" showLabel={false} />
            <TestTube className="w-16 h-16 opacity-20" />
          </div>
        </div>
      </div>

      {/* Patient Selector */}
      <div className="bg-white p-6 rounded-lg shadow-md">
        <label className="block text-sm font-semibold text-gray-700 mb-2">Select Patient</label>
        <select
          value={selectedPatientId}
          onChange={(e) => setSelectedPatientId(e.target.value)}
          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
        >
          <option value="">-- Select Patient --</option>
          {patients.map(patient => (
            <option key={patient.id} value={String(patient.id)}>
              {patient.name} - {patient.phone}
            </option>
          ))}
        </select>
      </div>

      {selectedPatient && cycleData.id && (
        <div className="bg-white rounded-lg shadow-md overflow-hidden">
          {/* Cycle Header */}
          <div className="bg-gradient-to-r from-blue-50 to-blue-100 p-4 border-b border-gray-200">
            <h2 className="text-2xl font-bold text-gray-900">{selectedPatient.name}'s Cycle</h2>
            <p className="text-sm text-gray-600 mt-1">Status: <span className="font-semibold text-teal-600">{cycleData.status}</span></p>
          </div>

          {/* Tabs */}
          <div className="border-b border-gray-200">
            <nav className="flex">
              {['assessment', 'stimulation', 'lab', 'transfer'].map((tab) => (
                <button
                  key={tab}
                  onClick={() => setActiveTab(tab as any)}
                  className={`flex-1 py-4 px-6 text-center font-medium transition-colors ${activeTab === tab
                    ? 'border-b-2 border-teal-500 text-teal-600 bg-teal-50'
                    : 'text-gray-500 hover:text-gray-700'
                    }`}
                >
                  {tab.charAt(0).toUpperCase() + tab.slice(1)}
                </button>
              ))}
            </nav>
          </div>

          {/* Tab Content */}
          <div className="p-6">
            {/* Assessment Tab */}
            {activeTab === 'assessment' && (
              <div className="grid md:grid-cols-2 gap-6">
                {/* Couple Profile */}
                <div className="bg-blue-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                    <Heart className="w-5 h-5 text-blue-600" /> Couple Profile
                  </h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Age (Wife)</label>
                      <input
                        type="number"
                        value={cycleData.coupleAge || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, coupleAge: parseInt(e.target.value) || undefined }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                        placeholder="Years"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">BMI</label>
                      <input
                        type="number"
                        step="0.1"
                        value={cycleData.coupleBMI || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, coupleBMI: parseFloat(e.target.value) || undefined }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                        placeholder="kg/mÂ²"
                      />
                    </div>
                    <div className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        id="pcosCheckbox"
                        checked={cycleData.pcosHistory || false}
                        onChange={(e) => setCycleData(prev => ({ ...prev, pcosHistory: e.target.checked }))}
                        className="w-4 h-4"
                      />
                      <label htmlFor="pcosCheckbox" className="text-sm font-medium text-gray-700">PCOS History</label>
                    </div>
                  </div>
                </div>

                {/* Ovarian Reserve */}
                <div className="bg-green-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                    <Microscope className="w-5 h-5 text-green-600" /> Ovarian Reserve
                  </h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">AMH (ng/mL)</label>
                      <input
                        type="number"
                        step="0.1"
                        value={cycleData.amh || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, amh: parseFloat(e.target.value) || undefined }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500"
                        placeholder="0.0"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">AFC</label>
                      <input
                        type="number"
                        value={cycleData.afc || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, afc: parseInt(e.target.value) || undefined }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500"
                        placeholder="Count"
                      />
                    </div>
                    {cycleData.amh !== undefined && cycleData.afc !== undefined && (
                      <div className="p-3 bg-white rounded border border-green-200 text-sm">
                        <p className="font-medium text-gray-900">
                          Classification: <span className="text-green-600 font-bold">{classifyOvarianReserve(cycleData.amh, cycleData.afc)}</span>
                        </p>
                      </div>
                    )}
                  </div>
                </div>

                {/* Male Factor */}
                <div className="bg-purple-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4">Male Factor Analysis</h3>
                  <textarea
                    value={cycleData.maleFactorAnalysis || ''}
                    onChange={(e) => setCycleData(prev => ({ ...prev, maleFactorAnalysis: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500"
                    placeholder="WHO 2021 parameters, TMSC, Morphology..."
                    rows={3}
                  />
                </div>

                {/* Protocol Selection */}
                <div className="bg-amber-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4">Protocol Selection</h3>
                  <select
                    value={cycleData.protocol}
                    onChange={(e) => setCycleData(prev => ({ ...prev, protocol: e.target.value }))}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 mb-3"
                  >
                    {PROTOCOL_OPTIONS.map(p => (
                      <option key={p} value={p}>{p}</option>
                    ))}
                  </select>
                  {PROTOCOL_INFO[cycleData.protocol] && (
                    <div className="p-3 bg-white rounded border border-amber-200 text-sm">
                      <p className="font-medium text-gray-900">{PROTOCOL_INFO[cycleData.protocol].name}</p>
                      <p className="text-gray-600 mt-1">Duration: {PROTOCOL_INFO[cycleData.protocol].duration}</p>
                      <p className="text-gray-600">Stimulation: {PROTOCOL_INFO[cycleData.protocol].stimDays}</p>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* Stimulation Tab */}
            {activeTab === 'stimulation' && (
              <div className="space-y-6">
                {/* Hormone Trends Chart */}
                {stimulationChartData.length > 0 && (
                  <div className="bg-gray-50 p-4 rounded-lg">
                    <h3 className="text-lg font-semibold text-gray-900 mb-4">Hormone Trends</h3>
                    <ResponsiveContainer width="100%" height={300}>
                      <LineChart data={stimulationChartData}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="day" />
                        <YAxis />
                        <Tooltip />
                        <Legend />
                        <Line type="monotone" dataKey="e2" stroke="#ef4444" name="E2 (pg/mL)" />
                        <Line type="monotone" dataKey="lh" stroke="#3b82f6" name="LH (mIU/mL)" />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                )}

                {/* Daily Stimulation Logs */}
                <div className="bg-gray-50 p-4 rounded-lg">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-lg font-semibold text-gray-900">Daily Stimulation Logs</h3>
                    <button
                      onClick={handleAddStimulationLog}
                      className="flex items-center gap-2 bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-lg transition"
                    >
                      <Plus className="w-4 h-4" /> Add Day
                    </button>
                  </div>

                  <div className="overflow-x-auto">
                    <table className="w-full text-sm">
                      <thead className="bg-white border-b">
                        <tr>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">Date</th>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">Day</th>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">FSH</th>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">HMG</th>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">E2</th>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">LH</th>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">Rt Follicles</th>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">Lt Follicles</th>
                          <th className="px-3 py-2 text-left font-semibold text-gray-700">Action</th>
                        </tr>
                      </thead>
                      <tbody className="divide-y">
                        {cycleData.stimulationLogs.map((log, idx) => (
                          <tr key={idx} className="bg-white hover:bg-gray-50">
                            <td className="px-3 py-2">
                              <input
                                type="date"
                                value={log.date}
                                onChange={(e) => handleUpdateLog(idx, 'date', e.target.value)}
                                className="w-24 px-2 py-1 border border-gray-300 rounded text-sm"
                              />
                            </td>
                            <td className="px-3 py-2 text-gray-600">{log.cycleDay}</td>
                            <td className="px-3 py-2">
                              <input
                                type="number"
                                value={log.fsh}
                                onChange={(e) => handleUpdateLog(idx, 'fsh', e.target.value)}
                                className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                                placeholder="IU"
                              />
                            </td>
                            <td className="px-3 py-2">
                              <input
                                type="number"
                                value={log.hmg}
                                onChange={(e) => handleUpdateLog(idx, 'hmg', e.target.value)}
                                className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                                placeholder="IU"
                              />
                            </td>
                            <td className="px-3 py-2">
                              <input
                                type="number"
                                value={log.e2}
                                onChange={(e) => handleUpdateLog(idx, 'e2', e.target.value)}
                                className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                                placeholder="pg/mL"
                              />
                            </td>
                            <td className="px-3 py-2">
                              <input
                                type="number"
                                value={log.lh}
                                onChange={(e) => handleUpdateLog(idx, 'lh', e.target.value)}
                                className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                                placeholder="mIU/mL"
                              />
                            </td>
                            <td className="px-3 py-2">
                              <input
                                type="text"
                                value={log.rtFollicles}
                                onChange={(e) => handleUpdateLog(idx, 'rtFollicles', e.target.value)}
                                className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                                placeholder="e.g., 12,10,8"
                              />
                            </td>
                            <td className="px-3 py-2">
                              <input
                                type="text"
                                value={log.ltFollicles}
                                onChange={(e) => handleUpdateLog(idx, 'ltFollicles', e.target.value)}
                                className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                                placeholder="e.g., 11,9,7"
                              />
                            </td>
                            <td className="px-3 py-2">
                              <button
                                onClick={() => handleRemoveLog(idx)}
                                className="p-1 hover:bg-red-100 text-red-600 rounded transition"
                              >
                                <X className="w-4 h-4" />
                              </button>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  {cycleData.stimulationLogs.length === 0 && (
                    <p className="text-gray-500 text-center py-6">No stimulation logs yet. Click "Add Day" to start recording.</p>
                  )}
                </div>

                {/* Trigger */}
                <div className="bg-red-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4">Trigger Shot</h3>
                  <input
                    type="date"
                    value={cycleData.triggerDate || ''}
                    onChange={(e) => setCycleData(prev => ({ ...prev, triggerDate: e.target.value }))}
                    className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500"
                  />
                </div>
              </div>
            )}

            {/* Lab Tab */}
            {activeTab === 'lab' && (
              <div className="grid md:grid-cols-2 gap-6">
                {/* OPU Data */}
                <div className="bg-pink-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                    <PipetteIcon className="w-5 h-5 text-pink-600" /> OPU Data
                  </h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">OPU Date</label>
                      <input
                        type="date"
                        value={cycleData.opuDate || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, opuDate: e.target.value }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-pink-500"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Total Oocytes</label>
                      <input
                        type="number"
                        value={cycleData.totalOocytes || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, totalOocytes: parseInt(e.target.value) || undefined }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-pink-500"
                      />
                    </div>
                    <div className="grid grid-cols-2 gap-3">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">MII</label>
                        <input
                          type="number"
                          value={cycleData.mii || ''}
                          onChange={(e) => setCycleData(prev => ({ ...prev, mii: parseInt(e.target.value) || undefined }))}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-pink-500"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">MI</label>
                        <input
                          type="number"
                          value={cycleData.mi || ''}
                          onChange={(e) => setCycleData(prev => ({ ...prev, mi: parseInt(e.target.value) || undefined }))}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-pink-500"
                        />
                      </div>
                    </div>
                    <div className="grid grid-cols-2 gap-3">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">GV</label>
                        <input
                          type="number"
                          value={cycleData.gv || ''}
                          onChange={(e) => setCycleData(prev => ({ ...prev, gv: parseInt(e.target.value) || undefined }))}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-pink-500"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Atretic</label>
                        <input
                          type="number"
                          value={cycleData.atretic || ''}
                          onChange={(e) => setCycleData(prev => ({ ...prev, atretic: parseInt(e.target.value) || undefined }))}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-pink-500"
                        />
                      </div>
                    </div>
                    {cycleData.totalOocytes && cycleData.mii && (
                      <div className="p-3 bg-white rounded border border-pink-200">
                        <p className="text-sm text-gray-700">
                          Maturation Rate: <span className="font-bold text-pink-600">{calculateMaturation()}%</span>
                        </p>
                      </div>
                    )}
                  </div>
                </div>

                {/* Fertilization */}
                <div className="bg-cyan-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                    <Microscope className="w-5 h-5 text-cyan-600" /> Fertilization
                  </h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">2PN Count</label>
                      <input
                        type="number"
                        value={cycleData.fertilizedTwoPN || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, fertilizedTwoPN: parseInt(e.target.value) || undefined }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-500"
                      />
                    </div>
                    {cycleData.mii && cycleData.fertilizedTwoPN && (
                      <div className="p-3 bg-white rounded border border-cyan-200">
                        <p className="text-sm text-gray-700">
                          Fertilization Rate: <span className="font-bold text-cyan-600">{calculateFertilization()}%</span>
                        </p>
                      </div>
                    )}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Embryo Quality</label>
                      <select
                        value={cycleData.embryoQuality || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, embryoQuality: e.target.value }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-cyan-500"
                      >
                        <option value="">Select Quality</option>
                        <option value="A">Excellent (A)</option>
                        <option value="B">Good (B)</option>
                        <option value="C">Fair (C)</option>
                      </select>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Transfer Tab */}
            {activeTab === 'transfer' && (
              <div className="grid md:grid-cols-2 gap-6">
                {/* Transfer Details */}
                <div className="bg-indigo-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                    <Baby className="w-5 h-5 text-indigo-600" /> Transfer Details
                  </h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Transfer Date</label>
                      <input
                        type="date"
                        value={cycleData.transferDate || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, transferDate: e.target.value }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Number Transferred</label>
                      <input
                        type="number"
                        value={cycleData.numberTransferred || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, numberTransferred: parseInt(e.target.value) || undefined }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500"
                      />
                    </div>
                  </div>
                </div>

                {/* Outcome */}
                <div className="bg-emerald-50 p-4 rounded-lg">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                    <Heart className="w-5 h-5 text-emerald-600" /> Outcome
                  </h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Beta-HCG (mIU/mL)</label>
                      <input
                        type="number"
                        value={cycleData.betaHcg || ''}
                        onChange={(e) => setCycleData(prev => ({ ...prev, betaHcg: parseInt(e.target.value) || undefined }))}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500"
                      />
                    </div>
                    <div className="space-y-2">
                      <div className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          id="clinicalPregnancy"
                          checked={cycleData.clinicalPregnancy || false}
                          onChange={(e) => setCycleData(prev => ({ ...prev, clinicalPregnancy: e.target.checked }))}
                          className="w-4 h-4"
                        />
                        <label htmlFor="clinicalPregnancy" className="text-sm font-medium text-gray-700">Clinical Pregnancy</label>
                      </div>
                      <div className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          id="gestationalSac"
                          checked={cycleData.gestationalSac || false}
                          onChange={(e) => setCycleData(prev => ({ ...prev, gestationalSac: e.target.checked }))}
                          className="w-4 h-4"
                        />
                        <label htmlFor="gestationalSac" className="text-sm font-medium text-gray-700">Gestational Sac Seen</label>
                      </div>
                      <div className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          id="fhr"
                          checked={cycleData.fHR || false}
                          onChange={(e) => setCycleData(prev => ({ ...prev, fHR: e.target.checked }))}
                          className="w-4 h-4"
                        />
                        <label htmlFor="fhr" className="text-sm font-medium text-gray-700">Fetal Heart Rate Detected</label>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className="bg-gray-50 p-6 border-t border-gray-200 flex gap-4">
            <button
              onClick={handleSaveCycle}
              disabled={isLoading}
              className="flex-1 flex items-center justify-center gap-2 bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white font-medium py-3 px-4 rounded-lg transition"
            >
              <Save className="w-5 h-5" />
              {isLoading ? 'Saving...' : 'Save Cycle'}
            </button>
            <button
              onClick={() => setIsPrinterOpen(true)}
              className="flex-1 flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-4 rounded-lg transition"
            >
              <Printer className="w-5 h-5" /> Print Report
            </button>
            <button
              onClick={() => {
                setCycleData(defaultCycleData);
                setActiveTab('assessment');
              }}
              className="flex-1 flex items-center justify-center gap-2 bg-gray-400 hover:bg-gray-500 text-white font-medium py-3 px-4 rounded-lg transition"
            >
              <X className="w-5 h-5" /> Reset
            </button>
          </div>
        </div>
      )}

      {!cycleData.id && selectedPatient && (
        <div className="bg-white p-12 rounded-lg shadow-md text-center">
          <TestTube className="w-16 h-16 mx-auto text-gray-300 mb-4" />
          <h2 className="text-2xl font-bold text-gray-900 mb-2">No Active Cycle</h2>
          <p className="text-gray-600 mb-6">Start a new IVF cycle for {selectedPatient.name}</p>
          <button
            onClick={handleStartCycle}
            disabled={isLoading}
            className="bg-teal-600 hover:bg-teal-700 disabled:opacity-50 text-white font-medium py-3 px-8 rounded-lg transition flex items-center justify-center gap-2 mx-auto"
          >
            <PlusCircle className="w-5 h-5" />
            {isLoading ? 'Starting...' : 'Start New Cycle'}
          </button>
        </div>
      )}

      {/* Prescription Printer */}
      <PrescriptionPrinter
        patient={selectedPatient || null}
        prescriptions={[]}
        diagnosis="IVF Cycle"
        notes="Comprehensive IVF Cycle Documentation"
        isOpen={isPrinterOpen}
        onClose={() => setIsPrinterOpen(false)}
      />

      <HistorySidebar
        patientId={selectedPatientId}
        category="IVF"
        isOpen={showHistory}
        onClose={() => setShowHistory(false)}
      />
    </div>
  );
};

export default IvfJourney;
</file>

<file path="pages/Login.tsx">
import React, { useState } from 'react';
import { authService } from '../services/authService';
import toast from 'react-hot-toast';
import { LogIn, AlertCircle, Mail, Lock, User, Phone, Stethoscope, Facebook, MessageCircle } from 'lucide-react';

interface LoginProps {
  onLoginSuccess: () => void;
}

export const Login: React.FC<LoginProps> = ({ onLoginSuccess }) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [showSignup, setShowSignup] = useState(false);
  const [signupData, setSignupData] = useState({
    name: '',
    specialization: '',
    phone: '',
  });

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!email || !password) {
      toast.error('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„');
      return;
    }

    setLoading(true);
    try {
      await authService.login(email, password);
      toast.success('ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­');
      onLoginSuccess();
    } catch (error: any) {
      toast.error(error.message || 'ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„');
    } finally {
      setLoading(false);
    }
  };

  const handleSignup = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!email || !password || !signupData.name) {
      toast.error('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ù„Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©');
      return;
    }

    if (password.length < 6) {
      toast.error('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
      return;
    }

    setLoading(true);
    try {
      await authService.signup(email, password, signupData);
      toast.success('ØªÙ… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­! ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ');
      setShowSignup(false);
      setEmail('');
      setPassword('');
      setSignupData({ name: '', specialization: '', phone: '' });
    } catch (error: any) {
      toast.error(error.message || 'ÙØ´Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„');
    } finally {
      setLoading(false);
    }
  };

  // Fallback branding for login page
  const branding = {
    clinic_name: 'Nile IVF Center',
    logo_url: null
  };

  return (
    <div className="min-h-screen flex font-[Tajawal]" dir="rtl">
      {/* Left Side - Login Form */}
      <div className="flex-1 flex items-center justify-center p-8 bg-white md:w-1/2">
        <div className="w-full max-w-md space-y-8">
          {/* Logo and Branding */}
          <div className="text-center">
            <div className="flex justify-center mb-6">
              {branding?.logo_url ? (
                <img
                  src={branding.logo_url}
                  alt="Nile IVF Center Logo"
                  className="w-20 h-20 rounded-full object-cover border-4 border-teal-100"
                />
              ) : (
                <div className="w-20 h-20 bg-gradient-to-br from-teal-500 to-cyan-600 rounded-full flex items-center justify-center">
                  <Stethoscope className="text-white" size={32} />
                </div>
              )}
            </div>
            <h1 className="text-3xl font-bold text-gray-900 mb-2">
              Ù…Ø±ÙƒØ² Ø¯ ØµÙ„Ø§Ø­ Ù„Ù„Ø®ØµÙˆØ¨Ø©
            </h1>
            <p className="text-gray-600 text-lg mb-2">
              Ù…Ø¹Ø§ÙƒÙ… Ø®Ø·ÙˆØ© Ø¨Ø®Ø·ÙˆØ©
            </p>
            <p className="text-gray-500 text-base">
              {showSignup ? 'Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯' : 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„'}
            </p>
          </div>

          {/* Login Form */}
          {!showSignup ? (
            <form onSubmit={handleLogin} className="space-y-6">
              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-3">
                  Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
                </label>
                <div className="relative">
                  <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
                  <input
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="w-full pr-12 pl-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all duration-200"
                    placeholder="doctor@example.com"
                    disabled={loading}
                  />
                </div>
              </div>

              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-3">
                  ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
                </label>
                <div className="relative">
                  <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
                  <input
                    type="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="w-full pr-12 pl-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all duration-200"
                    placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
                    disabled={loading}
                  />
                </div>
              </div>

              <button
                type="submit"
                disabled={loading}
                className="w-full bg-gradient-to-r from-teal-600 to-cyan-600 hover:from-teal-700 hover:to-cyan-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-bold py-4 rounded-xl transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5"
              >
                {loading ? (
                  <div className="flex items-center justify-center gap-2">
                    <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                    Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...
                  </div>
                ) : (
                  'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„'
                )}
              </button>
            </form>
          ) : (
            /* Signup Form */
            <form onSubmit={handleSignup} className="space-y-6">
              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-3">
                  Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„ *
                </label>
                <div className="relative">
                  <User className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
                  <input
                    type="text"
                    value={signupData.name}
                    onChange={(e) => setSignupData({ ...signupData, name: e.target.value })}
                    className="w-full pr-12 pl-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all duration-200"
                    placeholder="Ø¯. Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯"
                    disabled={loading}
                  />
                </div>
              </div>

              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-3">
                  Ø§Ù„ØªØ®ØµØµ
                </label>
                <div className="relative">
                  <Stethoscope className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
                  <input
                    type="text"
                    value={signupData.specialization}
                    onChange={(e) => setSignupData({ ...signupData, specialization: e.target.value })}
                    className="w-full pr-12 pl-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all duration-200"
                    placeholder="Ø£Ù…Ø±Ø§Ø¶ Ø§Ù„Ù†Ø³Ø§Ø¡ ÙˆØ§Ù„ØªÙˆÙ„ÙŠØ¯"
                    disabled={loading}
                  />
                </div>
              </div>

              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-3">
                  Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ
                </label>
                <div className="relative">
                  <Phone className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
                  <input
                    type="tel"
                    value={signupData.phone}
                    onChange={(e) => setSignupData({ ...signupData, phone: e.target.value })}
                    className="w-full pr-12 pl-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all duration-200"
                    placeholder="+966501234567"
                    disabled={loading}
                  />
                </div>
              </div>

              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-3">
                  Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ *
                </label>
                <div className="relative">
                  <Mail className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
                  <input
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="w-full pr-12 pl-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all duration-200"
                    placeholder="doctor@example.com"
                    disabled={loading}
                  />
                </div>
              </div>

              <div>
                <label className="block text-sm font-semibold text-gray-700 mb-3">
                  ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± *
                </label>
                <div className="relative">
                  <Lock className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
                  <input
                    type="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="w-full pr-12 pl-4 py-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all duration-200"
                    placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
                    disabled={loading}
                  />
                </div>
              </div>

              <div className="bg-rose-50 border border-rose-200 rounded-xl p-4 flex gap-3 items-start">
                <AlertCircle size={20} className="text-rose-600 flex-shrink-0 mt-0.5" />
                <p className="text-sm text-rose-800">
                  ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù‚ÙˆÙŠØ© ÙˆØ³Ù‡Ù„Ø© Ø§Ù„Ø­ÙØ¸
                </p>
              </div>

              <button
                type="submit"
                disabled={loading}
                className="w-full bg-gradient-to-r from-teal-600 to-cyan-600 hover:from-teal-700 hover:to-cyan-700 disabled:from-gray-400 disabled:to-gray-500 text-white font-bold py-4 rounded-xl transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5"
              >
                {loading ? (
                  <div className="flex items-center justify-center gap-2">
                    <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                    Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...
                  </div>
                ) : (
                  'Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨'
                )}
              </button>
            </form>
          )}

          {/* Toggle between Login/Signup */}
          <div className="text-center">
            <button
              onClick={() => {
                setShowSignup(!showSignup);
                setEmail('');
                setPassword('');
                setSignupData({ name: '', specialization: '', phone: '' });
              }}
              className="text-teal-600 hover:text-teal-700 font-semibold transition-colors duration-200"
              disabled={loading}
            >
              {showSignup ? 'Ù‡Ù„ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ØŸ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„' : 'Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ØŸ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨'}
            </button>
          </div>

          {/* Footer with Copyright and Developer Credits */}
          <div className="pt-8 border-t border-gray-200 text-center text-gray-500 text-sm">
            <p>Copyright Â© 2025 Ù…Ø±ÙƒØ² Ø¯ ØµÙ„Ø§Ø­ Ù„Ù„Ø®ØµÙˆØ¨Ø©. All Rights Reserved.</p>
            <p className="mt-1">ØªÙ… Ø§Ù„ØªØ·ÙˆÙŠØ± Ø¨ÙˆØ§Ø³Ø·Ø© Ø¯. Ù…Ø­Ù…Ø¯ ØµÙ„Ø§Ø­ Ø¬Ø¨Ø±</p>
            
            <div className="mt-4 flex items-center justify-center gap-4">
              <a
                href="https://www.facebook.com/profile.php?id=100000785193419"
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex items-center gap-1 text-blue-600 hover:text-blue-700 transition-colors font-medium"
              >
                <Facebook size={16} />
                <span>ØªØ§Ø¨Ø¹Ù†Ø§ Ø¹Ù„Ù‰ ÙÙŠØ³Ø¨ÙˆÙƒ</span>
              </a>
              <span className="text-gray-300">|</span>
              <a
                href="https://wa.me/201003418068"
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex items-center gap-1 text-green-600 hover:text-green-700 transition-colors font-medium"
              >
                <MessageCircle size={16} />
                <span>Ø±Ø§Ø³Ù„Ù†Ø§ Ø¹Ù„Ù‰ ÙˆØ§ØªØ³Ø§Ø¨</span>
              </a>
            </div>
          </div>
        </div>
      </div>

      {/* Right Side - Decorative Banner */}
      <div className="hidden md:flex md:w-1/2 bg-gradient-to-br from-teal-600 to-cyan-700 relative overflow-hidden">
        {/* Background Image */}
        <div
          className="absolute inset-0 bg-cover bg-center opacity-20"
          style={{
            backgroundImage: `url('https://images.unsplash.com/photo-1576091160550-2173dba999ef?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D')`
          }}
        />

        {/* Gradient Overlay */}
        <div className="absolute inset-0 bg-gradient-to-br from-teal-600/80 to-cyan-700/80" />

        {/* Content */}
        <div className="relative z-10 flex flex-col justify-center items-center text-white p-12 text-center">
          <div className="max-w-md">
            <h2 className="text-4xl font-bold mb-6 leading-tight">
              Ù†Ø±Ø§ÙÙ‚ÙƒÙ… ÙÙŠ Ø±Ø­Ù„Ø© Ø§Ù„Ø£Ù…Ù„
            </h2>
            <p className="text-xl mb-8 opacity-90 leading-relaxed">
              Ù†Ø­Ù† Ù‡Ù†Ø§ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒÙ… ÙÙŠ ØªØ­Ù‚ÙŠÙ‚ Ø£Ø­Ù„Ø§Ù…ÙƒÙ… ÙÙŠ Ø¨Ù†Ø§Ø¡ Ø£Ø³Ø±Ø© Ø³Ø¹ÙŠØ¯Ø©
            </p>
            <div className="flex items-center justify-center gap-2 text-lg">
              <div className="w-2 h-2 bg-white rounded-full animate-pulse"></div>
              <span>Ù…Ø±ÙƒØ² Ø¯ ØµÙ„Ø§Ø­ Ù„Ù„Ø®ØµÙˆØ¨Ø©</span>
              <div className="w-2 h-2 bg-white rounded-full animate-pulse"></div>
            </div>
          </div>
        </div>

        {/* Decorative Elements */}
        <div className="absolute top-10 right-10 w-20 h-20 border-2 border-white/20 rounded-full"></div>
        <div className="absolute bottom-10 left-10 w-16 h-16 bg-white/10 rounded-full"></div>
        <div className="absolute top-1/2 left-10 w-12 h-12 border border-white/30 rounded-full"></div>
      </div>
    </div>
  );
};
</file>

<file path="pages/Reception.tsx">
import React, { useState } from 'react';
import { UserPlus, Search, Phone, User, History } from 'lucide-react';
import { usePatients } from '../src/hooks/usePatients';
import { authService } from '../services/authService';
import toast from 'react-hot-toast';
import RefreshButton from '../components/RefreshButton';

const Reception: React.FC = () => {
  const [activeTab, setActiveTab] = useState<'register' | 'directory'>('register');
  const [formData, setFormData] = useState({
    name: '',
    age: '',
    phone: '',
    husbandName: '',
    history: ''
  });
  const [searchTerm, setSearchTerm] = useState('');

  // PowerSync hook
  const { patients, addPatient } = usePatients();



  console.log('ğŸ¥ Reception: patients array from hook:', patients);

  const handleRegister = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!formData.name || !formData.phone) {
      toast.error("Please fill required fields");
      return;
    }

    const toastId = toast.loading("Registering patient...");

    try {
      // Get current user and ensure doctor record exists
      const user = await authService.getCurrentUser();
      if (!user) throw new Error("Not authenticated");

      const doctor = await authService.ensureDoctorRecord(user.id, user.email || '');
      if (!doctor) throw new Error("Doctor profile missing. Please log out and sign in again.");

      await addPatient({
        name: formData.name,
        age: parseInt(formData.age) || 0,
        phone: formData.phone,
        husband_name: formData.husbandName,
        history: formData.history,
        doctor_id: doctor.id
      });

      toast.success("Patient registered successfully!", { id: toastId });
      setFormData({ name: '', age: '', phone: '', husbandName: '', history: '' });
    } catch (error) {
      // Provide more detailed error feedback for debugging
      const msg = (error && (error as any).message) ? (error as any).message : JSON.stringify(error);
      toast.error(`Failed to register patient: ${msg}`, { id: toastId });
      console.error('Register patient error:', error);
    }
  };

  const filteredPatients = patients.filter(p =>
    p.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    p.phone.includes(searchTerm)
  );

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-4xl font-bold text-gray-900">Reception & Patient Directory</h1>
        <RefreshButton />
      </div>

      <div className="bg-white rounded-2xl shadow-sm border border-gray-100 overflow-hidden min-h-[600px]">
        <div className="flex border-b border-gray-100">
          <button
            onClick={() => setActiveTab('register')}
            className={`flex-1 py-4 text-center font-medium transition-colors ${activeTab === 'register' ? 'text-teal-700 border-b-2 border-teal-700 bg-teal-50' : 'text-gray-500 hover:text-gray-700'}`}
          >
            New Registration
          </button>
          <button
            onClick={() => setActiveTab('directory')}
            className={`flex-1 py-4 text-center font-medium transition-colors ${activeTab === 'directory' ? 'text-teal-700 border-b-2 border-teal-700 bg-teal-50' : 'text-gray-500 hover:text-gray-700'}`}
          >
            Patient Directory
          </button>
        </div>

        <div className="p-4 md:p-8">
          {activeTab === 'register' ? (
            <form onSubmit={handleRegister} className="max-w-2xl mx-auto space-y-6">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Patient Name (Wife)</label>
                  <div className="relative">
                    <User className="absolute right-3 top-3 w-5 h-5 text-gray-400" />
                    <input
                      type="text"
                      required
                      className="w-full pl-4 pr-10 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent outline-none"
                      placeholder="Full Name"
                      value={formData.name}
                      onChange={e => setFormData({ ...formData, name: e.target.value })}
                    />
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Age</label>
                  <input
                    type="number"
                    className="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-teal-500 outline-none"
                    placeholder="Years"
                    value={formData.age}
                    onChange={e => setFormData({ ...formData, age: e.target.value })}
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Phone Number</label>
                  <div className="relative">
                    <Phone className="absolute right-3 top-3 w-5 h-5 text-gray-400" />
                    <input
                      type="tel"
                      required
                      className="w-full pl-4 pr-10 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-teal-500 outline-none"
                      placeholder="01xxxxxxxxx"
                      value={formData.phone}
                      onChange={e => setFormData({ ...formData, phone: e.target.value })}
                    />
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Husband Name</label>
                  <input
                    type="text"
                    className="w-full px-4 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-teal-500 outline-none"
                    placeholder="Husband Name"
                    value={formData.husbandName}
                    onChange={e => setFormData({ ...formData, husbandName: e.target.value })}
                  />
                </div>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">Medical History (Brief)</label>
                <div className="relative">
                  <History className="absolute right-3 top-3 w-5 h-5 text-gray-400" />
                  <textarea
                    className="w-full pl-4 pr-10 py-2 border border-gray-200 rounded-lg focus:ring-2 focus:ring-teal-500 outline-none h-32"
                    placeholder="G P A, Previous Operations, Allergies..."
                    value={formData.history}
                    onChange={e => setFormData({ ...formData, history: e.target.value })}
                  />
                </div>
              </div>

              <button
                type="submit"
                className="w-full bg-teal-700 text-white py-3 rounded-xl font-bold hover:bg-teal-800 transition-colors flex items-center justify-center gap-2 shadow-lg shadow-teal-700/20"
              >
                <UserPlus className="w-5 h-5" />
                Register Patient
              </button>
            </form>
          ) : (
            <div className="space-y-6">
              <div className="relative">
                <Search className="absolute right-3 top-3 w-5 h-5 text-gray-400" />
                <input
                  type="text"
                  className="w-full pl-4 pr-12 py-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-teal-500 outline-none shadow-sm"
                  placeholder="Search by name or phone..."
                  value={searchTerm}
                  onChange={e => setSearchTerm(e.target.value)}
                />
              </div>

              {/* Mobile: render cards */}
              <div className="block md:hidden space-y-3">
                {filteredPatients.length > 0 ? filteredPatients.map(patient => (
                  <div key={patient.id} className="bg-white border border-gray-100 rounded-xl p-4 shadow-sm">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-sm font-bold text-gray-900">{patient.name}</div>
                        <div className="text-xs text-gray-500 mt-1">{patient.phone} â€¢ Age {patient.age}</div>
                      </div>
                      <div className="text-right text-xs text-gray-400 font-mono">
                        {patient.remoteId ? patient.remoteId.slice(0, 6) : `#${patient.id}`}
                      </div>
                    </div>
                    <div className="mt-3 text-xs text-gray-600 truncate">{patient.history}</div>
                  </div>
                )) : (
                  <div className="text-center text-gray-400 py-8">No patients found matching your search.</div>
                )}
              </div>

              {/* Desktop: table */}
              <div className="hidden md:block overflow-x-auto rounded-xl border border-gray-200">
                <table className="w-full text-right">
                  <thead className="bg-gray-50 text-gray-600 font-medium text-sm">
                    <tr>
                      <th className="px-6 py-4">ID</th>
                      <th className="px-6 py-4">Patient Name</th>
                      <th className="px-6 py-4">Age</th>
                      <th className="px-6 py-4">Phone</th>
                      <th className="px-6 py-4">Husband</th>
                      <th className="px-6 py-4">History</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-100">
                    {filteredPatients.length > 0 ? (
                      filteredPatients.map((patient) => (
                        <tr key={patient.id} className="hover:bg-teal-50/30 transition-colors text-sm text-gray-700">
                          <td className="px-6 py-4 font-mono text-xs text-gray-400">
                            {patient.remoteId ? patient.remoteId.slice(0, 6) : `#${patient.id}`}
                          </td>
                          <td className="px-6 py-4 font-bold text-gray-900">{patient.name}</td>
                          <td className="px-6 py-4">{patient.age}</td>
                          <td className="px-6 py-4">{patient.phone}</td>
                          <td className="px-6 py-4">{patient.husband_name}</td>
                          <td className="px-6 py-4 truncate max-w-xs">{patient.history}</td>
                        </tr>
                      ))
                    ) : (
                      <tr>
                        <td colSpan={6} className="px-6 py-12 text-center text-gray-400">
                          No patients found matching your search.
                        </td>
                      </tr>
                    )}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default Reception;
</file>

<file path="services/visitsService.ts">
import { powerSyncDb } from '../src/powersync/client';
import { Visit } from '../types';

// Helper to map DB format to App format
const mapToAppFormat = (v: any): Visit => {
  let clinicalData = {};
  try {
    clinicalData = v.clinical_data ? JSON.parse(v.clinical_data) : {};
  } catch (e) {
    console.error('Error parsing clinical_data:', e);
  }

  let prescription = [];
  try {
    prescription = v.prescription ? JSON.parse(v.prescription) : [];
  } catch (e) {
    console.error('Error parsing prescription:', e);
  }

  return {
    id: v.id,
    patientId: v.patient_id,
    date: v.date || v.visit_date || new Date().toISOString(),
    department: v.department || 'General',
    diagnosis: v.diagnosis || '',
    prescription: prescription,
    notes: v.notes || '',
    clinical_data: clinicalData,
    vitals: (clinicalData as any)?.vitals
  };
};

export const visitsService = {
  // 1. Get all visits for a patient from PowerSync
  getVisitsByPatient: async (patientId: string) => {
    try {
      console.log(`ğŸ” Fetching history for Patient ID: ${patientId}`);

      // Parallel queries for all data sources
      const [generalVisits, pregnancies, ivfCycles] = await Promise.all([
        // 1. General/Gynecology Visits
        powerSyncDb.getAll('SELECT * FROM visits WHERE patient_id = ?', [patientId]) as Promise<any[]>,

        // 2. Pregnancies (for ANC visits)
        powerSyncDb.getAll('SELECT * FROM pregnancies WHERE patient_id = ?', [patientId]) as Promise<any[]>,

        // 3. IVF Cycles
        powerSyncDb.getAll('SELECT * FROM ivf_cycles WHERE patient_id = ?', [patientId]) as Promise<any[]>
      ]);

      console.log(`ğŸ“Š Found: ${generalVisits.length} general visits, ${pregnancies.length} pregnancies, ${ivfCycles.length} IVF cycles`);

      // Process ANC visits from pregnancies
      const ancVisitsPromises = pregnancies.map(async (pregnancy) => {
        const ancVisits = await powerSyncDb.getAll(
          'SELECT * FROM antenatal_visits WHERE pregnancy_id = ?',
          [pregnancy.id]
        ) as any[];

        return ancVisits.map((visit: any) => ({
          id: visit.id,
          patientId: patientId,
          date: visit.visit_date,
          department: 'OBS',
          diagnosis: `ANC Visit - GA ${visit.gestational_age_weeks}w+${visit.gestational_age_days}d`,
          prescription: visit.prescription ? JSON.parse(visit.prescription) : [],
          notes: visit.notes || '',
          clinical_data: {
            systolic_bp: visit.systolic_bp,
            diastolic_bp: visit.diastolic_bp,
            weight_kg: visit.weight_kg,
            urine_albuminuria: visit.urine_albuminuria,
            urine_glycosuria: visit.urine_glycosuria,
            fetal_heart_sound: visit.fetal_heart_sound,
            fundal_height_cm: visit.fundal_height_cm,
            edema: visit.edema,
            edema_grade: visit.edema_grade,
            next_visit_date: visit.next_visit_date
          }
        }));
      });

      const ancVisitsArrays = await Promise.all(ancVisitsPromises);
      const allAncVisits = ancVisitsArrays.flat();

      // Create pregnancy start visits
      const pregnancyStartVisits = pregnancies.map((pregnancy) => ({
        id: `pregnancy_${pregnancy.id}`,
        patientId: patientId,
        date: pregnancy.lmp_date || pregnancy.created_at,
        department: 'OBS',
        diagnosis: 'Pregnancy Started',
        prescription: [],
        notes: `EDD: ${pregnancy.edd_date || 'Unknown'}`,
        clinical_data: {
          risk_level: pregnancy.risk_level,
          risk_factors: pregnancy.risk_factors ? JSON.parse(pregnancy.risk_factors) : []
        }
      }));

      // Map IVF cycles to visits
      const ivfVisits = ivfCycles.map((cycle) => {
        let cycleData = {};
        try {
          cycleData = cycle.assessment_data ? JSON.parse(cycle.assessment_data) : {};
        } catch (e) { }

        return {
          id: cycle.id,
          patientId: patientId,
          date: cycle.start_date,
          department: 'IVF_STIM',
          diagnosis: `IVF Cycle - Protocol: ${cycle.protocol}`,
          prescription: [],
          notes: `Status: ${cycle.status}`,
          clinical_data: cycleData
        };
      });

      // Combine all visits
      const allVisits = [
        ...generalVisits.map(mapToAppFormat),
        ...allAncVisits,
        ...pregnancyStartVisits,
        ...ivfVisits
      ];

      console.log(`âœ… Total combined history: ${allVisits.length} items`);

      // Sort by date descending (newest first)
      return allVisits.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

    } catch (error) {
      console.error('Error fetching patient history:', error);
      return [];
    }
  },

  // 2. Save Visit
  saveVisit: async (params: {
    patientId: string;
    department: string;
    clinicalData: any;
    diagnosis?: string;
    prescription?: any[];
    notes?: string;
  }) => {
    console.log('ğŸ’¾ Saving Visit...', params);

    const id = crypto.randomUUID();
    const now = new Date().toISOString();
    const visitDate = now.split('T')[0];

    await powerSyncDb.execute(
      `INSERT INTO visits (id, patient_id, date, department, diagnosis, prescription, notes, clinical_data, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        params.patientId,
        visitDate,
        params.department,
        params.diagnosis || '',
        JSON.stringify(params.prescription || []),
        params.notes || '',
        JSON.stringify(params.clinicalData || {}),
        now,
        now
      ]
    );

    return id;
  },

  getAllVisits: async () => {
    const visits = await powerSyncDb.getAll('SELECT * FROM visits');
    return visits.map(mapToAppFormat);
  },

  deleteVisit: async (id: string) => {
    await powerSyncDb.execute('DELETE FROM visits WHERE id = ?', [id]);
  }
};
</file>

<file path="pages/Gynecology.tsx">
import React, { useState, useEffect } from 'react';
import { Save, Stethoscope, ClipboardList, Pill } from 'lucide-react';
import { usePatients } from '../src/hooks/usePatients';
import toast from 'react-hot-toast';
import { Patient, PrescriptionItem } from '../types';

import { visitsService } from '../services/visitsService';
import { authService } from '../services/authService';
import PrescriptionComponent from '../components/PrescriptionComponent';
import PrescriptionPrinter from '../components/PrescriptionPrinter';
import SearchableSelect from '../components/ui/SearchableSelect';
import RefreshButton from '../components/RefreshButton';
import HistorySidebar from '../src/components/HistorySidebar';
import { COMMON_COMPLAINTS, ICD10_DIAGNOSES, PROCEDURE_ORDERS } from '../data/medical_terms';

interface GynecologyData {
  // Vitals
  vitals: {
    weight?: number;
    height?: number;
    bmi?: number;
    bpSystolic?: number;
    bpDiastolic?: number;
    temperature?: number;
  };

  // Assessment Tab
  complaints: string[];
  pvExamination: {
    vulva: string;
    vagina: string;
    cervix: string;
    adnexa: string;
  };
  ultrasound: {
    uterus: {
      dimensions: string;
      position: string;
      myometrium: string;
      cavity: string;
    };
    endometrium: {
      thickness: string;
      pattern: string;
    };
    adnexa: {
      rightOvary: string;
      leftOvary: string;
      pod: string;
    };
  };

  // Diagnosis & Plan Tab
  diagnosis: string[];
  procedureOrder: string[];
  clinicalNotes: string;

  // Rx Tab
  prescription: PrescriptionItem[];
}

const Gynecology: React.FC = () => {
  const [selectedPatientId, setSelectedPatientId] = useState<string>('');
  const [doctorId, setDoctorId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [activeTab, setActiveTab] = useState<'assessment' | 'diagnosis' | 'rx'>('assessment');
  const [isPrinterOpen, setIsPrinterOpen] = useState(false);
  const [showHistory, setShowHistory] = useState(false);

  const { patients } = usePatients();

  const [gynecologyData, setGynecologyData] = useState<GynecologyData>({
    vitals: {
      weight: undefined,
      height: undefined,
      bmi: undefined,
      bpSystolic: undefined,
      bpDiastolic: undefined,
      temperature: undefined,
    },
    complaints: [],
    pvExamination: {
      vulva: '',
      vagina: '',
      cervix: '',
      adnexa: '',
    },
    ultrasound: {
      uterus: {
        dimensions: '',
        position: 'AVF',
        myometrium: 'Homogeneous',
        cavity: 'Empty',
      },
      endometrium: {
        thickness: '',
        pattern: 'Triple Line',
      },
      adnexa: {
        rightOvary: '',
        leftOvary: '',
        pod: 'Clear',
      },
    },
    diagnosis: [],
    procedureOrder: [],
    clinicalNotes: '',
    prescription: [],
  });

  useEffect(() => {
    fetchDoctorProfile();
  }, []);

  const fetchDoctorProfile = async () => {
    try {
      const user = await authService.getCurrentUser();
      if (user) {
        const doctor = await authService.getDoctorProfile(user.id);
        setDoctorId(doctor.id);
      }
    } catch (error) {
      console.error('Error fetching doctor profile:', error);
      toast.error('Failed to load doctor profile');
    }
  };

  const selectedPatient = patients.find(p => p.id.toString() === selectedPatientId);

  const handleSaveVisit = async () => {
    if (!selectedPatientId || !doctorId) {
      toast.error('Please select a patient');
      return;
    }

    setIsLoading(true);
    try {
      const clinicalData = {
        vitals: gynecologyData.vitals,
        assessment: {
          complaints: gynecologyData.complaints,
          pvExamination: gynecologyData.pvExamination,
          ultrasound: gynecologyData.ultrasound,
        },
        diagnosis: gynecologyData.diagnosis.join('; '),
        procedureOrder: gynecologyData.procedureOrder.join('; '),
        clinicalNotes: gynecologyData.clinicalNotes,
      };

      await visitsService.saveVisit({
        patientId: selectedPatientId,
        department: 'GYNA',
        clinicalData: clinicalData,
        diagnosis: gynecologyData.diagnosis.join('; '),
        prescription: gynecologyData.prescription,
        notes: gynecologyData.clinicalNotes,
      });

      toast.success('Gynecology visit saved successfully');

      // Reset form
      setGynecologyData({
        vitals: {
          weight: undefined,
          height: undefined,
          bmi: undefined,
          bpSystolic: undefined,
          bpDiastolic: undefined,
          temperature: undefined,
        },
        complaints: [],
        pvExamination: {
          vulva: '',
          vagina: '',
          cervix: '',
          adnexa: '',
        },
        ultrasound: {
          uterus: {
            dimensions: '',
            position: 'AVF',
            myometrium: 'Homogeneous',
            cavity: 'Empty',
          },
          endometrium: {
            thickness: '',
            pattern: 'Triple Line',
          },
          adnexa: {
            rightOvary: '',
            leftOvary: '',
            pod: 'Clear',
          },
        },
        diagnosis: [],
        procedureOrder: [],
        clinicalNotes: '',
        prescription: [],
      });

    } catch (error: any) {
      console.error('Error saving visit:', error);
      toast.error(`Failed to save visit: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const toggleComplaint = (complaint: string) => {
    setGynecologyData(prev => ({
      ...prev,
      complaints: prev.complaints.includes(complaint)
        ? prev.complaints.filter(c => c !== complaint)
        : [...prev.complaints, complaint]
    }));
  };

  const toggleDiagnosis = (diagnosis: string) => {
    setGynecologyData(prev => ({
      ...prev,
      diagnosis: prev.diagnosis.includes(diagnosis)
        ? prev.diagnosis.filter(d => d !== diagnosis)
        : [...prev.diagnosis, diagnosis]
    }));
  };

  const toggleProcedure = (procedure: string) => {
    setGynecologyData(prev => ({
      ...prev,
      procedureOrder: prev.procedureOrder.includes(procedure)
        ? prev.procedureOrder.filter(p => p !== procedure)
        : [...prev.procedureOrder, procedure]
    }));
  };

  const handleVitalsChange = (field: keyof GynecologyData['vitals'], value: string) => {
    const numValue = value ? parseFloat(value) : undefined;

    setGynecologyData(prev => {
      const newVitals = { ...prev.vitals, [field]: numValue };

      if (field === 'weight' || field === 'height') {
        if (newVitals.weight && newVitals.height && newVitals.height > 0) {
          const heightInMeters = newVitals.height / 100;
          newVitals.bmi = parseFloat((newVitals.weight / (heightInMeters * heightInMeters)).toFixed(1));
        }
      }

      return {
        ...prev,
        vitals: newVitals,
      };
    });
  };

  return (
    <div className="max-w-7xl mx-auto">
      <div className="mb-8 flex items-start justify-between">
        <div>
          <h1 className="text-4xl font-bold text-gray-900 mb-2 font-[Tajawal]">
            Ø¹ÙŠØ§Ø¯Ø© Ø§Ù„Ù†Ø³Ø§Ø¡
          </h1>
          <p className="text-gray-600 font-[Tajawal]">
            Gynecology Station - Diagnosis & Medical Management of Benign Conditions
          </p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={() => setShowHistory(true)}
            className="bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-2"
          >
            ğŸ“œ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„Ø³Ø§Ø¨Ù‚
          </button>
          <RefreshButton />
        </div>
      </div>

      {/* Patient Selector */}
      <div className="bg-white p-6 rounded-lg shadow-md mb-6">
        <label className="block text-sm font-semibold text-gray-700 mb-2">
          Select Patient
        </label>
        <select
          value={selectedPatientId}
          onChange={(e) => setSelectedPatientId(e.target.value)}
          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent"
        >
          <option value="">-- Select Patient --</option>
          {patients.map(patient => (
            <option key={patient.id} value={patient.id}>
              {patient.name} - {patient.phone}
            </option>
          ))}
        </select>
      </div>

      {selectedPatient && (
        <div className="bg-white rounded-lg shadow-md">
          {/* Tab Navigation */}
          <div className="border-b border-gray-200">
            <nav className="flex">
              <button
                onClick={() => setActiveTab('assessment')}
                className={`flex-1 py-4 px-6 text-center font-medium transition-colors ${activeTab === 'assessment'
                  ? 'border-b-2 border-teal-500 text-teal-600 bg-teal-50'
                  : 'text-gray-500 hover:text-gray-700'
                  }`}
              >
                <Stethoscope className="w-5 h-5 inline mr-2" />
                Clinical Assessment
              </button>
              <button
                onClick={() => setActiveTab('diagnosis')}
                className={`flex-1 py-4 px-6 text-center font-medium transition-colors ${activeTab === 'diagnosis'
                  ? 'border-b-2 border-amber-500 text-amber-600 bg-amber-50'
                  : 'text-gray-500 hover:text-gray-700'
                  }`}
              >
                <ClipboardList className="w-5 h-5 inline mr-2" />
                Diagnosis & Plan
              </button>
              <button
                onClick={() => setActiveTab('rx')}
                className={`flex-1 py-4 px-6 text-center font-medium transition-colors ${activeTab === 'rx'
                  ? 'border-b-2 border-blue-500 text-blue-600 bg-blue-50'
                  : 'text-gray-500 hover:text-gray-700'
                  }`}
              >
                <Pill className="w-5 h-5 inline mr-2" />
                Prescription
              </button>
            </nav>
          </div>

          {/* Tab Content */}
          <div className="p-6">
            {/* Assessment Tab */}
            {activeTab === 'assessment' && (
              <div className="grid md:grid-cols-2 gap-6" dir="ltr">
                {/* LEFT COLUMN: Vitals & Complaints */}
                <div className="space-y-6">
                  {/* Vitals Section */}
                  <div className="bg-blue-50 p-4 rounded-lg">
                    <h3 className="text-lg font-semibold text-gray-900 mb-4">Vital Signs</h3>
                    <div className="grid grid-cols-2 gap-3 text-left">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Weight (kg)</label>
                        <input
                          type="number"
                          value={gynecologyData.vitals.weight || ''}
                          onChange={(e) => handleVitalsChange('weight', e.target.value)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 65"
                          step="0.1"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Height (cm)</label>
                        <input
                          type="number"
                          value={gynecologyData.vitals.height || ''}
                          onChange={(e) => handleVitalsChange('height', e.target.value)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 165"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">BMI</label>
                        <div className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white text-gray-700 font-medium">
                          {gynecologyData.vitals.bmi ? gynecologyData.vitals.bmi.toFixed(1) : '--'}
                        </div>
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Temp (Â°C)</label>
                        <input
                          type="number"
                          value={gynecologyData.vitals.temperature || ''}
                          onChange={(e) => handleVitalsChange('temperature', e.target.value)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 37"
                          step="0.1"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">BP Systolic</label>
                        <input
                          type="number"
                          value={gynecologyData.vitals.bpSystolic || ''}
                          onChange={(e) => handleVitalsChange('bpSystolic', e.target.value)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="mmHg"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">BP Diastolic</label>
                        <input
                          type="number"
                          value={gynecologyData.vitals.bpDiastolic || ''}
                          onChange={(e) => handleVitalsChange('bpDiastolic', e.target.value)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="mmHg"
                        />
                      </div>
                    </div>
                  </div>

                  {/* Complaints */}
                  <div className="text-left">
                    <SearchableSelect
                      label="Chief Complaints"
                      options={COMMON_COMPLAINTS}
                      value={gynecologyData.complaints}
                      onChange={(value) => setGynecologyData(prev => ({
                        ...prev,
                        complaints: Array.isArray(value) ? value : [value]
                      }))}
                      placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø´ÙƒÙˆÙ‰ Ø£Ùˆ Ø£Ø¶Ù Ø´ÙƒÙˆÙ‰ Ø¬Ø¯ÙŠØ¯Ø©"
                      multi={true}
                      allowCustom={true}
                    />
                  </div>
                </div>

                {/* RIGHT COLUMN: Investigations & Scans */}
                <div className="space-y-6">
                  {/* PV Examination */}
                  <div className="bg-green-50 p-4 rounded-lg" dir="ltr">
                    <h3 className="text-lg font-semibold text-gray-900 mb-4">Vaginal Examination (PV)</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-left">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Vulva</label>
                        <input
                          type="text"
                          value={gynecologyData.pvExamination.vulva}
                          onChange={(e) => setGynecologyData(prev => ({
                            ...prev,
                            pvExamination: { ...prev.pvExamination, vulva: e.target.value }
                          }))}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="Normal / Lesions / etc."
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Vagina</label>
                        <input
                          type="text"
                          value={gynecologyData.pvExamination.vagina}
                          onChange={(e) => setGynecologyData(prev => ({
                            ...prev,
                            pvExamination: { ...prev.pvExamination, vagina: e.target.value }
                          }))}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="Normal / Discharge / etc."
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Cervix</label>
                        <input
                          type="text"
                          value={gynecologyData.pvExamination.cervix}
                          onChange={(e) => setGynecologyData(prev => ({
                            ...prev,
                            pvExamination: { ...prev.pvExamination, cervix: e.target.value }
                          }))}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="Normal / Erosion / Motion tenderness"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Adnexa</label>
                        <input
                          type="text"
                          value={gynecologyData.pvExamination.adnexa}
                          onChange={(e) => setGynecologyData(prev => ({
                            ...prev,
                            pvExamination: { ...prev.pvExamination, adnexa: e.target.value }
                          }))}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                          placeholder="Normal / Mass / Tenderness"
                        />
                      </div>
                    </div>
                  </div>

                  {/* Office Ultrasound */}
                  <div dir="ltr">
                    <h3 className="text-lg font-semibold text-gray-900 mb-4">Transvaginal Ultrasound (TVS)</h3>

                    {/* Uterus */}
                    <div className="mb-6">
                      <h4 className="text-md font-medium text-gray-800 mb-3">Uterus</h4>
                      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 text-left">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Dimensions (LxWxAP)</label>
                          <input type="text" value={gynecologyData.ultrasound.uterus.dimensions} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, uterus: { ...prev.ultrasound.uterus, dimensions: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" placeholder="e.g., 7x5x4 cm" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Position</label>
                          <select value={gynecologyData.ultrasound.uterus.position} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, uterus: { ...prev.ultrasound.uterus, position: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                            <option value="AVF">Anteverted Flexed (AVF)</option>
                            <option value="RVF">Retroverted Flexed (RVF)</option>
                            <option value="Axial">Axial</option>
                          </select>
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Myometrium</label>
                          <select value={gynecologyData.ultrasound.uterus.myometrium} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, uterus: { ...prev.ultrasound.uterus, myometrium: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                            <option value="Homogeneous">Homogeneous</option>
                            <option value="Heterogeneous">Heterogeneous</option>
                            <option value="Fibroid">Fibroid</option>
                            <option value="Adenomyosis">Adenomyosis</option>
                          </select>
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Cavity</label>
                          <select value={gynecologyData.ultrasound.uterus.cavity} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, uterus: { ...prev.ultrasound.uterus, cavity: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                            <option value="Empty">Empty</option>
                            <option value="Polyp">Polyp</option>
                            <option value="Fibroid">Fibroid</option>
                          </select>
                        </div>
                      </div>
                    </div>

                    {/* Endometrium */}
                    <div className="mb-6">
                      <h4 className="text-md font-medium text-gray-800 mb-3">Endometrium</h4>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-left">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Thickness (mm)</label>
                          <input type="text" value={gynecologyData.ultrasound.endometrium.thickness} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, endometrium: { ...prev.ultrasound.endometrium, thickness: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" placeholder="e.g., 8-10 mm" />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Pattern</label>
                          <select value={gynecologyData.ultrasound.endometrium.pattern} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, endometrium: { ...prev.ultrasound.endometrium, pattern: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                            <option value="Triple Line">Triple Line</option>
                            <option value="Hyperechoic">Hyperechoic</option>
                          </select>
                        </div>
                      </div>
                    </div>

                    {/* Adnexa */}
                    <div>
                      <h4 className="text-md font-medium text-gray-800 mb-3">Adnexa</h4>
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-left">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Right Ovary</label>
                          <select value={gynecologyData.ultrasound.adnexa.rightOvary} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, adnexa: { ...prev.ultrasound.adnexa, rightOvary: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                            <option value="">Select</option>
                            <option value="Normal">Normal</option>
                            <option value="PCO">Polycystic (PCO)</option>
                            <option value="Cyst">Cyst</option>
                          </select>
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">Left Ovary</label>
                          <select value={gynecologyData.ultrasound.adnexa.leftOvary} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, adnexa: { ...prev.ultrasound.adnexa, leftOvary: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                            <option value="">Select</option>
                            <option value="Normal">Normal</option>
                            <option value="PCO">Polycystic (PCO)</option>
                            <option value="Cyst">Cyst</option>
                          </select>
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">POD (Pouch of Douglas)</label>
                          <select value={gynecologyData.ultrasound.adnexa.pod} onChange={(e) => setGynecologyData(prev => ({ ...prev, ultrasound: { ...prev.ultrasound, adnexa: { ...prev.ultrasound.adnexa, pod: e.target.value } } }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                            <option value="Clear">Clear</option>
                            <option value="Free Fluid">Free Fluid</option>
                          </select>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Diagnosis & Plan Tab */}
            {activeTab === 'diagnosis' && (
              <div className="space-y-6" dir="ltr">
                {/* Diagnosis */}
                <div className="text-left">
                  <SearchableSelect
                    label="ICD-10 Ø§Ù„ØªØ´Ø®ÙŠØµ (Ø§Ø®ØªØ± Ù…ØªØ¹Ø¯Ø¯)"
                    options={ICD10_DIAGNOSES}
                    value={gynecologyData.diagnosis}
                    onChange={(value) => setGynecologyData(prev => ({
                      ...prev,
                      diagnosis: Array.isArray(value) ? value : [value]
                    }))}
                    placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªØ´Ø®ÙŠØµ Ø£Ùˆ Ø£Ø¶Ù ØªØ´Ø®ÙŠØµ Ø¬Ø¯ÙŠØ¯"
                    multi={true}
                    allowCustom={true}
                  />
                  {gynecologyData.diagnosis.length > 0 && (
                    <div className="mt-3 p-3 bg-amber-50 border border-amber-200 rounded-lg">
                      <p className="text-sm text-amber-800 font-medium font-[Tajawal]">Ø§Ù„ØªØ´Ø®ÙŠØµØ§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©:</p>
                      <p className="text-sm text-amber-700 mt-1 font-[Tajawal]">{gynecologyData.diagnosis.join('; ')}</p>
                    </div>
                  )}
                </div>

                {/* Procedure Order */}
                <div className="text-left">
                  <SearchableSelect
                    label="Ø®Ø·Ø© Ø§Ù„Ø¹Ù„Ø§Ø¬ / Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª (Ø§Ø®ØªØ± Ù…ØªØ¹Ø¯Ø¯)"
                    options={PROCEDURE_ORDERS}
                    value={gynecologyData.procedureOrder}
                    onChange={(value) => setGynecologyData(prev => ({
                      ...prev,
                      procedureOrder: Array.isArray(value) ? value : [value]
                    }))}
                    placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø¥Ø¬Ø±Ø§Ø¡ Ø£Ùˆ Ø£Ø¶Ù Ø¥Ø¬Ø±Ø§Ø¡ Ø¬Ø¯ÙŠØ¯"
                    multi={true}
                    allowCustom={true}
                  />
                  {gynecologyData.procedureOrder.length > 0 && (
                    <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                      <p className="text-sm text-blue-800 font-medium font-[Tajawal]">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©:</p>
                      <p className="text-sm text-blue-700 mt-1 font-[Tajawal]">{gynecologyData.procedureOrder.join('; ')}</p>
                    </div>
                  )}
                </div>

                {/* Clinical Notes */}
                <div className="text-left">
                  <h3 className="text-lg font-semibold text-gray-900 mb-4">Clinical Notes & Plan</h3>
                  <textarea
                    value={gynecologyData.clinicalNotes}
                    onChange={(e) => setGynecologyData(prev => ({ ...prev, clinicalNotes: e.target.value }))}
                    rows={4}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500"
                    placeholder="Enter clinical observations, management plan, and follow-up..."
                  />
                </div>
              </div>
            )}

            {/* Rx Tab */}
            {activeTab === 'rx' && (
              <PrescriptionComponent
                prescriptions={gynecologyData.prescription}
                onPrescriptionsChange={(prescriptions) =>
                  setGynecologyData(prev => ({ ...prev, prescription: prescriptions }))
                }
                onPrint={() => setIsPrinterOpen(true)}
                showPrintButton={true}
              />
            )}
          </div>

          {/* Save Button */}
          <div className="bg-gray-50 px-6 py-4 border-t border-gray-200">
            <button
              onClick={handleSaveVisit}
              disabled={isLoading}
              className="w-full bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors flex items-center justify-center gap-2"
            >
              <Save className="w-5 h-5" />
              {isLoading ? 'Saving...' : 'Save Gynecology Visit'}
            </button>
          </div>
        </div>
      )}

      <PrescriptionPrinter
        patient={selectedPatient || null}
        prescriptions={gynecologyData.prescription}
        diagnosis={gynecologyData.diagnosis.join('; ')}
        notes={gynecologyData.clinicalNotes}
        isOpen={isPrinterOpen}
        onClose={() => setIsPrinterOpen(false)}
      />

      <HistorySidebar
        patientId={selectedPatientId}
        category="GYNA"
        isOpen={showHistory}
        onClose={() => setShowHistory(false)}
      />
    </div>
  );
};

export default Gynecology;
</file>

<file path="src/powersync/client.ts">
import { WASQLitePowerSyncDatabaseOpenFactory } from '@powersync/web';
import { AppSchema } from './schema';
import { SupabaseConnector } from './SupabaseConnector';

// Create PowerSync database instance
export const powerSyncDb = new WASQLitePowerSyncDatabaseOpenFactory({
    schema: AppSchema,
    dbFilename: 'powersync.db',
    // Use the worker script from the public directory
    // @ts-ignore
    workerScriptURL: '/powersync.worker.js'
}).getInstance();

// Create connector instance
export const connector = new SupabaseConnector();

// Track connection state to prevent multiple simultaneous connection attempts
let isConnecting = false;
let lastConnectionAttempt = 0;
const CONNECTION_COOLDOWN = 5000; // 5 seconds cooldown between connection attempts

// Initialize and connect PowerSync with retry logic
export async function initPowerSync(retries = 3, delay = 2000, force = false): Promise<void> {
  // Prevent multiple simultaneous connection attempts (unless forced)
  const now = Date.now();
  if (!force && isConnecting) {
    console.log('â¸ï¸ PowerSync connection already in progress, skipping...');
    return;
  }
  
  if (!force && now - lastConnectionAttempt < CONNECTION_COOLDOWN) {
    console.log('â¸ï¸ PowerSync connection cooldown active, skipping...');
    return;
  }

  isConnecting = true;
  lastConnectionAttempt = now;

  try {
    console.log('ğŸ”Œ Initializing PowerSync...');

    // Check if offline before attempting connection
    if (!navigator.onLine) {
      console.warn('âš ï¸ Browser is offline - PowerSync will work in offline mode');
      console.warn('âš ï¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ù…Ù† Supabase Ù…Ø¨Ø§Ø´Ø±Ø©');
      return;
    }

    // Check environment variables
    const endpoint = import.meta.env.VITE_POWERSYNC_URL;
    const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
    
    if (!endpoint || !supabaseUrl) {
      console.error('âŒ PowerSync: Missing required environment variables');
      console.error('   VITE_POWERSYNC_URL:', endpoint ? 'âœ“' : 'âœ—');
      console.error('   VITE_SUPABASE_URL:', supabaseUrl ? 'âœ“' : 'âœ—');
      console.error('âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Ù…Ù„Ù .env');
      console.error('âŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ… Ù…Ù†:');
      console.error('   - Supabase Dashboard > Settings > API');
      console.error('   - PowerSync Dashboard > Settings > Instance URL');
      console.warn('âš ï¸ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø³ÙŠØ¹Ù…Ù„ ÙÙŠ ÙˆØ¶Ø¹ Ø£ÙˆÙÙ„Ø§ÙŠÙ† - Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ù…Ù† Supabase Ù…Ø¨Ø§Ø´Ø±Ø©');
      return;
    }

    // First, verify credentials before attempting connection
    console.log('ğŸ” Verifying credentials before connection...');
    const credentials = await connector.fetchCredentials();
    if (!credentials) {
      console.error('âŒ Failed to fetch credentials - cannot connect to PowerSync');
      console.error('âŒ Please check:');
      console.error('   1. You are logged in');
      console.error('   2. VITE_POWERSYNC_URL is correct');
      console.error('   3. Supabase session is valid');
      return;
    }
    console.log('âœ… Credentials verified:', {
      endpoint: credentials.endpoint,
      hasToken: !!credentials.token
    });

    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        console.log(`ğŸ”Œ Attempting to connect PowerSync (attempt ${attempt}/${retries})...`);
        console.log(`ğŸ”— Endpoint: ${credentials.endpoint}`);
        
        // Disconnect first if already connected (for reconnection)
        try {
          await powerSyncDb.disconnectAndClear();
        } catch (disconnectError) {
          // Ignore disconnect errors
        }
        
        await powerSyncDb.connect(connector);
        console.log('âœ… PowerSync connected successfully');
        return;
      } catch (error: any) {
        const isLastAttempt = attempt === retries;
        console.warn(`âš ï¸ PowerSync connection attempt ${attempt} failed:`, error?.message);
        console.warn(`âš ï¸ Error type:`, error?.constructor?.name);
        console.warn(`âš ï¸ Error stack:`, error?.stack);
        
        if (isLastAttempt) {
          console.error('âŒ PowerSync connection failed after all retries');
          console.error('âŒ Error details:', error);
          console.warn('âš ï¸ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø³ÙŠØ¹Ù…Ù„ ÙÙŠ ÙˆØ¶Ø¹ Ø£ÙˆÙÙ„Ø§ÙŠÙ†');
          console.warn('âš ï¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…ØªØ§Ø­Ø© Ù…Ù† Supabase Ù…Ø¨Ø§Ø´Ø±Ø©');
          
          // Provide specific error messages
          if (navigator.onLine) {
            console.error('âŒ Network available but PowerSync connection failed');
            console.error('âŒ Possible causes:');
            console.error('   1. VITE_POWERSYNC_URL is incorrect');
            console.error('   2. PowerSync server is down');
            console.error('   3. Authentication token expired');
            console.error('   4. Network firewall blocking connection');
            console.error('   5. PowerSync sync rules not configured');
            console.error('   6. CORS issues');
            
            // Check specific error types
            if (error?.message?.includes('fetch')) {
              console.error('âŒ Network error detected - check internet connection');
            }
            if (error?.message?.includes('401') || error?.message?.includes('Unauthorized')) {
              console.error('âŒ Authentication error - token may be expired');
            }
            if (error?.message?.includes('CORS')) {
              console.error('âŒ CORS error - check PowerSync server configuration');
            }
          }
          throw error; // Throw to allow caller to handle
        }
        
        // Wait before retrying
        console.log(`â³ Waiting ${delay}ms before retry...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  } finally {
    isConnecting = false;
  }
}
</file>

<file path="pages/PatientMasterRecord.tsx">
import React, { useState, useEffect } from 'react';
import {
  Calendar, FileText, User, Heart, Baby, TestTube, Download, ChevronDown, ChevronUp,
  X, Image as ImageIcon, Printer
} from 'lucide-react';
import { usePatients } from '../src/hooks/usePatients';
import { Patient, Visit } from '../types';
import { supabase } from '../services/supabaseClient';
import { powerSyncDb } from '../src/powersync/client';
import { visitsService } from '../services/visitsService';
import toast from 'react-hot-toast';
import PrescriptionPrinter from '../components/PrescriptionPrinter';
import RefreshButton from '../components/RefreshButton';

const PatientMasterRecord: React.FC = () => {
  const [selectedPatientId, setSelectedPatientId] = useState<string>('');
  const [visits, setVisits] = useState<Visit[]>([]);
  const [patientFiles, setPatientFiles] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isPrinterOpen, setIsPrinterOpen] = useState(false);
  const [selectedVisit, setSelectedVisit] = useState<Visit | null>(null);
  const [activeTab, setActiveTab] = useState<'timeline' | 'gallery'>('timeline');
  const [selectedFilter, setSelectedFilter] = useState<'All' | 'GYNA' | 'OBS' | 'IVF'>('All');
  const [expandedVisitId, setExpandedVisitId] = useState<string | null>(null);
  const [selectedImage, setSelectedImage] = useState<any | null>(null);

  const { patients: powerSyncPatients, isLoading: isLoadingPatients } = usePatients();

  const patients: Patient[] = powerSyncPatients.map((p: any) => ({
    id: p.id,
    name: p.name,
    age: p.age,
    phone: p.phone,
    husbandName: p.husband_name, // Map snake_case to camelCase
    history: p.history,
    createdAt: p.created_at
  }));

  useEffect(() => {
    if (selectedPatientId) {
      fetchPatientVisits(selectedPatientId);
      fetchPatientFiles(selectedPatientId);
    } else {
      setVisits([]);
      setPatientFiles([]);
    }
  }, [selectedPatientId]);

  const fetchPatientVisits = async (pId: string) => {
    setIsLoading(true);
    try {
      console.log('Fetching visits for patient:', pId);
      // Use the service which now handles ID resolution (Local vs Remote)
      const data = await visitsService.getVisitsByPatient(pId);
      setVisits(data);
    } catch (error) {
      console.error('Error fetching visits:', error);
      toast.error('Failed to load patient visits');
    } finally {
      setIsLoading(false);
    }
  };

  const fetchPatientFiles = async (patientId: string) => {
    try {
      let targetUuid = patientId;

      // Check if it's a legacy numeric ID (though PowerSync uses UUIDs)
      if (!isNaN(Number(patientId))) {
        const patient = patients.find(p => p.id == patientId);
        if (patient && (patient as any).remoteId) {
          targetUuid = (patient as any).remoteId;
        }
      }

      // Use PowerSync for offline access to file metadata
      const data = await powerSyncDb.getAll(
        'SELECT * FROM patient_files WHERE patient_id = ? ORDER BY created_at DESC',
        [targetUuid]
      );

      setPatientFiles(data || []);
    } catch (error) {
      console.error('Error fetching patient files:', error);
      setPatientFiles([]);
    }
  };

  const selectedPatient = patients.find(p => String(p.id) === selectedPatientId);

  const getDepartmentIcon = (department?: string) => {
    switch (department) {
      case 'GYNA': return <Heart className="w-6 h-6 text-pink-600" />;
      case 'OBS': return <Baby className="w-6 h-6 text-blue-600" />;
      case 'IVF_STIM': return <TestTube className="w-6 h-6 text-purple-600" />;
      case 'IVF_LAB': return <TestTube className="w-6 h-6 text-purple-600" />;
      default: return <FileText className="w-6 h-6 text-gray-600" />;
    }
  };

  const getDepartmentName = (department?: string) => {
    switch (department) {
      case 'GYNA': return 'Gynecology';
      case 'OBS': return 'Obstetrics';
      case 'IVF_STIM': return 'IVF Stimulation';
      case 'IVF_LAB': return 'IVF Lab';
      default: return 'General Visit';
    }
  };

  const getDepartmentColor = (department?: string) => {
    switch (department) {
      case 'GYNA': return { bg: 'bg-pink-100', border: 'border-pink-300', dot: 'bg-pink-600' };
      case 'OBS': return { bg: 'bg-blue-100', border: 'border-blue-300', dot: 'bg-blue-600' };
      case 'IVF_STIM': return { bg: 'bg-purple-100', border: 'border-purple-300', dot: 'bg-purple-600' };
      case 'IVF_LAB': return { bg: 'bg-purple-100', border: 'border-purple-300', dot: 'bg-purple-600' };
      default: return { bg: 'bg-gray-100', border: 'border-gray-300', dot: 'bg-gray-600' };
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  };

  const renderClinicalData = (data: any, department?: string) => {
    if (!data) return null;
    switch (department) {
      case 'GYNA': return renderGynecologyData(data);
      case 'OBS': return renderObstetricsData(data);
      case 'IVF_STIM': return renderIVFData(data);
      default: return <div className="text-sm text-gray-600"><pre className="whitespace-pre-wrap">{JSON.stringify(data, null, 2)}</pre></div>;
    }
  };

  const renderGynecologyData = (data: any) => {
    const { assessment, diagnosis, procedureOrder, clinicalNotes } = data;
    return (
      <div className="space-y-3">
        {assessment?.complaints && assessment.complaints.length > 0 && (
          <div>
            <span className="font-medium text-gray-700">Complaints:</span>
            <div className="flex flex-wrap gap-1 mt-1">
              {assessment.complaints.map((complaint: string, idx: number) => (
                <span key={idx} className="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs">{complaint}</span>
              ))}
            </div>
          </div>
        )}
        {diagnosis && <div><span className="font-medium text-green-700">Diagnosis:</span> {diagnosis}</div>}
        {procedureOrder && <div><span className="font-medium text-purple-700">Procedure:</span> {procedureOrder}</div>}
        {clinicalNotes && <div><span className="font-medium text-gray-700">Notes:</span> {clinicalNotes}</div>}
      </div>
    );
  };

  const renderObstetricsData = (data: any) => {
    const { gestationalAge, riskAssessment, currentStatus } = data;
    return (
      <div className="space-y-2">
        {gestationalAge && <div><span className="font-medium">GA:</span> {gestationalAge.weeks}w {gestationalAge.days}d</div>}
        {riskAssessment && <div><span className="font-medium">Risk:</span> {riskAssessment.level}</div>}
        {currentStatus && <div><span className="font-medium">Status:</span> {currentStatus}</div>}
      </div>
    );
  };

  const renderIVFData = (data: any) => {
    const { protocol, startDate, stimulationDays, latestHormones } = data;
    return (
      <div className="space-y-2">
        {protocol && <div><span className="font-medium">Protocol:</span> {protocol}</div>}
        {startDate && <div><span className="font-medium">Started:</span> {formatDate(startDate)}</div>}
        {stimulationDays && <div><span className="font-medium">Days:</span> {stimulationDays}</div>}
        {latestHormones?.e2 && <div><span className="font-medium">E2:</span> {latestHormones.e2} pg/mL</div>}
      </div>
    );
  };

  const getFilteredVisits = () => {
    if (selectedFilter === 'All') return visits;
    if (selectedFilter === 'IVF') return visits.filter(v => v.department?.startsWith('IVF'));
    return visits.filter(v => v.department === selectedFilter);
  };

  const groupFilesByDate = (files: any[]) => {
    const grouped: { [key: string]: any[] } = {};
    files.forEach(file => {
      const date = new Date(file.created_at).toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
      if (!grouped[date]) grouped[date] = [];
      grouped[date].push(file);
    });
    return grouped;
  };

  const generateMedicalReport = () => {
    const filteredVisits = getFilteredVisits();
    const html = `
      <html>
        <head><title>Medical Report - ${selectedPatient?.name}</title></head>
        <body style="font-family: Arial; margin: 20px;">
          <h1>Medical Report</h1>
          <p><strong>Patient:</strong> ${selectedPatient?.name}</p>
          <p><strong>Age:</strong> ${selectedPatient?.age}</p>
          <table border="1" style="width: 100%; border-collapse: collapse;">
            <tr style="background: #f0f0f0;">
              <th style="padding: 8px;">Date</th>
              <th>Department</th>
              <th>Diagnosis</th>
            </tr>
            ${filteredVisits.map(v => `<tr><td style="padding: 8px;">${formatDate(v.date)}</td><td>${getDepartmentName(v.department)}</td><td>${v.diagnosis || 'N/A'}</td></tr>`).join('')}
          </table>
        </body>
      </html>
    `;
    const win = window.open('', '_blank');
    if (win) {
      win.document.write(html);
      win.document.close();
      setTimeout(() => win.print(), 250);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto p-6">
        <div className="mb-8 flex items-start justify-between">
          <div>
            <h1 className="text-4xl font-bold text-gray-900 mb-2">Patient Master Record</h1>
            <p className="text-gray-600">Comprehensive Medical Timeline & Archive</p>
          </div>
          <RefreshButton onRefreshComplete={() => {
            if (selectedPatientId) {
              fetchPatientVisits(selectedPatientId);
              fetchPatientFiles(selectedPatientId);
            }
          }} />
        </div>

        <div className="bg-white p-6 rounded-lg shadow-md mb-6">
          <label className="block text-sm font-semibold text-gray-700 mb-2">Select Patient</label>
          <select
            value={selectedPatientId}
            onChange={(e) => setSelectedPatientId(e.target.value)}
            className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500"
          >
            <option value="">-- Select Patient --</option>
            {patients.map(p => (<option key={p.id} value={p.id}>{p.name} - {p.phone}</option>))}
          </select>
        </div>

        {selectedPatient && (
          <div className="bg-white rounded-lg shadow-md overflow-hidden">
            <div className="bg-gradient-to-r from-teal-600 to-teal-700 text-white p-6 flex items-center justify-between sticky top-0 z-10">
              <div className="flex items-center gap-4">
                <div className="w-14 h-14 bg-white bg-opacity-20 rounded-full flex items-center justify-center">
                  <User className="w-7 h-7" />
                </div>
                <div>
                  <h2 className="text-2xl font-bold">{selectedPatient.name}</h2>
                  <p className="text-teal-100">Age: {selectedPatient.age} | ID: {String(selectedPatient.id).slice(0, 8)}</p>
                </div>
              </div>
              <button
                onClick={generateMedicalReport}
                className="flex items-center gap-2 bg-white bg-opacity-20 hover:bg-opacity-30 px-4 py-2 rounded-lg transition"
              >
                <Download className="w-5 h-5" />
                Report
              </button>
            </div>

            <div className="border-b border-gray-200 px-6 flex">
              <button
                onClick={() => setActiveTab('timeline')}
                className={`py-4 px-4 font-semibold border-b-2 transition ${activeTab === 'timeline'
                  ? 'border-teal-600 text-teal-600'
                  : 'border-transparent text-gray-600'
                  }`}
              >
                <Calendar className="w-5 h-5 inline mr-2" />
                Timeline
              </button>
              <button
                onClick={() => setActiveTab('gallery')}
                className={`py-4 px-4 font-semibold border-b-2 transition ${activeTab === 'gallery'
                  ? 'border-teal-600 text-teal-600'
                  : 'border-transparent text-gray-600'
                  }`}
              >
                <ImageIcon className="w-5 h-5 inline mr-2" />
                Media Gallery
              </button>
            </div>

            <div className="p-6">
              {activeTab === 'timeline' && (
                <div>
                  <div className="flex gap-2 mb-6 flex-wrap">
                    {(['All', 'GYNA', 'OBS', 'IVF'] as const).map(f => (
                      <button
                        key={f}
                        onClick={() => setSelectedFilter(f)}
                        className={`px-4 py-2 rounded-full font-medium transition ${selectedFilter === f
                          ? 'bg-teal-600 text-white'
                          : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                          }`}
                      >
                        {f === 'GYNA' ? 'â™¥ Gynecology' : f === 'OBS' ? 'ğŸ‘¶ Obstetrics' : f === 'IVF' ? 'ğŸ§¬ IVF' : 'ğŸ“‹ All'}
                      </button>
                    ))}
                  </div>

                  {getFilteredVisits().length > 0 ? (
                    <div className="space-y-4">
                      {getFilteredVisits().map((v) => {
                        const colors = getDepartmentColor(v.department);
                        const isExpanded = expandedVisitId === v.id;

                        return (
                          <div key={v.id} className="flex gap-4">
                            <div className="flex flex-col items-center">
                              <div className={`w-4 h-4 rounded-full ${colors.dot} border-4 border-white shadow-md`} />
                              <div className="w-1 bg-gray-300 flex-1 h-12" />
                            </div>

                            <div
                              className={`flex-1 ${colors.bg} border-2 ${colors.border} rounded-lg p-4 cursor-pointer transition hover:shadow-md`}
                              onClick={() => setExpandedVisitId(isExpanded ? null : v.id)}
                            >
                              <div className="flex items-start justify-between">
                                <div className="flex-1">
                                  <div className="flex items-center gap-2 mb-2">
                                    {getDepartmentIcon(v.department)}
                                    <h3 className="font-semibold text-gray-900">{getDepartmentName(v.department)}</h3>
                                    <span className="text-xs text-gray-500">{formatDate(v.date)}</span>
                                  </div>
                                  <p className="text-sm font-medium text-gray-700">{v.diagnosis || 'No diagnosis'}</p>
                                </div>
                                {isExpanded ? <ChevronUp className="w-5 h-5" /> : <ChevronDown className="w-5 h-5" />}
                              </div>

                              {isExpanded && (
                                <div className="mt-4 pt-4 border-t border-opacity-30">
                                  <div className="bg-white bg-opacity-60 p-3 rounded mb-3">
                                    {renderClinicalData(v.clinical_data, v.department)}
                                  </div>
                                  {v.notes && (
                                    <div className="mb-3">
                                      <p className="text-xs font-medium text-gray-600 mb-1">Notes:</p>
                                      <p className="text-sm text-gray-700 italic">{v.notes}</p>
                                    </div>
                                  )}
                                  {v.prescription && v.prescription.length > 0 && (
                                    <button
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        setSelectedVisit(v);
                                        setIsPrinterOpen(true);
                                      }}
                                      className="mt-3 flex items-center gap-2 text-sm text-teal-600 hover:text-teal-700 font-medium"
                                    >
                                      <Printer className="w-4 h-4" />
                                      Print Prescription
                                    </button>
                                  )}
                                </div>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  ) : (
                    <div className="text-center py-12 text-gray-500">
                      <Calendar className="w-12 h-12 mx-auto mb-3 text-gray-300" />
                      No visits found for this filter
                    </div>
                  )}
                </div>
              )}

              {activeTab === 'gallery' && (
                <div>
                  {patientFiles.length > 0 ? (
                    <div>
                      {Object.entries(groupFilesByDate(patientFiles)).map(([date, files]) => (
                        <div key={date} className="mb-8">
                          <h3 className="text-lg font-semibold text-gray-900 mb-4">{date}</h3>
                          <div className="grid grid-cols-4 gap-4">
                            {files.map(f => (
                              <div
                                key={f.id}
                                className="bg-gray-100 rounded-lg overflow-hidden cursor-pointer group hover:shadow-lg transition"
                                onClick={() => setSelectedImage(f)}
                              >
                                <div className="aspect-square bg-gradient-to-br from-gray-200 to-gray-300 flex items-center justify-center group-hover:from-gray-300 group-hover:to-gray-400">
                                  <ImageIcon className="w-8 h-8 text-gray-500" />
                                </div>
                                <p className="text-xs text-gray-600 p-2 truncate">{f.name || 'File'}</p>
                              </div>
                            ))}
                          </div>
                        </div>
                      ))}

                      {selectedImage && (
                        <div
                          className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4"
                          onClick={() => setSelectedImage(null)}
                        >
                          <div
                            className="bg-white rounded-lg p-4 max-w-2xl w-full"
                            onClick={(e) => e.stopPropagation()}
                          >
                            <div className="flex items-center justify-between mb-4">
                              <h3 className="text-lg font-semibold">{selectedImage.name || 'File'}</h3>
                              <button onClick={() => setSelectedImage(null)} className="text-gray-600 hover:text-gray-900">
                                <X className="w-6 h-6" />
                              </button>
                            </div>
                            <div className="bg-gray-100 rounded-lg p-4 min-h-96 flex items-center justify-center">
                              <ImageIcon className="w-16 h-16 text-gray-400" />
                            </div>
                            <p className="text-sm text-gray-600 mt-4">{formatDate(selectedImage.created_at)}</p>
                          </div>
                        </div>
                      )}
                    </div>
                  ) : (
                    <div className="text-center py-12 text-gray-500">
                      <ImageIcon className="w-12 h-12 mx-auto mb-3 text-gray-300" />
                      No media files available
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        )}
      </div>

      {isPrinterOpen && selectedVisit && (
        <PrescriptionPrinter
          patient={selectedPatient || null}
          prescriptions={selectedVisit.prescription || []}
          diagnosis={selectedVisit.diagnosis}
          notes={selectedVisit.notes}
          isOpen={isPrinterOpen}
          onClose={() => {
            setIsPrinterOpen(false);
            setSelectedVisit(null);
          }}
        />
      )}
    </div>
  );
};

export default PatientMasterRecord;
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
// @ts-ignore
import react from '@vitejs/plugin-react';

import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      injectRegister: null, // We handle registration manually in src/lib/pwa.ts
      devOptions: {
        enabled: false,
        type: 'module',
      },
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'mask-icon.svg'],
      manifest: {
        name: 'Nile IVF Center',
        short_name: 'Nile IVF',
        description: 'Comprehensive IVF and Obstetrics Management System',
        start_url: '/',
        display: 'standalone',
        background_color: '#ffffff',
        theme_color: '#00838f',
        orientation: 'portrait',
        scope: '/',
        lang: 'ar-EG',
        dir: 'ltr',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png',
            purpose: 'any maskable'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable'
          }
        ],
        categories: ['medical', 'health', 'productivity']
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
            handler: 'CacheFirst',
            options: {
              cacheName: 'google-fonts-cache',
              expiration: {
                maxEntries: 10,
                maxAgeSeconds: 60 * 60 * 24 * 365 // <== 365 days
              },
              cacheableResponse: {
                statuses: [0, 200]
              }
            }
          },
          {
            urlPattern: /^https:\/\/fonts\.gstatic\.com\/.*/i,
            handler: 'CacheFirst',
            options: {
              cacheName: 'gstatic-fonts-cache',
              expiration: {
                maxEntries: 10,
                maxAgeSeconds: 60 * 60 * 24 * 365 // <== 365 days
              },
              cacheableResponse: {
                statuses: [0, 200]
              },
            }
          }
        ]
      }
    })
  ],
  optimizeDeps: {
    exclude: ['@journeyapps/wa-sqlite', '@powersync/web'],
    include: ['@powersync/web > uuid', '@powersync/web > event-iterator', '@powersync/web > js-logger']
  },
  worker: {
    format: 'es',
    plugins: () => [react()]
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: undefined
      }
    },
    target: 'esnext'
  }
});
</file>

<file path="package.json">
{
  "name": "dr-salah-ivf-center",
  "private": true,
  "version": "1.0.0",
  "author": "Dr. Mohamed Salah Gabr",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "typecheck": "tsc --noEmit",
    "preview": "vite preview"
  },
  "dependencies": {
    "@journeyapps/wa-sqlite": "^1.4.1",
    "@powersync/react": "^1.8.2",
    "@powersync/web": "^1.29.1",
    "@supabase/supabase-js": "^2.39.7",
    "clsx": "^2.1.0",
    "lucide-react": "^0.344.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hot-toast": "^2.4.1",
    "recharts": "^2.12.2",
    "tailwind-merge": "^2.2.1",
    "wa-sqlite": "^1.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.64",
    "@types/react-dom": "^18.2.21",
    "@vitejs/plugin-react": "^4.7.0",
    "autoprefixer": "^10.4.18",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.9.3",
    "vite": "^7.2.7",
    "vite-plugin-pwa": "^1.2.0"
  }
}
</file>

<file path="pages/Settings.tsx">
import React, { useState, useEffect } from 'react';
import { User, Palette, FileText, Lock, Upload, Save, AlertCircle, CheckCircle, Facebook, MessageCircle, Loader, Database, RefreshCw, Wifi, WifiOff, Server } from 'lucide-react';
import toast from 'react-hot-toast';
import { authService } from '../services/authService';
import { useBranding } from '../context/BrandingContext';
import { Doctor } from '../types';
import { powerSyncDb } from '../src/powersync/client';
import RefreshButton from '../components/RefreshButton';
import { useStatus } from '@powersync/react';
import { supabase } from '../services/supabaseClient';
import { initPowerSync } from '../src/powersync/client';

interface SettingsProps {
  user: any;
}

const Settings: React.FC<SettingsProps> = ({ user }) => {
  const { branding, updateBranding, loading: brandingLoading } = useBranding();
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [doctor, setDoctor] = useState<Doctor | null>(null);
  const [activeTab, setActiveTab] = useState<'branding' | 'prescription' | 'profile' | 'password' | 'data' | 'connection'>('branding');

  const [brandingFormData, setBrandingFormData] = useState({
    clinic_name: '',
    primary_color: '',
    logo_url: '' as string | null,
  });

  const [prescriptionFormData, setPrescriptionFormData] = useState({
    clinic_address: '',
    clinic_phone: '',
    default_rx_notes: '',
  });

  const [profileFormData, setProfileFormData] = useState({
    name: '',
    email: '',
    phone: '',
    specialization: '',
    doctor_image: '',
  });

  const [passwordData, setPasswordData] = useState({
    newPassword: '',
    confirmPassword: '',
  });

  const [logoPreview, setLogoPreview] = useState<string | null>(null);
  const [logoUploadLoading, setLogoUploadLoading] = useState(false);
  const [hardResetLoading, setHardResetLoading] = useState(false);
  
  // Connection status
  const powerSyncStatus = useStatus();
  const [supabaseStatus, setSupabaseStatus] = useState<{
    connected: boolean;
    url: string;
    error?: string;
    user?: any;
  }>({ connected: false, url: '' });
  const [checkingConnection, setCheckingConnection] = useState(false);

  useEffect(() => {
    const fetchData = async () => {
      try {
        if (user?.id) {
          await authService.ensureDoctorRecord(user.id, user.email);
          const doctorProfile = await authService.getDoctorProfile(user.id);
          setDoctor(doctorProfile);
          setProfileFormData({
            name: doctorProfile.name || '',
            email: doctorProfile.email || '',
            phone: doctorProfile.phone || '',
            specialization: doctorProfile.specialization || '',
            doctor_image: doctorProfile.doctor_image || '',
          });
        }
      } catch (error) {
        console.error('Failed to fetch doctor profile:', error);
        toast.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
    checkConnections();
  }, [user]);

  const checkConnections = async () => {
    setCheckingConnection(true);
    try {
      // Check Supabase
      const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
      if (!supabaseUrl) {
        setSupabaseStatus({
          connected: false,
          url: 'Not configured',
          error: 'VITE_SUPABASE_URL not found'
        });
      } else {
        const { data: { session }, error: sessionError } = await supabase.auth.getSession();
        if (sessionError || !session) {
          setSupabaseStatus({
            connected: false,
            url: supabaseUrl,
            error: sessionError?.message || 'No active session'
          });
        } else {
          // Test database query
          const { error: dbError } = await supabase.from('patients').select('id').limit(1);
          setSupabaseStatus({
            connected: !dbError,
            url: supabaseUrl,
            error: dbError?.message,
            user: session.user
          });
        }
      }
    } catch (error: any) {
      setSupabaseStatus({
        connected: false,
        url: import.meta.env.VITE_SUPABASE_URL || 'Unknown',
        error: error?.message || 'Unknown error'
      });
    } finally {
      setCheckingConnection(false);
    }
  };

  const handleReconnectPowerSync = async () => {
    try {
      setCheckingConnection(true);
      toast.loading('Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„...', { id: 'reconnect' });
      
      // Force reconnection by passing force=true
      await initPowerSync(3, 2000, true);
      
      // Wait a bit for status to update
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Check if connected now
      if (powerSyncStatus.connected) {
        toast.success('âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­!', { id: 'reconnect' });
      } else {
        toast.error('âš ï¸ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ - ØªØ­Ù‚Ù‚ Ù…Ù† Console Ù„Ù„ØªÙØ§ØµÙŠÙ„', { id: 'reconnect', duration: 5000 });
      }
    } catch (error: any) {
      console.error('âŒ Reconnection error:', error);
      toast.error(`âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„: ${error?.message || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}`, { id: 'reconnect', duration: 5000 });
    } finally {
      setCheckingConnection(false);
      // Refresh connection status
      setTimeout(() => checkConnections(), 2000);
    }
  };

  // Legacy sync stats effects removed

  useEffect(() => {
    if (branding) {
      setBrandingFormData({
        clinic_name: branding.clinic_name || '',
        primary_color: branding.primary_color || '#2d5a6b',
        logo_url: branding.logo_url || null,
      });
      setPrescriptionFormData({
        clinic_address: branding.clinic_address || '',
        clinic_phone: branding.clinic_phone || '',
        default_rx_notes: branding.default_rx_notes || '',
      });
      setLogoPreview(branding.logo_url);
    }
  }, [branding]);

  const handleLogoUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    try {
      setLogoUploadLoading(true);
      const reader = new FileReader();
      reader.onloadend = () => {
        setLogoPreview(reader.result as string);
      };
      reader.readAsDataURL(file);

      await updateBranding({ clinic_name: brandingFormData.clinic_name }, file);
      toast.success('ØªÙ… Ø±ÙØ¹ Ø§Ù„Ø´Ø¹Ø§Ø± Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('Upload error:', error);
      toast.error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„Ø´Ø¹Ø§Ø±. ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ bucket "branding" ÙÙŠ Supabase');
      setLogoPreview(branding?.logo_url || null);
    } finally {
      setLogoUploadLoading(false);
    }
  };

  const handleBrandingSave = async () => {
    try {
      setSaving(true);
      await updateBranding({
        clinic_name: brandingFormData.clinic_name,
        primary_color: brandingFormData.primary_color,
      });
      toast.success('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡ÙˆÙŠØ© Ø§Ù„Ø¨ØµØ±ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('Save error:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡ÙˆÙŠØ© Ø§Ù„Ø¨ØµØ±ÙŠØ©');
    } finally {
      setSaving(false);
    }
  };

  const handlePrescriptionSave = async () => {
    try {
      setSaving(true);
      await updateBranding({
        clinic_address: prescriptionFormData.clinic_address,
        clinic_phone: prescriptionFormData.clinic_phone,
        default_rx_notes: prescriptionFormData.default_rx_notes,
      });
      toast.success('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±ÙˆØ´ØªØ© Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('Save error:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±ÙˆØ´ØªØ©');
    } finally {
      setSaving(false);
    }
  };

  const handleProfileSave = async () => {
    try {
      setSaving(true);
      await authService.updateDoctorProfile(user.id, {
        name: profileFormData.name,
        phone: profileFormData.phone,
        specialization: profileFormData.specialization,
        doctor_image: profileFormData.doctor_image,
      });
      toast.success('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('Save error:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ');
    } finally {
      setSaving(false);
    }
  };

  const handleDoctorImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    try {
      setSaving(true);
      const imageUrl = await authService.uploadImage(user.id, file, 'doctor_images');
      setProfileFormData(prev => ({ ...prev, doctor_image: imageUrl }));
      toast.success('ØªÙ… Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('Upload error:', error);
      toast.error('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©');
    } finally {
      setSaving(false);
    }
  };

  const handlePasswordSave = async () => {
    if (passwordData.newPassword !== passwordData.confirmPassword) {
      toast.error('ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©');
      return;
    }

    if (passwordData.newPassword.length < 6) {
      toast.error('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
      return;
    }

    try {
      setSaving(true);
      await authService.updatePassword(passwordData.newPassword);
      setPasswordData({ newPassword: '', confirmPassword: '' });
      toast.success('ØªÙ… ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('Password update error:', error);
      toast.error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±');
    } finally {
      setSaving(false);
    }
  };

  // Unused handlers removed

  const handleHardReset = async () => {
    const confirmed = window.confirm('âš ï¸ ØªØ­Ø°ÙŠØ±: Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© ÙˆØ¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„Ù‡Ø§ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ');
    if (!confirmed) return;

    try {
      setHardResetLoading(true);
      toast.loading('Ø¬Ø§Ø±ÙŠ Ø­Ø°Ù Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©...', { id: 'hard-reset' });

      // TODO: Implement PowerSync database reset
      // await db.delete();

      toast.loading('Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...', { id: 'hard-reset' });

      // TODO: Implement PowerSync database initialization
      // await initLocalDB();

      toast.loading('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±...', { id: 'hard-reset' });

      // Clear local database to force re-sync on reload
      await powerSyncDb.disconnectAndClear();

      toast.success('ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­! Ø³ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©...', { id: 'hard-reset' });

      // Reload page
      setTimeout(() => {
        window.location.reload();
      }, 2000);

    } catch (error) {
      console.error('Hard reset error:', error);
      toast.error('ÙØ´Ù„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', { id: 'hard-reset' });
    } finally {
      setHardResetLoading(false);
    }
  };

  if (loading || brandingLoading) {
    return (
      <div className="flex items-center justify-center h-96">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-teal-600"></div>
      </div>
    );
  }

  return (
    <div className="max-w-6xl mx-auto">
      <div className="mb-8 flex items-start justify-between">
        <div>
          <h1 className="text-4xl font-bold text-gray-900 mb-2 font-[Tajawal]">Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠØ©</h1>
          <p className="text-gray-600 font-[Tajawal]">ØªØ­ÙƒÙ… ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙˆØ§Ù„Ù‡ÙˆÙŠØ© Ø§Ù„Ø¨ØµØ±ÙŠØ© ÙˆØ§Ù„Ø±ÙˆØ´ØªØ§Øª Ø§Ù„Ø·Ø¨ÙŠØ©</p>
        </div>
        <RefreshButton />
      </div>

      <div className="flex flex-col md:flex-row gap-4 mb-8 border-b border-gray-200">
        <button
          onClick={() => setActiveTab('branding')}
          className={`flex items-center gap-2 px-4 py-3 font-[Tajawal] font-semibold border-b-2 transition-colors ${activeTab === 'branding'
            ? 'border-teal-600 text-teal-600'
            : 'border-transparent text-gray-500 hover:text-gray-700'
            }`}
        >
          <Palette size={20} />
          Ø§Ù„Ù…Ø¸Ù‡Ø± ÙˆØ§Ù„Ù‡ÙˆÙŠØ©
        </button>
        <button
          onClick={() => setActiveTab('prescription')}
          className={`flex items-center gap-2 px-4 py-3 font-[Tajawal] font-semibold border-b-2 transition-colors ${activeTab === 'prescription'
            ? 'border-teal-600 text-teal-600'
            : 'border-transparent text-gray-500 hover:text-gray-700'
            }`}
        >
          <FileText size={20} />
          Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±ÙˆØ´ØªØ©
        </button>
        <button
          onClick={() => setActiveTab('profile')}
          className={`flex items-center gap-2 px-4 py-3 font-[Tajawal] font-semibold border-b-2 transition-colors ${activeTab === 'profile'
            ? 'border-teal-600 text-teal-600'
            : 'border-transparent text-gray-500 hover:text-gray-700'
            }`}
        >
          <User size={20} />
          Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
        </button>
        <button
          onClick={() => setActiveTab('password')}
          className={`flex items-center gap-2 px-4 py-3 font-[Tajawal] font-semibold border-b-2 transition-colors ${activeTab === 'password'
            ? 'border-teal-600 text-teal-600'
            : 'border-transparent text-gray-500 hover:text-gray-700'
            }`}
        >
          <Lock size={20} />
          ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
        </button>
        <button
          onClick={() => setActiveTab('data')}
          className={`flex items-center gap-2 px-4 py-3 font-[Tajawal] font-semibold border-b-2 transition-colors ${activeTab === 'data'
            ? 'border-teal-600 text-teal-600'
            : 'border-transparent text-gray-500 hover:text-gray-700'
            }`}
        >
          <Database size={20} />
          Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        </button>
        <button
          onClick={() => setActiveTab('connection')}
          className={`flex items-center gap-2 px-4 py-3 font-[Tajawal] font-semibold border-b-2 transition-colors ${activeTab === 'connection'
            ? 'border-teal-600 text-teal-600'
            : 'border-transparent text-gray-500 hover:text-gray-700'
            }`}
        >
          <Server size={20} />
          Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„
        </button>
      </div>

      {activeTab === 'branding' && (
        <div className="bg-white rounded-lg shadow-md p-8">
          <div className="grid md:grid-cols-2 gap-8">
            <div>
              <h3 className="text-xl font-bold text-gray-900 mb-6 font-[Tajawal]">Ø§Ù„Ù…Ø¸Ù‡Ø± ÙˆØ§Ù„Ù‡ÙˆÙŠØ©</h3>

              <div className="mb-6">
                <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø§Ø³Ù… Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©</label>
                <input
                  type="text"
                  value={brandingFormData.clinic_name}
                  onChange={(e) => setBrandingFormData(prev => ({ ...prev, clinic_name: e.target.value }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
                  placeholder="Ø³ÙŠØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠ ÙˆØµÙØ­Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„"
                />
              </div>

              <div className="mb-6">
                <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ</label>
                <div className="flex gap-4 items-center">
                  <input
                    type="color"
                    value={brandingFormData.primary_color}
                    onChange={(e) => setBrandingFormData(prev => ({ ...prev, primary_color: e.target.value }))}
                    className="w-16 h-10 rounded border border-gray-300 cursor-pointer"
                  />
                  <input
                    type="text"
                    value={brandingFormData.primary_color}
                    onChange={(e) => setBrandingFormData(prev => ({ ...prev, primary_color: e.target.value }))}
                    className="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
                    placeholder="#2d5a6b"
                  />
                </div>
                <p className="text-xs text-gray-500 mt-2 font-[Tajawal]">Ø³ÙŠØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙˆØ§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† ÙˆØ§Ù„Ø±ÙˆØ§Ø¨Ø·</p>
              </div>

              <button
                onClick={handleBrandingSave}
                disabled={saving}
                className="w-full flex items-center justify-center gap-2 bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-[Tajawal] font-semibold transition-colors"
              >
                <Save size={18} />
                {saving ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...' : 'Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª'}
              </button>
            </div>

            <div>
              <h3 className="text-xl font-bold text-gray-900 mb-6 font-[Tajawal]">Ø´Ø¹Ø§Ø± Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©</h3>

              <div className="bg-gray-50 rounded-lg border-2 border-dashed border-gray-300 p-8 text-center">
                {logoPreview ? (
                  <div className="mb-4">
                    <img
                      src={logoPreview}
                      alt="Clinic logo"
                      className="w-40 h-40 rounded-lg mx-auto object-cover border-4 border-teal-600 mb-4"
                    />
                  </div>
                ) : (
                  <Palette size={64} className="mx-auto text-gray-400 mb-4" />
                )}

                <label className="inline-flex items-center gap-2 bg-teal-600 hover:bg-teal-700 text-white px-6 py-2 rounded-lg cursor-pointer font-[Tajawal] font-semibold transition-colors">
                  {logoUploadLoading ? (
                    <>
                      <Loader size={18} className="animate-spin" />
                      Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø±ÙØ¹...
                    </>
                  ) : (
                    <>
                      <Upload size={18} />
                      Ø§Ø®ØªØ± Ø´Ø¹Ø§Ø±
                    </>
                  )}
                  <input
                    type="file"
                    accept="image/*"
                    onChange={handleLogoUpload}
                    disabled={logoUploadLoading}
                    className="hidden"
                  />
                </label>

                <p className="text-xs text-gray-500 mt-4 font-[Tajawal]">PNG, JPG Ø­ØªÙ‰ 10MB</p>
              </div>
            </div>
          </div>
        </div>
      )}

      {activeTab === 'prescription' && (
        <div className="bg-white rounded-lg shadow-md p-8 max-w-2xl">
          <h3 className="text-xl font-bold text-gray-900 mb-6 font-[Tajawal]">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø±ÙˆØ´ØªØ© Ø§Ù„Ø·Ø¨ÙŠØ©</h3>

          <div className="mb-6">
            <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©</label>
            <textarea
              value={prescriptionFormData.clinic_address}
              onChange={(e) => setPrescriptionFormData(prev => ({ ...prev, clinic_address: e.target.value }))}
              rows={3}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
              placeholder="Ø³ÙŠØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø³ÙÙ„ÙŠ Ù…Ù† Ø§Ù„Ø±ÙˆØ´ØªØ© Ø§Ù„Ù…Ø·Ø¨ÙˆØ¹Ø©"
            />
          </div>

          <div className="mb-6">
            <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø§Ù„Ø¹ÙŠØ§Ø¯Ø©</label>
            <input
              type="tel"
              value={prescriptionFormData.clinic_phone}
              onChange={(e) => setPrescriptionFormData(prev => ({ ...prev, clinic_phone: e.target.value }))}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
              placeholder="Ù…Ø«Ø§Ù„: 201003418068"
            />
          </div>

          <div className="mb-6">
            <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø±ÙˆØ´ØªØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©</label>
            <textarea
              value={prescriptionFormData.default_rx_notes}
              onChange={(e) => setPrescriptionFormData(prev => ({ ...prev, default_rx_notes: e.target.value }))}
              rows={5}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
              placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø§Ù„ØªÙŠ Ø³ØªØ¸Ù‡Ø± ÙÙŠ ÙƒÙ„ Ø±ÙˆØ´ØªØ©..."
            />
            <p className="text-xs text-gray-500 mt-2 font-[Tajawal]">Ø³ØªØ¸Ù‡Ø± Ù‡Ø°Ù‡ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±ÙˆØ´ØªØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</p>
          </div>

          <button
            onClick={handlePrescriptionSave}
            disabled={saving}
            className="w-full flex items-center justify-center gap-2 bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-[Tajawal] font-semibold transition-colors"
          >
            <Save size={18} />
            {saving ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...' : 'Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª'}
          </button>
        </div>
      )}

      {activeTab === 'profile' && (
        <div className="bg-white rounded-lg shadow-md p-8">
          <div className="grid md:grid-cols-2 gap-8">
            <div>
              <h3 className="text-xl font-bold text-gray-900 mb-6 font-[Tajawal]">Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ</h3>

              <div className="mb-6">
                <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø§Ù„Ø§Ø³Ù…</label>
                <input
                  type="text"
                  value={profileFormData.name}
                  onChange={(e) => setProfileFormData(prev => ({ ...prev, name: e.target.value }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
                />
              </div>

              <div className="mb-6">
                <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</label>
                <input
                  type="email"
                  value={profileFormData.email}
                  disabled
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg bg-gray-50 text-gray-500 font-[Tajawal]"
                />
              </div>

              <div className="mb-6">
                <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø§Ù„Ù‡Ø§ØªÙ</label>
                <input
                  type="tel"
                  value={profileFormData.phone}
                  onChange={(e) => setProfileFormData(prev => ({ ...prev, phone: e.target.value }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
                />
              </div>

              <div className="mb-6">
                <label className="block text-sm font-semibold text-gray-700 mb-2 font-[Tajawal]">Ø§Ù„ØªØ®ØµØµ</label>
                <input
                  type="text"
                  value={profileFormData.specialization}
                  onChange={(e) => setProfileFormData(prev => ({ ...prev, specialization: e.target.value }))}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
                />
              </div>

              <button
                onClick={handleProfileSave}
                disabled={saving}
                className="w-full flex items-center justify-center gap-2 bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-[Tajawal] font-semibold transition-colors"
              >
                <Save size={18} />
                {saving ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...' : 'Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'}
              </button>
            </div>

            <div>
              <h3 className="text-xl font-bold text-gray-900 mb-6 font-[Tajawal]">ØµÙˆØ±Ø© Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ</h3>

              <div className="bg-gray-50 rounded-lg border-2 border-dashed border-gray-300 p-8 text-center">
                {profileFormData.doctor_image ? (
                  <div className="mb-4">
                    <img
                      src={profileFormData.doctor_image}
                      alt="Doctor profile"
                      className="w-40 h-40 rounded-full mx-auto object-cover border-4 border-teal-600 mb-4"
                    />
                  </div>
                ) : (
                  <User size={64} className="mx-auto text-gray-400 mb-4" />
                )}

                <label className="inline-flex items-center gap-2 bg-teal-600 hover:bg-teal-700 text-white px-6 py-2 rounded-lg cursor-pointer font-[Tajawal] font-semibold transition-colors">
                  <Upload size={18} />
                  Ø§Ø®ØªØ± ØµÙˆØ±Ø©
                  <input
                    type="file"
                    accept="image/*"
                    onChange={handleDoctorImageUpload}
                    disabled={saving}
                    className="hidden"
                  />
                </label>

                <p className="text-xs text-gray-500 mt-4 font-[Tajawal]">PNG, JPG Ø­ØªÙ‰ 10MB</p>
              </div>
            </div>
          </div>
        </div>
      )}

      {activeTab === 'password' && (
        <div className="bg-white rounded-lg shadow-md p-8 max-w-xl">
          <h3 className="text-xl font-bold text-gray-900 mb-6 flex items-center gap-2 font-[Tajawal]">
            <AlertCircle size={24} className="text-orange-500" />
            ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
          </h3>

          <div className="mb-6">
            <label className="block text-sm font-semibold text-gray-700 mb-2">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</label>
            <input
              type="password"
              value={passwordData.newPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, newPassword: e.target.value }))}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
              placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©"
            />
          </div>

          <div className="mb-6">
            <label className="block text-sm font-semibold text-gray-700 mb-2">ØªØ£ÙƒÙŠØ¯ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</label>
            <input
              type="password"
              value={passwordData.confirmPassword}
              onChange={(e) => setPasswordData(prev => ({ ...prev, confirmPassword: e.target.value }))}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500 focus:border-transparent font-[Tajawal]"
              placeholder="Ø£Ø¹Ø¯ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±"
            />
          </div>

          <p className="text-sm text-gray-600 mb-6 flex items-center gap-2">
            <AlertCircle size={16} />
            ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„
          </p>

          <button
            onClick={handlePasswordSave}
            disabled={saving}
            className="w-full flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-[Tajawal] font-semibold transition-colors"
          >
            <Save size={18} />
            {saving ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ«...' : 'ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±'}
          </button>
        </div>
      )}

      {activeTab === 'connection' && (
        <div className="bg-white rounded-lg shadow-md p-8">
          <div className="flex items-center justify-between mb-6">
            <h3 className="text-xl font-bold text-gray-900 font-[Tajawal]">Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„</h3>
            <button
              onClick={checkConnections}
              disabled={checkingConnection}
              className="flex items-center gap-2 px-4 py-2 bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white rounded-lg font-[Tajawal] transition-colors"
            >
              <RefreshCw size={18} className={checkingConnection ? 'animate-spin' : ''} />
              ØªØ­Ø¯ÙŠØ«
            </button>
          </div>

          <div className="grid md:grid-cols-2 gap-6 mb-6">
            {/* Supabase Status */}
            <div className={`border-2 rounded-lg p-6 ${supabaseStatus.connected ? 'border-green-200 bg-green-50' : 'border-red-200 bg-red-50'}`}>
              <div className="flex items-center justify-between mb-4">
                <h4 className="text-lg font-semibold text-gray-900 font-[Tajawal]">Supabase</h4>
                {supabaseStatus.connected ? (
                  <CheckCircle className="text-green-600" size={24} />
                ) : (
                  <AlertCircle className="text-red-600" size={24} />
                )}
              </div>
              <div className="space-y-2">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium text-gray-700 font-[Tajawal]">Ø§Ù„Ø­Ø§Ù„Ø©:</span>
                  <span className={`text-sm font-bold ${supabaseStatus.connected ? 'text-green-700' : 'text-red-700'} font-[Tajawal]`}>
                    {supabaseStatus.connected ? 'âœ… Ù…ØªØµÙ„' : 'âŒ ØºÙŠØ± Ù…ØªØµÙ„'}
                  </span>
                </div>
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium text-gray-700 font-[Tajawal]">Ø§Ù„Ø±Ø§Ø¨Ø·:</span>
                  <span className="text-xs text-gray-600 font-mono break-all">{supabaseStatus.url}</span>
                </div>
                {supabaseStatus.user && (
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-medium text-gray-700 font-[Tajawal]">Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:</span>
                    <span className="text-sm text-gray-600">{supabaseStatus.user.email}</span>
                  </div>
                )}
                {supabaseStatus.error && (
                  <div className="mt-2 p-2 bg-red-100 rounded text-xs text-red-700 font-[Tajawal]">
                    {supabaseStatus.error}
                  </div>
                )}
              </div>
            </div>

            {/* PowerSync Status */}
            <div className={`border-2 rounded-lg p-6 ${powerSyncStatus.connected ? 'border-green-200 bg-green-50' : 'border-red-200 bg-red-50'}`}>
              <div className="flex items-center justify-between mb-4">
                <h4 className="text-lg font-semibold text-gray-900 font-[Tajawal]">PowerSync</h4>
                {powerSyncStatus.connected ? (
                  <CheckCircle className="text-green-600" size={24} />
                ) : (
                  <AlertCircle className="text-red-600" size={24} />
                )}
              </div>
              <div className="space-y-2">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium text-gray-700 font-[Tajawal]">Ø§Ù„Ø­Ø§Ù„Ø©:</span>
                  <span className={`text-sm font-bold ${powerSyncStatus.connected ? 'text-green-700' : 'text-red-700'} font-[Tajawal]`}>
                    {powerSyncStatus.connected ? 'âœ… Ù…ØªØµÙ„' : powerSyncStatus.connecting ? 'ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„...' : 'âŒ ØºÙŠØ± Ù…ØªØµÙ„'}
                  </span>
                </div>
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium text-gray-700 font-[Tajawal]">Ø§Ù„Ø±Ø§Ø¨Ø·:</span>
                  <span className="text-xs text-gray-600 font-mono break-all">
                    {import.meta.env.VITE_POWERSYNC_URL || 'Not configured'}
                  </span>
                </div>
                {powerSyncStatus.lastSyncedAt && (
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-medium text-gray-700 font-[Tajawal]">Ø¢Ø®Ø± Ù…Ø²Ø§Ù…Ù†Ø©:</span>
                    <span className="text-sm text-gray-600">
                      {new Date(powerSyncStatus.lastSyncedAt).toLocaleString('ar-EG')}
                    </span>
                  </div>
                )}
                {!powerSyncStatus.connected && (
                  <div className="mt-3 space-y-2">
                    <button
                      onClick={handleReconnectPowerSync}
                      disabled={checkingConnection || powerSyncStatus.connecting}
                      className="w-full flex items-center justify-center gap-2 bg-teal-600 hover:bg-teal-700 disabled:bg-gray-400 text-white px-4 py-2 rounded-lg text-sm font-[Tajawal] transition-colors"
                    >
                      <RefreshCw size={16} className={checkingConnection ? 'animate-spin' : ''} />
                      {checkingConnection ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„...' : 'Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„'}
                    </button>
                    <p className="text-xs text-gray-600 text-center font-[Tajawal]">
                      Ø§Ø¶ØºØ· F12 ÙˆØ§ÙØªØ­ Console Ù„Ø±Ø¤ÙŠØ© ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø®Ø·Ø£
                    </p>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Overall Status */}
          <div className={`border-2 rounded-lg p-6 ${
            supabaseStatus.connected && powerSyncStatus.connected
              ? 'border-green-300 bg-green-50'
              : supabaseStatus.connected || powerSyncStatus.connected
              ? 'border-yellow-300 bg-yellow-50'
              : 'border-red-300 bg-red-50'
          }`}>
            <h4 className="text-lg font-semibold text-gray-900 mb-3 font-[Tajawal]">Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù…Ø©</h4>
            <p className={`text-sm font-[Tajawal] ${
              supabaseStatus.connected && powerSyncStatus.connected
                ? 'text-green-800'
                : supabaseStatus.connected || powerSyncStatus.connected
                ? 'text-yellow-800'
                : 'text-red-800'
            }`}>
              {supabaseStatus.connected && powerSyncStatus.connected
                ? 'âœ… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª ØªØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ - Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ²Ø§Ù…Ù†Ø©'
                : supabaseStatus.connected
                ? 'âš ï¸ Supabase Ù…ØªØµÙ„ØŒ Ù„ÙƒÙ† PowerSync ØºÙŠØ± Ù…ØªØµÙ„ - Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ§Ø­Ø© Ù…Ù† Supabase Ù…Ø¨Ø§Ø´Ø±Ø©'
                : powerSyncStatus.connected
                ? 'âš ï¸ PowerSync Ù…ØªØµÙ„ØŒ Ù„ÙƒÙ† Supabase ØºÙŠØ± Ù…ØªØµÙ„'
                : 'âŒ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª ÙØ§Ø´Ù„Ø© - ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª'}
            </p>
          </div>

          {/* Environment Variables Check */}
          <div className="mt-6 border border-gray-200 rounded-lg p-6">
            <h4 className="text-lg font-semibold text-gray-900 mb-4 font-[Tajawal]">Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©</h4>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <span className="text-sm font-medium text-gray-700 font-[Tajawal]">VITE_SUPABASE_URL:</span>
                <span className={`text-xs font-mono ${import.meta.env.VITE_SUPABASE_URL ? 'text-green-600' : 'text-red-600'}`}>
                  {import.meta.env.VITE_SUPABASE_URL ? 'âœ“ Ù…ÙˆØ¬ÙˆØ¯' : 'âœ— ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'}
                </span>
              </div>
              <div className="flex items-center justify-between">
                <span className="text-sm font-medium text-gray-700 font-[Tajawal]">VITE_SUPABASE_ANON_KEY:</span>
                <span className={`text-xs font-mono ${import.meta.env.VITE_SUPABASE_ANON_KEY ? 'text-green-600' : 'text-red-600'}`}>
                  {import.meta.env.VITE_SUPABASE_ANON_KEY ? 'âœ“ Ù…ÙˆØ¬ÙˆØ¯' : 'âœ— ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'}
                </span>
              </div>
              <div className="flex items-center justify-between">
                <span className="text-sm font-medium text-gray-700 font-[Tajawal]">VITE_POWERSYNC_URL:</span>
                <span className={`text-xs font-mono ${import.meta.env.VITE_POWERSYNC_URL ? 'text-green-600' : 'text-red-600'}`}>
                  {import.meta.env.VITE_POWERSYNC_URL ? 'âœ“ Ù…ÙˆØ¬ÙˆØ¯' : 'âœ— ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'}
                </span>
              </div>
            </div>
            
            {/* Troubleshooting Tips */}
            {!powerSyncStatus.connected && (
              <div className="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                <h5 className="text-sm font-semibold text-yellow-900 mb-2 font-[Tajawal]">Ù†ØµØ§Ø¦Ø­ Ù„Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©:</h5>
                <ul className="text-xs text-yellow-800 space-y-1 list-disc list-inside font-[Tajawal]">
                  <li>ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¬Ù…ÙŠØ¹ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© ÙÙŠ Ù…Ù„Ù .env</li>
                  <li>Ø£Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø³ÙŠØ±ÙØ± Ø§Ù„ØªØ·ÙˆÙŠØ± Ø¨Ø¹Ø¯ ØªØ¹Ø¯ÙŠÙ„ .env</li>
                  <li>ØªØ­Ù‚Ù‚ Ù…Ù† Console (F12) Ù„Ø±Ø¤ÙŠØ© ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø®Ø·Ø£</li>
                  <li>ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† PowerSync URL ØµØ­ÙŠØ­ Ù…Ù† Dashboard</li>
                  <li>ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ùƒ Ù…Ø³Ø¬Ù„ Ø¯Ø®ÙˆÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­</li>
                </ul>
              </div>
            )}
          </div>
        </div>
      )}

      {activeTab === 'data' && (
        <div className="bg-white rounded-lg shadow-md p-8">
          <h3 className="text-xl font-bold text-gray-900 mb-6 font-[Tajawal]">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ù…Ø²Ø§Ù…Ù†Ø©</h3>

          <div className="grid md:grid-cols-1 gap-8 mb-8">
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
              <h4 className="text-lg font-semibold text-blue-900 mb-2 font-[Tajawal]">Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©</h4>
              <p className="text-sm text-blue-800 font-[Tajawal]">
                ÙŠØªÙ… Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù…Ø¹ Ø§Ù„Ø³ÙŠØ±ÙØ± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… PowerSync.
                ØªØ¹Ù…Ù„ Ù‡Ø°Ù‡ Ø§Ù„ØªÙ‚Ù†ÙŠØ© ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ© Ù„Ø¶Ù…Ø§Ù† ØªÙˆÙØ± Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ø¯Ø§Ø¦Ù…Ø§Ù‹ØŒ Ø­ØªÙ‰ Ø¨Ø¯ÙˆÙ† Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.
              </p>
            </div>

            <div>
              <h4 className="text-lg font-semibold text-gray-800 mb-4 font-[Tajawal]">Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·ÙˆØ±</h4>
              <p className="text-sm text-gray-600 mb-4 font-[Tajawal]">
                Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø¯Ø§Ø© Ø¹Ù†Ø¯Ù…Ø§ ØªÙƒÙˆÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†Ø© Ù…Ø¹ Ø§Ù„Ø³ÙŠØ±ÙØ± Ø£Ùˆ Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ Ù…Ø´Ø§ÙƒÙ„ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶.
              </p>
              <button
                onClick={handleHardReset}
                disabled={hardResetLoading}
                className="w-full flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-[Tajawal] font-semibold transition-colors"
              >
                {hardResetLoading ? (
                  <>
                    <Loader size={18} className="animate-spin" />
                    Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„...
                  </>
                ) : (
                  <>
                    <RefreshCw size={18} />
                    Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Hard Reset)
                  </>
                )}
              </button>
              <p className="text-xs text-red-600 mt-2 font-[Tajawal]">
                ØªØ­Ø°ÙŠØ±: Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ© ÙˆØ¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„Ù‡Ø§ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±
              </p>
            </div>
          </div>
        </div>
      )}
    </div>

  );
};

export default Settings;
</file>

<file path="services/ivfService.ts">
import { dbService } from './dbService';
import { Patient, IvfCycle, Visit, StimulationLog } from '../types';

export const calculateBMI = (weightKg: number, heightCm: number): { bmi: number; alert: boolean } => {
  if (!weightKg || !heightCm) return { bmi: 0, alert: false };
  const heightM = heightCm / 100;
  const bmi = parseFloat((weightKg / (heightM * heightM)).toFixed(1));
  return { bmi, alert: bmi > 30 };
};

export const calculateTMSC = (volume: number, concentration: number, motility: number): number => {
  if (!volume || !concentration || !motility) return 0;
  return parseFloat(((volume * concentration * motility) / 100).toFixed(2));
};

export const analyzeSemenAnalysis = (vol: number, conc: number, motility: number, morph: number): string => {
  const findings: string[] = [];
  if (vol < 1.5) findings.push("Hypospermia");
  if (conc < 15) findings.push("Oligozoospermia");
  if (motility < 40) findings.push("Asthenozoospermia");
  if (morph < 4) findings.push("Teratozoospermia");
  
  if (findings.length === 0) return "Normozoospermia (WHO 2021)";
  return findings.join(" + ");
};

export const classifyOvarianReserve = (amh?: number, afc?: number): 'Poor Responder' | 'Normal' | 'High Responder' => {
  if (!amh && !afc) return 'Normal';
  
  if ((amh && amh < 0.4) || (afc && afc < 5)) {
    return 'Poor Responder';
  }
  if ((amh && amh > 4.5) || (afc && afc > 25)) {
    return 'High Responder';
  }
  return 'Normal';
};

export const calculateMaturationRate = (totalOocytes: number, mii: number): number => {
  if (!totalOocytes || totalOocytes === 0) return 0;
  return parseFloat(((mii / totalOocytes) * 100).toFixed(1));
};

export const calculateFertilizationRate = (fertilized: number, mii: number): number => {
  if (!mii || mii === 0) return 0;
  return parseFloat(((fertilized / mii) * 100).toFixed(1));
};

export const db = dbService;
</file>

<file path="src/powersync/SupabaseConnector.ts">
/// <reference types="vite/client" />
import { PowerSyncBackendConnector, UpdateType } from '@powersync/web';
import { supabase } from '../lib/supabase';

// Cache credentials to prevent excessive calls
let credentialsCache: { endpoint: string; token: string; expiresAt: number; lastFetch: number } | null = null;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache
const MIN_FETCH_INTERVAL = 2000; // Minimum 2 seconds between fetches (even if cache invalidated)

export class SupabaseConnector implements PowerSyncBackendConnector {
  async fetchCredentials() {
    const now = Date.now();
    
    // Check cache first - use it if still valid
    if (credentialsCache && credentialsCache.expiresAt > now) {
      // Only log occasionally to reduce console spam
      if (Math.random() < 0.1) { // Log 10% of the time
        console.log('ğŸ” SupabaseConnector: Using cached credentials');
      }
      return {
        endpoint: credentialsCache.endpoint,
        token: credentialsCache.token
      };
    }

    // Rate limiting: Don't fetch too frequently even if cache invalidated
    if (credentialsCache && (now - credentialsCache.lastFetch) < MIN_FETCH_INTERVAL) {
      // Return cached token even if expired, to prevent excessive calls
      console.log('ğŸ” SupabaseConnector: Rate limiting - using cached credentials');
      return {
        endpoint: credentialsCache.endpoint,
        token: credentialsCache.token
      };
    }

    console.log('ğŸ” SupabaseConnector: Fetching credentials...');
    try {
      // Check environment variables first
      const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
      const endpoint = import.meta.env.VITE_POWERSYNC_URL;
      
      if (!supabaseUrl) {
        console.error('âŒ SupabaseConnector: VITE_SUPABASE_URL not configured');
        console.error('âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© VITE_SUPABASE_URL ÙÙŠ Ù…Ù„Ù .env');
        return null;
      }
      
      if (!endpoint) {
        console.error('âŒ SupabaseConnector: VITE_POWERSYNC_URL not configured');
        console.error('âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© VITE_POWERSYNC_URL ÙÙŠ Ù…Ù„Ù .env');
        console.error('âŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù† PowerSync Dashboard > Settings > Instance URL');
        return null;
      }

      const { data: { session }, error } = await supabase.auth.getSession();
      if (!session || error) {
        console.warn('âš ï¸ SupabaseConnector: No session found', error?.message);
        console.warn('âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰');
        // Clear cache on auth error
        credentialsCache = null;
        return null;
      }

      if (!session.access_token) {
        console.warn('âš ï¸ SupabaseConnector: No access token in session');
        console.warn('âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰');
        // Clear cache on auth error
        credentialsCache = null;
        return null;
      }

      // Cache the credentials
      credentialsCache = {
        endpoint: endpoint,
        token: session.access_token,
        expiresAt: Date.now() + CACHE_DURATION,
        lastFetch: Date.now()
      };

      // Only log occasionally to reduce console spam
      if (Math.random() < 0.2) { // Log 20% of the time
        console.log('âœ… SupabaseConnector: Credentials fetched successfully');
        console.log('ğŸ”— Endpoint:', endpoint);
        console.log('ğŸ”‘ Token exists:', !!session.access_token);
      }
      return {
        endpoint: endpoint,
        token: session.access_token
      };
    } catch (error: any) {
      console.error('âŒ SupabaseConnector: Error fetching credentials:', error?.message);
      console.error('âŒ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø®Ø·Ø£:', error);
      // Clear cache on error
      credentialsCache = null;
      return null;
    }
  }

  // Method to invalidate cache (useful when token expires)
  // Note: PowerSync SDK calls this frequently, so we use rate limiting instead of clearing cache
  invalidateCredentials() {
    // Don't clear cache immediately - use rate limiting instead
    // Only clear if cache is very old (more than 10 minutes)
    if (credentialsCache) {
      const age = Date.now() - credentialsCache.lastFetch;
      if (age > 10 * 60 * 1000) { // 10 minutes
        credentialsCache = null;
        console.log('ğŸ”„ SupabaseConnector: Credentials cache invalidated (old cache)');
      } else {
        // Just mark as needing refresh, but keep for rate limiting
        // Don't log - PowerSync calls this too frequently
      }
    }
    // Don't log invalidate calls - they're too frequent
  }

  async uploadData(database: any) {
    const transaction = await database.getNextCrudTransaction();
    if (!transaction) return;

    const UPLOAD_RETRIES = 3;
    const RETRY_DELAY = 1000;

    const uploadWithRetry = async (op: any): Promise<{ success: boolean; error?: string }> => {
      const { table, opData } = op;

      for (let attempt = 1; attempt <= UPLOAD_RETRIES; attempt++) {
        try {
          let result;

          if (op.op === UpdateType.PUT) {
            result = await supabase.from(table).upsert(opData, { onConflict: 'id' });
          } else if (op.op === UpdateType.PATCH) {
            result = await supabase.from(table).update(opData).eq('id', opData.id);
          } else if (op.op === UpdateType.DELETE) {
            result = await supabase.from(table).delete().eq('id', opData.id);
          } else {
            return { success: false, error: `Unknown operation type: ${op.op}` };
          }

          if (result.error) {
            const statusCode = result.error?.code;
            
            if (attempt < UPLOAD_RETRIES && ['PGRST116', 'PGRST301', 'Connection'].some(c => statusCode?.includes(c))) {
              const delayMs = RETRY_DELAY * attempt;
              console.warn(`âš ï¸ [${table}] Retry ${attempt}/${UPLOAD_RETRIES} in ${delayMs}ms:`, result.error.message);
              await new Promise(resolve => setTimeout(resolve, delayMs));
              continue;
            }

            return { success: false, error: result.error.message };
          }

          console.log(`âœ… [${table}] ${op.op === UpdateType.PUT ? 'Upserted' : op.op === UpdateType.PATCH ? 'Updated' : 'Deleted'} successfully (attempt ${attempt})`);
          return { success: true };
        } catch (error: any) {
          const isLastAttempt = attempt === UPLOAD_RETRIES;
          console.error(`âŒ [${table}] Upload error (attempt ${attempt}/${UPLOAD_RETRIES}):`, error?.message);

          if (isLastAttempt) {
            return { success: false, error: error?.message };
          }

          const delayMs = RETRY_DELAY * attempt;
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
      }

      return { success: false, error: 'Max retries exceeded' };
    };

    try {
      let successCount = 0;
      let failCount = 0;
      const failures = [];

      for (const op of transaction.crud) {
        const result = await uploadWithRetry(op);
        if (result.success) {
          successCount++;
        } else {
          failCount++;
          failures.push({ table: op.table, error: result.error });
        }
      }

      if (failCount === 0) {
        console.log(`âœ… Upload complete: ${successCount} operations successful`);
        await transaction.complete();
      } else {
        console.warn(`âš ï¸ Upload partial: ${successCount} successful, ${failCount} failed`);
        console.error('Failed operations:', failures);
        await transaction.complete();
      }
    } catch (error: any) {
      console.error('âŒ Upload transaction failed:', error?.message);
    }
  }
}
</file>

<file path="services/obstetricsService.ts">
import { powerSyncDb } from '../src/powersync/client';
import { authService } from './authService';
import { Pregnancy, AntenatalVisit, BiometryScan } from '../types';

// ============================================================================
// CALCULATION FUNCTIONS
// ============================================================================

export const calculateGestationalAge = (lmpDate: string | null | undefined): { weeks: number; days: number } => {
  if (!lmpDate || typeof lmpDate !== 'string' || lmpDate.trim() === '') {
    return { weeks: 0, days: 0 };
  }

  try {
    const timestamp = new Date(lmpDate).getTime();
    if (isNaN(timestamp)) {
      return { weeks: 0, days: 0 };
    }

    const today = new Date();
    const lmp = new Date(timestamp);
    const diffTime = Math.abs(today.getTime() - lmp.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    const weeks = Math.max(0, Math.floor(diffDays / 7));
    const days = Math.max(0, diffDays % 7);

    if (isNaN(weeks) || isNaN(days)) {
      return { weeks: 0, days: 0 };
    }

    return { weeks, days };
  } catch (error) {
    console.warn('Invalid LMP date provided to calculateGestationalAge:', lmpDate);
    return { weeks: 0, days: 0 };
  }
};

export const calculateEDD = (lmpDate: string | null | undefined): string => {
  if (!lmpDate || typeof lmpDate !== 'string' || lmpDate.trim() === '') {
    return '';
  }

  try {
    const timestamp = new Date(lmpDate).getTime();
    if (isNaN(timestamp)) {
      return '';
    }

    const lmp = new Date(timestamp);
    if (!lmp || isNaN(lmp.getTime())) {
      return '';
    }

    lmp.setDate(lmp.getDate() + 280);
    const eddString = lmp.toISOString().split('T')[0];

    if (!eddString) {
      return '';
    }

    return eddString;
  } catch (error) {
    console.warn('Invalid LMP date provided to calculateEDD:', lmpDate);
    return '';
  }
};

export const calculateGAFromEDD = (eddDate: string): { weeks: number; days: number } => {
  const today = new Date();
  const edd = new Date(eddDate);
  const diffTime = edd.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  const totalDaysToEDD = Math.max(0, diffDays);
  const totalGADays = 40 * 7 - totalDaysToEDD;
  const gaWeeks = Math.floor(totalGADays / 7);
  const gaDays = totalGADays % 7;
  return { weeks: Math.max(0, gaWeeks), days: Math.max(0, gaDays) };
};

// Hadlock formula for Estimated Fetal Weight (EFW)
export const calculateEFW = (
  bpdMm: number | null | undefined,
  hcMm: number | null | undefined,
  acMm: number | null | undefined,
  flMm: number | null | undefined
): number => {
  const inputs = [bpdMm, hcMm, acMm, flMm];

  if (inputs.some(input => input === null || input === undefined || isNaN(Number(input)))) {
    return 0;
  }

  const bpd = Number(bpdMm);
  const hc = Number(hcMm);
  const ac = Number(acMm);
  const fl = Number(flMm);

  if (bpd <= 0 || hc <= 0 || ac <= 0 || fl <= 0) {
    return 0;
  }

  try {
    const log10EFW =
      1.3404 +
      0.0438 * hc +
      0.158 * ac +
      0.0061 * bpd -
      0.002322 * ac * bpd;

    if (isNaN(log10EFW) || !isFinite(log10EFW)) {
      return 0;
    }

    const efw = Math.pow(10, log10EFW);

    if (isNaN(efw) || !isFinite(efw) || efw < 100 || efw > 5000) {
      return 0;
    }

    return Math.round(efw);
  } catch (error) {
    console.warn('Error calculating EFW with inputs:', { bpdMm, hcMm, acMm, flMm });
    return 0;
  }
};

// Calculate percentile based on RCOG/NICE standards (simplified)
export const calculatePercentile = (efwGrams: number, gaWeeks: number): number => {
  const expectedWeights: { [key: number]: { p10: number; p50: number; p90: number } } = {
    20: { p10: 300, p50: 330, p90: 370 },
    22: { p10: 430, p50: 475, p90: 540 },
    24: { p10: 600, p50: 660, p90: 750 },
    26: { p10: 760, p50: 850, p90: 980 },
    28: { p10: 1000, p50: 1100, p90: 1270 },
    30: { p10: 1300, p50: 1440, p90: 1680 },
    32: { p10: 1600, p50: 1840, p90: 2150 },
    34: { p10: 2100, p50: 2450, p90: 2850 },
    36: { p10: 2600, p50: 3000, p90: 3500 },
    38: { p10: 3000, p50: 3400, p90: 3900 },
    40: { p10: 3200, p50: 3500, p90: 3900 },
  };

  const weights = expectedWeights[gaWeeks];
  if (!weights) return 50;

  if (efwGrams <= weights.p10) return 10;
  if (efwGrams >= weights.p90) return 90;
  if (efwGrams <= weights.p50) {
    return 10 + ((efwGrams - weights.p10) / (weights.p50 - weights.p10)) * 40;
  }
  return 50 + ((efwGrams - weights.p50) / (weights.p90 - weights.p50)) * 40;
};

// ============================================================================
// RISK ASSESSMENT
// ============================================================================

export interface RiskFactors {
  age_over_40: boolean;
  bmi_over_30: boolean;
  previous_preeclampsia: boolean;
  twins: boolean;
  autoimmune: boolean;
  hypertension: boolean;
  diabetes: boolean;
  kidney_disease: boolean;
}

export const assessRiskLevel = (
  riskFactors: RiskFactors | null | undefined
): {
  level: 'low' | 'moderate' | 'high';
  riskFactorsList: string[];
  aspirinNeeded: boolean;
  thromboprophylaxisNeeded: boolean;
} => {
  // Provide safe defaults if riskFactors is null/undefined
  const safeRiskFactors = riskFactors || {
    age_over_40: false,
    bmi_over_30: false,
    previous_preeclampsia: false,
    twins: false,
    autoimmune: false,
    hypertension: false,
    diabetes: false,
    kidney_disease: false,
  };

  const highRiskFactors = [
    safeRiskFactors.previous_preeclampsia,
    safeRiskFactors.hypertension,
    safeRiskFactors.kidney_disease,
    safeRiskFactors.diabetes,
    safeRiskFactors.autoimmune,
  ].filter(Boolean).length;

  const moderateRiskFactors = [
    safeRiskFactors.age_over_40,
    safeRiskFactors.bmi_over_30,
    safeRiskFactors.twins,
  ].filter(Boolean).length;

  let level: 'low' | 'moderate' | 'high' = 'low';
  let aspirinNeeded = false;
  let thromboprophylaxisNeeded = false;
  const riskFactorsList: string[] = [];

  if (highRiskFactors >= 1) {
    level = 'high';
    aspirinNeeded = true;
  } else if (moderateRiskFactors >= 2) {
    level = 'high';
    aspirinNeeded = true;
  } else if (moderateRiskFactors >= 1 || highRiskFactors === 0) {
    level = 'moderate';
  }

  if (safeRiskFactors.twins) {
    thromboprophylaxisNeeded = true;
  }

  if (safeRiskFactors.age_over_40) riskFactorsList.push('Age > 40');
  if (safeRiskFactors.bmi_over_30) riskFactorsList.push('BMI > 30');
  if (safeRiskFactors.previous_preeclampsia) riskFactorsList.push('Previous Pre-eclampsia');
  if (safeRiskFactors.twins) riskFactorsList.push('Multiple Pregnancy');
  if (safeRiskFactors.autoimmune) riskFactorsList.push('Autoimmune Disease');
  if (safeRiskFactors.hypertension) riskFactorsList.push('Hypertension');
  if (safeRiskFactors.diabetes) riskFactorsList.push('Diabetes');
  if (safeRiskFactors.kidney_disease) riskFactorsList.push('Kidney Disease');

  return { level, riskFactorsList, aspirinNeeded, thromboprophylaxisNeeded };
};

// ============================================================================
// DUE ACTIONS / ALERTS
// ============================================================================

export const getDueActions = (gaWeeks: number): string[] => {
  const actions: string[] = [];

  // Early pregnancy actions
  if (gaWeeks >= 11 && gaWeeks <= 13) {
    actions.push('âš ï¸ Nuchal Translucency (NT) Scan Due');
  }
  if (gaWeeks >= 15 && gaWeeks <= 20) {
    actions.push('âš ï¸ Quad Screen / NIPT Results Expected');
  }
  if (gaWeeks >= 20 && gaWeeks <= 22) {
    actions.push('âš ï¸ Mid-Trimester Anomaly Scan Due');
  }
  if (gaWeeks === 28) {
    actions.push('ğŸ’‰ Anti-D Prophylaxis Due (if Rh negative)');
    actions.push('ğŸ§ª Glucose Tolerance Test (GTT) Due');
    actions.push('ğŸ’‰ Tetanus Booster if needed');
  }
  if (gaWeeks >= 34 && gaWeeks <= 36) {
    actions.push('âš ï¸ Growth Scan Recommended');
    actions.push('ğŸ§ª Full Blood Count (FBC)');
  }
  if (gaWeeks >= 36 && gaWeeks < 40) {
    actions.push('ğŸ‘¶ Position Check (Cephalic/Breech)');
    actions.push('ğŸ“‹ Discuss Birth Plan');
  }

  // CRITICAL: Post-term pregnancy alerts
  if (gaWeeks >= 40 && gaWeeks < 42) {
    actions.push('âš ï¸ Patient Overdue: Discuss Membrane Sweep / Induction - Ù…Ù†Ø§Ù‚Ø´Ø© ØªÙ…Ø²ÙŠÙ‚ Ø§Ù„Ø£ØºØ´ÙŠØ© / Ø§Ù„Ø­Ø« Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙ„Ø§Ø¯Ø©');
  }
  if (gaWeeks >= 41 && gaWeeks < 42) {
    actions.push('ğŸŸ  Late Term: Schedule Induction of Labor - Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø­Ø« Ø¹Ù„Ù‰ Ø§Ù„ÙˆÙ„Ø§Ø¯Ø©');
  }
  if (gaWeeks >= 42) {
    actions.push('ğŸ”´ POST TERM: CRITICAL - Immediate Delivery/Admission Required - Ø­Ù…Ù„ Ù…ØªØ£Ø®Ø± Ø¹Ù† Ø§Ù„Ù…ÙˆØ¹Ø¯ - ÙˆÙ„Ø§Ø¯Ø© ÙÙˆØ±ÙŠØ© Ù…Ø·Ù„ÙˆØ¨Ø©');
  }

  return actions;
};

// ============================================================================
// DATABASE OPERATIONS
// ============================================================================

export const obstetricsService = {
  // PREGNANCIES
  createPregnancy: async (pregnancy: Omit<Pregnancy, 'id' | 'created_at' | 'updated_at'>) => {
    const user = await authService.getCurrentUser();
    if (!user) throw new Error('Not authenticated');

    const doctor = await authService.ensureDoctorRecord(user.id, user.email || '');
    if (!doctor || !doctor.id) throw new Error('Doctor profile missing');

    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    await powerSyncDb.execute(
      `INSERT INTO pregnancies (id, patient_id, doctor_id, lmp_date, edd_date, edd_by_scan, risk_level, risk_factors, aspirin_prescribed, thromboprophylaxis_needed, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        pregnancy.patient_id,
        doctor.id,
        pregnancy.lmp_date,
        pregnancy.edd_date,
        pregnancy.edd_by_scan,
        pregnancy.risk_level,
        JSON.stringify(pregnancy.risk_factors || []),
        pregnancy.aspirin_prescribed ? 1 : 0,
        pregnancy.thromboprophylaxis_needed ? 1 : 0,
        now,
        now
      ]
    );

    return { id, ...pregnancy, created_at: now, updated_at: now };
  },

  getPregnancyByPatient: async (patientId: string) => {
    const pregnancies = await powerSyncDb.getAll(
      'SELECT * FROM pregnancies WHERE patient_id = ? ORDER BY created_at DESC',
      [patientId]
    ) as any[];

    if (pregnancies.length === 0) return null;

    const p = pregnancies[0];
    return {
      ...p,
      risk_factors: p.risk_factors ? JSON.parse(p.risk_factors) : [],
      aspirin_prescribed: p.aspirin_prescribed === 1,
      thromboprophylaxis_needed: p.thromboprophylaxis_needed === 1
    };
  },

  updatePregnancy: async (pregnancyId: string, updates: Partial<Pregnancy>) => {
    const setClauses = [];
    const values = [];
    const now = new Date().toISOString();

    if (updates.lmp_date !== undefined) { setClauses.push('lmp_date = ?'); values.push(updates.lmp_date); }
    if (updates.edd_date !== undefined) { setClauses.push('edd_date = ?'); values.push(updates.edd_date); }
    if (updates.edd_by_scan !== undefined) { setClauses.push('edd_by_scan = ?'); values.push(updates.edd_by_scan); }
    if (updates.risk_level !== undefined) { setClauses.push('risk_level = ?'); values.push(updates.risk_level); }
    if (updates.risk_factors !== undefined) { setClauses.push('risk_factors = ?'); values.push(JSON.stringify(updates.risk_factors)); }
    if (updates.aspirin_prescribed !== undefined) { setClauses.push('aspirin_prescribed = ?'); values.push(updates.aspirin_prescribed ? 1 : 0); }
    if (updates.thromboprophylaxis_needed !== undefined) { setClauses.push('thromboprophylaxis_needed = ?'); values.push(updates.thromboprophylaxis_needed ? 1 : 0); }

    setClauses.push('updated_at = ?');
    values.push(now);
    values.push(pregnancyId);

    await powerSyncDb.execute(
      `UPDATE pregnancies SET ${setClauses.join(', ')} WHERE id = ?`,
      values
    );
  },

  // ANTENATAL VISITS
  createANCVisit: async (visit: Omit<AntenatalVisit, 'id' | 'created_at'>) => {
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    await powerSyncDb.execute(
      `INSERT INTO antenatal_visits (id, pregnancy_id, visit_date, gestational_age_weeks, gestational_age_days, systolic_bp, diastolic_bp, weight_kg, urine_albuminuria, urine_glycosuria, fetal_heart_sound, fundal_height_cm, edema, edema_grade, notes, next_visit_date, prescription, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        visit.pregnancy_id,
        visit.visit_date,
        visit.gestational_age_weeks,
        visit.gestational_age_days,
        visit.systolic_bp,
        visit.diastolic_bp,
        visit.weight_kg,
        visit.urine_albuminuria,
        visit.urine_glycosuria,
        visit.fetal_heart_sound,
        visit.fundal_height_cm,
        visit.edema ? 1 : 0,
        visit.edema_grade,
        visit.notes,
        visit.next_visit_date,
        JSON.stringify(visit.prescription || []),
        now,
        now
      ]
    );

    return { id, ...visit, created_at: now };
  },

  getANCVisits: async (pregnancyId: string) => {
    const visits = await powerSyncDb.getAll(
      'SELECT * FROM antenatal_visits WHERE pregnancy_id = ? ORDER BY visit_date DESC',
      [pregnancyId]
    );

    return visits.map((v: any) => ({
      ...v,
      edema: v.edema === 1,
      prescription: v.prescription ? JSON.parse(v.prescription) : []
    }));
  },

  updateANCVisit: async (visitId: string, updates: Partial<AntenatalVisit>) => {
    const setClauses = [];
    const values = [];
    const now = new Date().toISOString();

    // Add fields to update... (simplified for brevity, add all fields as needed)
    if (updates.visit_date !== undefined) { setClauses.push('visit_date = ?'); values.push(updates.visit_date); }
    if (updates.notes !== undefined) { setClauses.push('notes = ?'); values.push(updates.notes); }
    // ... add other fields

    setClauses.push('updated_at = ?');
    values.push(now);
    values.push(visitId);

    await powerSyncDb.execute(
      `UPDATE antenatal_visits SET ${setClauses.join(', ')} WHERE id = ?`,
      values
    );
  },

  deleteANCVisit: async (visitId: string) => {
    await powerSyncDb.execute('DELETE FROM antenatal_visits WHERE id = ?', [visitId]);
  },

  // BIOMETRY SCANS
  createBiometryScan: async (scan: Omit<BiometryScan, 'id' | 'created_at'>) => {
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    await powerSyncDb.execute(
      `INSERT INTO biometry_scans (id, pregnancy_id, scan_date, gestational_age_weeks, gestational_age_days, bpd_mm, hc_mm, ac_mm, fl_mm, efw_grams, percentile, notes, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        scan.pregnancy_id,
        scan.scan_date,
        scan.gestational_age_weeks,
        scan.gestational_age_days,
        scan.bpd_mm,
        scan.hc_mm,
        scan.ac_mm,
        scan.fl_mm,
        scan.efw_grams,
        scan.percentile,
        scan.notes,
        now,
        now
      ]
    );

    return { id, ...scan, created_at: now };
  },

  getBiometryScans: async (pregnancyId: string) => {
    return (await powerSyncDb.getAll(
      'SELECT * FROM biometry_scans WHERE pregnancy_id = ? ORDER BY scan_date DESC',
      [pregnancyId]
    )) as BiometryScan[];
  },

  updateBiometryScan: async (scanId: string, updates: Partial<BiometryScan>) => {
    const setClauses = [];
    const values = [];
    const now = new Date().toISOString();

    if (updates.scan_date !== undefined) { setClauses.push('scan_date = ?'); values.push(updates.scan_date); }
    if (updates.notes !== undefined) { setClauses.push('notes = ?'); values.push(updates.notes); }
    // ... add other fields

    setClauses.push('updated_at = ?');
    values.push(now);
    values.push(scanId);

    await powerSyncDb.execute(
      `UPDATE biometry_scans SET ${setClauses.join(', ')} WHERE id = ?`,
      values
    );
  },

  deleteBiometryScan: async (scanId: string) => {
    await powerSyncDb.execute('DELETE FROM biometry_scans WHERE id = ?', [scanId]);
  },
};
</file>

<file path="src/services/syncService.ts">
// âš ï¸ Legacy sync system disabled
// Ø¯Ù‡ Stub Ø¨Ø³ÙŠØ· Ø¹Ø´Ø§Ù† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙŠØ´ØªØºÙ„ Ù…Ù† ØºÙŠØ± Ù…Ø§ Ù†Ø³ØªØ®Ø¯Ù… Dexie sync

export class SyncService {
  getSyncStatus() {
    return {
      isOnline: navigator.onLine,
      syncInProgress: false,
    };
  }

  async initializeSync(): Promise<void> {
    console.log('Legacy SyncService.initializeSync() called â€“ no-op (PowerSync in use).');
  }

  async forceSync(): Promise<void> {
    console.log('Legacy SyncService.forceSync() called â€“ no-op.');
  }

  fireAndForgetSync(): void {
    console.log('Legacy SyncService.fireAndForgetSync() called â€“ no-op.');
  }

  async saveItem(_table: string, _data: any): Promise<any> {
    console.log('Legacy SyncService.saveItem() called â€“ no-op (use Supabase / PowerSync instead).');
    return null;
  }

  async updateItem(_table: string, _localId: number, _data: any): Promise<void> {
    console.log('Legacy SyncService.updateItem() called â€“ no-op (use Supabase / PowerSync instead).');
  }

  async deleteItem(_table: string, _localId: number): Promise<void> {
    console.log('Legacy SyncService.deleteItem() called â€“ no-op (use Supabase / PowerSync instead).');
  }

  async pushPendingItems(): Promise<{ success: number; failed: number; errors: string[] }> {
    console.log('Legacy SyncService.pushPendingItems() called â€“ no-op.');
    return { success: 0, failed: 0, errors: [] };
  }

  async retryFailedItems(): Promise<number> {
    console.log('Legacy SyncService.retryFailedItems() called â€“ no-op.');
    return 0;
  }

  async save(_table: string, _data: any) {
    throw new Error('Legacy sync disabled â€“ use Supabase / PowerSync instead.');
  }

  async read(_table: string) {
    throw new Error('Legacy sync disabled â€“ use Supabase / PowerSync instead.');
  }

  async update(_table: string, _remoteId: string, _data: any) {
    throw new Error('Legacy sync disabled â€“ use Supabase / PowerSync instead.');
  }

  async delete(_table: string, _remoteId: string) {
    throw new Error('Legacy sync disabled â€“ use Supabase / PowerSync instead.');
  }
}

export const syncService = new SyncService();

// alias Ù„Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø§Ù„Ù„ÙŠ Ø¨ÙŠØ³ØªØ®Ø¯Ù… syncManager
export const syncManager = syncService;
</file>

<file path="App.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { Sidebar } from './components/Sidebar';
import BottomNav from './components/BottomNav';
// import SyncStatus from './components/SyncStatus';
import { Page } from './types';
import Dashboard from './pages/Dashboard';
import Reception from './pages/Reception';
import Gynecology from './pages/Gynecology';
import IvfJourney from './pages/IvfJourney';
import PatientMasterRecord from './pages/PatientMasterRecord';
import Settings from './pages/Settings';
import ObstetricsDashboard from './pages/ObstetricsDashboard';
import AdminDashboard from './pages/AdminDashboard';
import { Login } from './pages/Login';
import { Toaster } from 'react-hot-toast';
import { authService } from './services/authService';
import { LogOut, WifiOff, Wifi } from 'lucide-react';
import { BrandingProvider } from './context/BrandingContext';
import { initPWA } from './src/lib/pwa';
import { initPowerSync } from './src/powersync/client';
import { useStatus } from '@powersync/react';

const App: React.FC = () => {
  const [activePage, setActivePage] = useState<Page>(Page.HOME);
  const [user, setUser] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [isOffline, setIsOffline] = useState(!navigator.onLine);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const powerSyncStatus = useStatus();

  useEffect(() => {
    const handleStatusChange = () => setIsOffline(!navigator.onLine);
    window.addEventListener('online', handleStatusChange);
    window.addEventListener('offline', handleStatusChange);
    return () => {
      window.removeEventListener('online', handleStatusChange);
      window.removeEventListener('offline', handleStatusChange);
    };
  }, []);

  // Track retry attempts to prevent infinite loops
  const retryAttemptsRef = useRef(0);
  const lastRetryTimeRef = useRef(0);
  const hasGivenUpRef = useRef(false); // Flag to stop retrying after max attempts
  const MAX_RETRIES = 2; // Reduced to 2 attempts
  const RETRY_COOLDOWN = 60000; // 60 seconds cooldown between retry attempts

  useEffect(() => {
    // Only log status changes in development
    if (import.meta.env.DEV) {
      console.log('ğŸ”Œ PowerSync Status Change:', JSON.stringify(powerSyncStatus, null, 2));
      console.log('ğŸ”Œ Connected:', powerSyncStatus.connected);
      console.log('ğŸ”Œ Connecting:', powerSyncStatus.connecting);
    }
    
    // Stop retrying if we've given up
    if (hasGivenUpRef.current) {
      return;
    }
    
    // Auto-retry connection if disconnected but online
    if (!powerSyncStatus.connected && !powerSyncStatus.connecting && navigator.onLine && user) {
      const now = Date.now();
      const timeSinceLastRetry = now - lastRetryTimeRef.current;
      
      // Check if we should retry (cooldown period passed and haven't exceeded max retries)
      if (timeSinceLastRetry > RETRY_COOLDOWN && retryAttemptsRef.current < MAX_RETRIES) {
        retryAttemptsRef.current++;
        lastRetryTimeRef.current = now;
        
        const timeoutId = setTimeout(async () => {
          console.log(`ğŸ”„ Auto-retrying PowerSync connection (attempt ${retryAttemptsRef.current}/${MAX_RETRIES})...`);
          try {
            await initPowerSync();
            // Reset retry counter on success
            if (powerSyncStatus.connected) {
              retryAttemptsRef.current = 0;
              hasGivenUpRef.current = false;
            }
          } catch (error: any) {
            console.warn('âš ï¸ Auto-retry failed:', error?.message);
            if (retryAttemptsRef.current >= MAX_RETRIES) {
              hasGivenUpRef.current = true;
              console.warn('âš ï¸ Max retry attempts reached. PowerSync will work in offline mode.');
              console.warn('âš ï¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…ØªØ§Ø­Ø© Ù…Ù† Supabase Ù…Ø¨Ø§Ø´Ø±Ø© Ø­ØªÙ‰ ÙŠØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„.');
            }
          }
        }, 10000); // Retry after 10 seconds
        
        return () => clearTimeout(timeoutId);
      } else if (retryAttemptsRef.current >= MAX_RETRIES) {
        if (!hasGivenUpRef.current) {
          hasGivenUpRef.current = true;
          console.warn('âš ï¸ Max retry attempts reached. PowerSync will work in offline mode.');
          console.warn('âš ï¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…ØªØ§Ø­Ø© Ù…Ù† Supabase Ù…Ø¨Ø§Ø´Ø±Ø© Ø­ØªÙ‰ ÙŠØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„.');
        }
      }
    } else if (powerSyncStatus.connected) {
      // Reset retry counter when connected
      retryAttemptsRef.current = 0;
      hasGivenUpRef.current = false;
    }
  }, [powerSyncStatus, user]);

  useEffect(() => {
    const initializeApp = async () => {
      try {
        setLoading(true);
        setConnectionError(null);

        // 1. Initialize PWA
        initPWA().catch(console.warn);

        // 2. Check user authentication
        let currentUser;
        try {
          currentUser = await authService.getCurrentUser();
        } catch (authError: any) {
          console.warn('âš ï¸ Auth check failed (offline mode):', authError?.message);
          // Continue without auth error - offline mode may still work
        }
        setUser(currentUser);

        // 3. Initialize PowerSync (non-blocking)
        if (currentUser) {
          console.log('ğŸ“± App: User authenticated, initializing PowerSync...');
          try {
            await initPowerSync();
          } catch (syncError: any) {
            console.warn('âš ï¸ PowerSync init failed (app will work offline):', syncError?.message);
            // Log detailed error for debugging
            if (syncError?.message?.includes('Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©')) {
              console.error('âŒ Environment variables missing. Please check .env file');
            }
            // Don't set error - app can work offline
          }
        }

      } catch (error: any) {
        console.error('âŒ Critical App Initialization Error:', error?.message);
        // Only set error if it's truly critical (auth failure with online)
        if (navigator.onLine && error?.message?.includes('auth')) {
          setConnectionError('Authentication failed. Please check your connection and reload.');
        }
      } finally {
        setLoading(false);
      }
    };

    console.log('ğŸš€ App useEffect: Starting initialization...');
    console.log('ğŸ“± Browser online status:', navigator.onLine);

    // Suppress manifest.json 401 errors (non-critical, browser will use manifest.webmanifest)
    const suppressManifestErrors = () => {
      const originalError = window.console.error;
      window.console.error = (...args: any[]) => {
        const message = args[0]?.toString() || '';
        if (message.includes('manifest.json') && (message.includes('401') || message.includes('Failed to load'))) {
          // Suppress - non-critical error, manifest.webmanifest will be used instead
          return;
        }
        originalError.apply(console, args);
      };
      
      // Restore after 5 seconds
      setTimeout(() => {
        window.console.error = originalError;
      }, 5000);
    };
    suppressManifestErrors();

    // Check if worker file exists (non-blocking)
    if (navigator.onLine) {
      fetch('/powersync.worker.js')
        .then(res => {
          console.log('ğŸ‘· Worker file check:', res.status, res.statusText);
          if (!res.ok) console.warn('âš ï¸ Worker file might not be accessible');
        })
        .catch(err => console.warn('âš ï¸ Could not check worker file:', err?.message));
    }

    initializeApp();

    let lastUserId: string | null = null;
    let isPowerSyncInitialized = false;
    
    const subscription = authService.onAuthStateChange(async (user) => {
      const currentUserId = user?.id || null;
      
      // Only initialize PowerSync if user actually changed (not just auth state refresh)
      if (user && currentUserId !== lastUserId) {
        lastUserId = currentUserId;
        
        // Reset retry flags on new login
        retryAttemptsRef.current = 0;
        hasGivenUpRef.current = false;
        
        // Only initialize once per user session
        if (!isPowerSyncInitialized) {
          isPowerSyncInitialized = true;
          console.log('ğŸ“± App: Auth state changed (new user), initializing PowerSync...');
          try {
            await initPowerSync();
            setConnectionError(null);
          } catch (err: any) {
            console.warn('âš ï¸ PowerSync connection failed (offline mode will be used):', err?.message);
            // Log detailed error for debugging
            if (err?.message?.includes('Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©')) {
              console.error('âŒ Please check your .env file for missing variables');
            }
            // Don't set error for PowerSync failures - offline mode is expected
            // Data will be available directly from Supabase
            isPowerSyncInitialized = false; // Allow retry on next auth change
          }
        } else {
          console.log('ğŸ“± App: Auth state changed but PowerSync already initialized, skipping...');
        }
      } else if (!user) {
        // Reset flags on logout
        lastUserId = null;
        isPowerSyncInitialized = false;
        retryAttemptsRef.current = 0;
        hasGivenUpRef.current = false;
      } else {
        // Same user, just auth state refresh - don't reinitialize
        // Only log occasionally to reduce spam
        if (Math.random() < 0.1) {
          console.log('ğŸ“± App: Auth state refresh (same user), skipping PowerSync init...');
        }
      }
      
      setUser(user);
    });

    return () => {
      if (subscription && typeof subscription.unsubscribe === 'function') {
        subscription.unsubscribe();
      }
    };
  }, []);

  const handleLogout = async () => {
    try {
      await authService.logout();
      setUser(null);
      setActivePage(Page.HOME);
    } catch (error) {
      console.error('Logout error:', error);
      // Force logout locally even if server fails
      setUser(null);
      localStorage.clear();
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
          <p className="text-gray-600 font-[Tajawal]">
            {isOffline ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ ÙÙŠ ÙˆØ¶Ø¹ Ø¹Ø¯Ù… Ø§Ù„Ø§ØªØµØ§Ù„...' : 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...'}
          </p>
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <>
        <Login onLoginSuccess={() => setActivePage(Page.HOME)} />
        <Toaster position="top-center" reverseOrder={false} />
      </>
    );
  }

  const renderContent = () => {
    switch (activePage) {
      case Page.HOME: return <Dashboard />;
      case Page.RECEPTION: return <Reception />;
      case Page.GYNECOLOGY: return <Gynecology />;
      case Page.IVF: return <IvfJourney />;
      case Page.OBSTETRICS: return <ObstetricsDashboard />;
      case Page.PATIENT_RECORD: return <PatientMasterRecord />;
      case Page.SETTINGS: return <Settings user={user} />;
      case Page.ADMIN: return <AdminDashboard />;
      default: return <Dashboard />;
    }
  };

  return (
    <BrandingProvider>
      <div className="min-h-screen bg-gray-50 flex flex-col md:flex-row-reverse font-[Tajawal]">
        <div className="hidden md:flex">
          <Sidebar activePage={activePage} setPage={setActivePage} onLogout={handleLogout} />
        </div>

        <main className="flex-1 md:mr-64 p-4 md:p-8 transition-all duration-300 no-print pb-20 md:pb-0">
          <div className="max-w-7xl mx-auto">
            {/* Desktop Header */}
            <div className="hidden md:flex justify-between items-center mb-6">
              <div className="flex items-center gap-3">
                <h1 className="text-2xl font-bold text-gray-900">
                  Ù…Ø±Ø­Ø¨Ø§Ù‹ØŒ {user?.email}
                </h1>
                {isOffline && (
                  <span className="flex items-center gap-1 px-3 py-1 bg-gray-200 text-gray-700 rounded-full text-xs font-bold">
                    <WifiOff size={14} />
                    Ø§Ù„Ù…ØªØµÙØ­ Ø£ÙˆÙÙ„Ø§ÙŠÙ†
                  </span>
                )}
                {powerSyncStatus.connecting && (
                  <span className="flex items-center gap-1 px-3 py-1 bg-yellow-100 text-yellow-700 rounded-full text-xs font-bold animate-pulse" title="Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±...">
                    <Wifi size={14} className="animate-spin" />
                    Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„...
                  </span>
                )}
                {!powerSyncStatus.connected && !powerSyncStatus.connecting && (
                  <span 
                    className="flex items-center gap-1 px-3 py-1 bg-red-100 text-red-700 rounded-full text-xs font-bold cursor-help" 
                    title={`ØºÙŠØ± Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±${!navigator.onLine ? ' - Ø§Ù„Ù…ØªØµÙØ­ Ø£ÙˆÙÙ„Ø§ÙŠÙ†' : ' - Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹'}`}
                    onClick={async () => {
                      if (navigator.onLine) {
                        try {
                          await initPowerSync();
                        } catch (error: any) {
                          console.error('âŒ Manual retry failed:', error?.message);
                        }
                      }
                    }}
                  >
                    <WifiOff size={14} />
                    ØºÙŠØ± Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±
                  </span>
                )}
                {powerSyncStatus.connected && (
                  <span className="flex items-center gap-1 px-3 py-1 bg-green-100 text-green-700 rounded-full text-xs font-bold" title={`Ù…ØªØµÙ„ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±${powerSyncStatus.lastSyncedAt ? ` - Ø¢Ø®Ø± Ù…Ø²Ø§Ù…Ù†Ø©: ${new Date(powerSyncStatus.lastSyncedAt).toLocaleTimeString('ar-EG')}` : ''}`}>
                    <Wifi size={14} />
                    Ù…ØªØµÙ„
                  </span>
                )}
              </div>
              <div className="flex items-center gap-4">
                {/* <SyncStatus /> */}
                <button
                  onClick={handleLogout}
                  className="flex items-center gap-2 px-4 py-2 bg-red-50 hover:bg-red-100 text-red-600 rounded-lg transition duration-200 font-[Tajawal]"
                >
                  <LogOut size={18} />
                  ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬
                </button>
              </div>
            </div>

            {/* Mobile Header */}
            <div className="md:hidden mb-4 flex justify-between items-center">
              {/* <SyncStatus /> */}
              <div className="text-center flex-1">
                <h1 className="text-xl font-bold text-gray-900">
                  Ù…Ø±Ø­Ø¨Ø§Ù‹ØŒ {user?.email?.split('@')[0]}
                </h1>
                {isOffline && <p className="text-xs text-gray-500 flex justify-center items-center gap-1"><WifiOff size={10} /> ÙˆØ¶Ø¹ Ø£ÙˆÙÙ„Ø§ÙŠÙ†</p>}
              </div>
              <div className="w-5"></div>
            </div>

            {renderContent()}
          </div>
        </main>

        <BottomNav activePage={activePage} setPage={setActivePage} onLogout={handleLogout} />

        <Toaster position="top-center" reverseOrder={false} />
      </div>
    </BrandingProvider>
  );
};

export default App;
</file>

</files>
